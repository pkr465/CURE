/*
 * Copyright (c) 2016-2024 Qualcomm Innovation Center, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Innovation Center, Inc.
 *
 * 2016 Qualcomm Atheros, Inc.
 * All Rights Reserved.
 * Qualcomm Atheros Confidential and Proprietary.
 */

#if UMAC_SUPPORT_CFG80211
#ifdef QCA_SUPPORT_EAPOL_OVER_CONTROL_PORT
#include <linux/netdevice.h>
#endif
#include <ieee80211_cfg80211.h>
#include <osif_private.h>
#include <ieee80211_defines.h>
#include <ieee80211_var.h>
#include <i_qdf_mem.h>
#include <if_athioctl.h>
#include <wlan_cfg80211_afc.h>
#include <ol_if_athvar.h>
#include <ol_ath_ucfg.h>
#include <ieee80211_regdmn.h>
#include "cdp_txrx_cmn.h"
#include "cdp_txrx_cmn_reg.h"
#include "cdp_txrx_ctrl.h"
#include <ieee80211_ucfg.h>
#include <linux/proc_fs.h>
#ifdef WLAN_FEATURE_11BE_MLO
#include <dp_me.h>
#endif
#include "ieee80211_crypto_nlshim_api.h"
#include <ext_ioctl_drv_if.h>
#include <ol_if_thermal.h>
#include <qdf_types.h>
#include <ieee80211_var.h>
#include <wlan_tgt_def_config.h>
#include <target_if.h>
#include <wlan_telemetry_agent.h>
#include "qwrap_structure.h"
#if QCA_AIRTIME_FAIRNESS
#include <wlan_atf_ucfg_api.h>
#endif
#include <init_deinit_ops.h>
#include <wlan_osif_priv.h>
#include <wlan_cfg80211_scan.h>
#include <wlan_cfg80211_gpio.h>
#include <wlan_cfg80211_spectral.h>
#include <wlan_dfs_ucfg_api.h>
#include <wlan_reg_services_api.h>
#include "ieee80211_mlme_priv.h"
#include <reg_services_public_struct.h>
#include <wlan_reg_channel_api.h>
#ifdef WLAN_SUPPORT_FILS
#include <wlan_fd_utils_api.h>
#endif /* WLAN_SUPPORT_FILS */
#include <dp_rate_stats_pub.h>
#include <wlan_utility.h>
#include <wlan_cfg80211.h>
#include <ieee80211_api.h>
#include <wlan_mlme_dispatcher.h>
#if ATH_SUPPORT_DFS
#include "ieee80211_mlme_dfs_dispatcher.h"
#endif
#if ATH_ACS_DEBUG_SUPPORT
#include <acs_debug.h>
#endif
#include <ieee80211_acs_internal.h>
#include <ieee80211_ioctl_acfg.h>
#if QLD
#include <qld_api.h>
#endif
#ifdef WLAN_MGMT_RX_REO_SUPPORT
#include <wlan_mgmt_txrx_rx_reo_ucfg_api.h>
#endif
#include <wlan_mgmt_txrx_rx_reo_utils_api.h>
#include "target_type.h"
#ifdef QCA_NSS_WIFI_OFFLOAD_SUPPORT
#include <osif_nss_wifiol_vdev_if.h>
#include <osif_nss_wifiol_if.h>
#endif
#if WLAN_SPECTRAL_ENABLE
#include <wlan_spectral_public_structs.h>
#endif
#if QCA_SUPPORT_SON
#include <wlan_son_pub.h>
#endif
#include <osif_cm_req.h>
#include <wlan_cm_api.h>
#include <wlan_repeater_api.h>
#include <ieee80211_nl.h>
#ifdef WLAN_FEATURE_11BE_MLO
#include <wlan_mlo_mgr_peer.h>
#include <ieee80211_objmgr_priv.h>
#endif
#include <wlan_mbss.h>
#ifdef WIFI_MONITOR_SUPPORT
#include <dp_mon_ol.h>
#endif
#include <wlan_mlme_if.h>
#include <cfg80211_external.h>
#include <wlan_cmn_ieee80211.h>
#if CONFIG_AFC_SUPPORT
#include <wlan_reg_afc.h>
#endif /* CONFIG_AFC_SUPPORT */
#include <wlan_reg_ucfg_api.h>
#include <wlan_mlo_mgr_sta.h>
#ifdef CONFIG_SAWF_DEF_QUEUES
#include <wlan_sawf.h>
#endif
#if WLAN_SUPPORT_SPLITMAC
#include <wlan_splitmac.h>
#endif
#ifdef WLAN_FEATURE_11BE_MLO
#include <wlan_mlo_mgr_ap.h>
#include <wlan_mlo_mgr_setup.h>
#endif
#ifdef WLAN_FEATURE_11BE_MLO
#include <utils_mlo.h>
#include <wlan_scan_utils_api.h>
#endif
#if DBDC_REPEATER_SUPPORT
#include <qca_multi_link.h>
#endif

#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
#include <wlan_nl_to_crypto_params.h>
#include <wifi_pos_ucfg_i.h>
#include <wifi_pos_pasn_api.h>
#include <wlan_cfg80211_wifi_pos.h>
#endif

#ifdef WLAN_FEATURE_11BE
#include <wlan_mlo_t2lm.h>
#ifdef QCA_SUPPORT_RDKB
#include <linux/nl80211.h>
#endif
#endif

#ifdef CONFIG_BOND_MOD_SUPPORT
#include <qal_bond.h>
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
#include <linux/overflow.h>
#endif

#ifdef WLAN_SUPPORT_SCS_API
#include <qca_scs_api_if.h>
#endif
#include <wlan_mlme_vdev_mgmt_ops.h>

#define MAX_BUFFER_LEN 1180
#define RADIO_CMD 1
#define VAP_CMD 0
#define REPLY_SKB_SIZE ((2*sizeof(u_int32_t)) + NLMSG_HDRLEN)
#define LIST_ALLOC_SIZE (3 * 1024)
#define LIST_STATION_CFG_ALLOC_SIZE 3500
#define MAX_CFG80211_BUF_LEN 4000
#define MAX_NSS_INTERFACE_NUM 256
#define CFG80211_GET_CHAN_SURVEY_HOME_CHANNEL_STATS (1)
#define CFG80211_GET_CHAN_SURVEY_SCAN_CHANNEL_STATS (2)
#define ENABLE_MC_TO_UC (5)
#define DISABLE_MC_TO_UC (0)
#ifdef QCA_SUPPORT_EAPOL_OVER_CONTROL_PORT
#define COOKIE_LEN 16
#endif

#define print_eacs_chanlist(list, len)                    \
    do {                                                  \
    int j;                                                \
    qdf_print("channel count:%d \nchannel list: ",(len)); \
    for (j = 0;j < (len);j++) {                           \
        qdf_print("%d  ", (list)[j]);                     \
    }                                                     \
    qdf_print("\n");                                      \
} while(0)

#ifdef WLAN_FEATURE_11BE_MLO
struct cfg80211_mld_wiphy_context mld_wiphy_ctx[WLAN_MAX_MLO_GROUPS];
#endif

extern int wlan_update_peer_cp_stats(struct ieee80211_node *ni,

                                     struct ieee80211_nodestats *ni_stats_user);
extern int
wlan_get_peer_dp_stats(struct ieee80211com *ic,
                       struct wlan_objmgr_peer *peer,
                       struct ieee80211_nodestats *ni_stats_user,
                       const uint8_t *mld_mac, bool is_ml_peer);

struct ieee80211_regdomain wlan_cfg80211_world_regdom_60_61_62 = {
    .n_reg_rules = 8,
    .alpha2 =  "00",
    .reg_rules = {
        REG_RULE_2412_2462,
        REG_RULE_2467_2472,
        REG_RULE_2484,
        REG_RULE_5180_5320,
        REG_RULE_5500_5640,
        REG_RULE_5660_5720,
        REG_RULE_5745_5925,
        REG_RULE_5955_7115,
    }
};

/* enums to parse netlink messages sent by FTM daemon */
enum wlan_tm_attr {
    WLAN_TM_ATTR_INVALID = 0,
    WLAN_TM_ATTR_CMD = 1,
    WLAN_TM_ATTR_DATA = 2,
    /* keep last */
    WLAN_TM_ATTR_MAX,
};

enum wlan_tm_cmd {
    WLAN_TM_CMD_WLAN_FTM = 0,
    WLAN_TM_CMD_WLAN_HB = 1,
};

#define WLAN_TM_DATA_MAX_LEN    5000
#define MAX_DEFAULT_SCAN_IE_LEN 2048

static const struct nla_policy wlan_tm_policy[WLAN_TM_ATTR_MAX] = {
    [WLAN_TM_ATTR_CMD] = {.type = NLA_U32},
    [WLAN_TM_ATTR_DATA] = {.type = NLA_BINARY,
                           .len = WLAN_TM_DATA_MAX_LEN},
};

static const struct nla_policy
wlan_cfg80211_setget_wificonfiguration_policy
[QCA_WLAN_VENDOR_ATTR_CONFIG_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_COMMAND] = {.type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_VALUE] = {.type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_DATA] = {.type = NLA_BINARY },
    [QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_LENGTH] = {.type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_FLAGS] = {.type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_CONFIG_PHY_MODE] = {.type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_CONFIG_CHANNEL_WIDTH] = {.type = NLA_U32 },
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    [QCA_WLAN_VENDOR_ATTR_CONFIG_MLO_LINK_ID] = {.type = NLA_U8 },
#endif
};

static const struct nla_policy
scan_policy[QCA_WLAN_VENDOR_ATTR_SCAN_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_SCAN_DWELL_TIME] = {.type = NLA_U64},
    [QCA_WLAN_VENDOR_ATTR_SCAN_FLAGS] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SCAN_TX_NO_CCK_RATE] = {.type = NLA_FLAG},
    [QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE] = {.type = NLA_U64},
    [QCA_WLAN_VENDOR_ATTR_SCAN_IE] = {.type = NLA_BINARY,
                                      .len = MAX_DEFAULT_SCAN_IE_LEN},
    [QCA_WLAN_VENDOR_ATTR_SCAN_PRIORITY] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SCAN_MAC] = VENDOR_NLA_POLICY_MAC_ADDR,
    [QCA_WLAN_VENDOR_ATTR_SCAN_MAC_MASK] = VENDOR_NLA_POLICY_MAC_ADDR,
    [QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_SCAN_SUPP_RATES] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_SCAN_BSSID] = {.type = NLA_BINARY},
    [QCA_WLAN_VENDOR_ATTR_SCAN_LINK_ID] = {.type = NLA_U8},
};

#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
static const struct nla_policy
wlan_cfg80211_pasn_auth_status_policy[QCA_WLAN_VENDOR_ATTR_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_PASN_ACTION] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_PASN_PEERS] = {.type = NLA_NESTED},
};

const struct nla_policy
wlan_cfg80211_pasn_auth_policy[QCA_WLAN_VENDOR_ATTR_PASN_PEER_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_PASN_PEER_SRC_ADDR] = VENDOR_NLA_POLICY_MAC_ADDR,
    [QCA_WLAN_VENDOR_ATTR_PASN_PEER_MAC_ADDR] = VENDOR_NLA_POLICY_MAC_ADDR,
    [QCA_WLAN_VENDOR_ATTR_PASN_PEER_STATUS_SUCCESS] = {.type = NLA_FLAG},
};

static const struct nla_policy
wlan_cfg80211_pasn_set_ranging_ctx_policy[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_ACTION] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_SRC_ADDR] =
        VENDOR_NLA_POLICY_MAC_ADDR,
    [QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_PEER_MAC_ADDR] =
        VENDOR_NLA_POLICY_MAC_ADDR,
    [QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_SHA_TYPE] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_TK] = {.type = NLA_BINARY,
        .len = MAX_PMK_LEN},
    [QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_CIPHER] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_LTF_KEYSEED] = {.type = NLA_BINARY,
        .len = MAX_PMK_LEN},
};

static const struct nla_policy
wlan_cfg80211_create_delete_pasn_auth_status_policy[QCA_WLAN_VENDOR_ATTR_MAX + 1] = {
	[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_ACTION] = {.type = NLA_U32},
	[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEERS] = {.type = NLA_NESTED},
};

static const struct nla_policy
wlan_cfg80211_create_delete_pasn_auth_policy[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAX + 1] = {
	[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_SRC_ADDR] = VENDOR_NLA_POLICY_MAC_ADDR,
	[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAC_ADDR] = VENDOR_NLA_POLICY_MAC_ADDR,
	[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_LTF_KEYSEED_REQUIRED] = {.type = NLA_FLAG},
	[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_STATUS_SUCCESS] = {.type = NLA_FLAG},
	[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_TYPE] = {.type = NLA_U32},
	[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_CONTROL_FLAG] = {.type = NLA_U16},
};
#endif

static const struct nla_policy
wlan_cfg80211_do_acs_policy[QCA_WLAN_VENDOR_ATTR_ACS_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_ACS_HW_MODE] = { .type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_ACS_HT_ENABLED] = { .type = NLA_FLAG },
    [QCA_WLAN_VENDOR_ATTR_ACS_HT40_ENABLED] = { .type = NLA_FLAG },
    [QCA_WLAN_VENDOR_ATTR_ACS_VHT_ENABLED] = { .type = NLA_FLAG },
    [QCA_WLAN_VENDOR_ATTR_ACS_CHWIDTH] = { .type = NLA_U16 },
    [QCA_WLAN_VENDOR_ATTR_ACS_CH_LIST] = { .type = NLA_BINARY },
    [QCA_WLAN_VENDOR_ATTR_ACS_FREQ_LIST] = { .type = NLA_BINARY },
    [QCA_WLAN_VENDOR_ATTR_ACS_EDMG_ENABLED] = { .type = NLA_FLAG },
    [QCA_WLAN_VENDOR_ATTR_ACS_EHT_ENABLED] = {.type = NLA_FLAG },
    [QCA_WLAN_VENDOR_ATTR_ACS_LINK_ID] = {.type = NLA_U8 },
};

#if STRICT_NLPOLICY_CHECKING
static const struct nla_policy
wlan_cfg80211_external_acs_policy
[QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_CHANNEL_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_CHANNEL_REASON] = { .type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_CHANNEL_LIST] = { .type = NLA_NESTED },
    [QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_FREQUENCY_LIST] = { .type = NLA_NESTED },
};

const struct nla_policy spectral_scan_policy
                      [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_SCAN_COUNT] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_SCAN_PERIOD] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_PRIORITY] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_FFT_SIZE] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_GC_ENA] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_RESTART_ENA] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_NOISE_FLOOR_REF] = {
                                                       .type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_INIT_DELAY] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_NB_TONE_THR] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_STR_BIN_THR] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_WB_RPT_MODE] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_RSSI_RPT_MODE] = {
                                                       .type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_RSSI_THR] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_PWR_FORMAT] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_RPT_MODE] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_BIN_SCALE] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_DBM_ADJ] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_CHN_MASK] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_REQUEST_TYPE] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_COOKIE] = {.type = NLA_U64},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_FFT_PERIOD] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_SHORT_REPORT] = {
                                                       .type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_DEBUG_LEVEL] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_FREQUENCY] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_FREQUENCY_2] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_MODE] = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_DMA_RING_DEBUG] = {
                                                       .type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_DMA_BUFFER_DEBUG] = {
                                                       .type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_BANDWIDTH] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_FFT_RECAPTURE] = {
                                                       .type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_DATA_TRANSPORT_MODE] = {
                                                       .type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_COMPLETION_TIMEOUT] = {
                                                       .type = NLA_U32},
  };


const struct nla_policy spectral_scan_get_status_policy
                         [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_STATUS_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_STATUS_IS_ENABLED] = {.type = NLA_FLAG},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_STATUS_IS_ACTIVE] = {.type = NLA_FLAG},
    [QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_STATUS_MODE] = {.type = NLA_U32},
};

#endif /* STRICT_NLPOLICY_CHECKING */

#ifdef WLAN_FEATURE_11BE
const struct nla_policy rm_generic_policy
        [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_APP_VERSION] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_DRIVER_VERSION] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_NUM_SOC_DEVICES] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SOC_DEVICE_INFO] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_TTLM_MAPPING] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_RELAYFS_FILE_NAME_PMLO] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_LINK_BW_NSS_CHANGE] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_RELAYFS_FILE_NAME_DETSCHED] = {.type = NLA_STRING},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_CATEGORY] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_NUM_LINKS] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_PEER_LINK_ENTRY] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_TTLM_INFO] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ERP] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SERVICE_ID] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SERVICE_DATA] = {.type = NLA_U64},
    [QCA_WLAN_VENDOR_ATTR_RM_GENERIC_DYNAMIC_INIT_CONF] = {.type = NLA_U8},
};

const struct nla_policy tid_to_link_mapping_policy
       [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLD_MAC] = {.type = NLA_BINARY,
                                                  .len = QDF_MAC_ADDR_SIZE},
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_CATEGORY] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_NUM_LINKS] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_DIALOG_TOKEN] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_T2LM_INFO] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_TX_STATUS] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MAPPING] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_RESPONSE_TYPE] = {.type = NLA_U8},
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_LINK_QUALIFIER] = {.type = NLA_NESTED},
    [QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_BTM_REQ_INFO] = {.type = NLA_NESTED},
};

#endif /* WLAN_FEATURE_11BE */

/**
 * wlan_cfg80211_set_qdepth_thresh_policy: Sets the nla_policy for the parsing
 * attributes for the command to set MSDUQ depth threshold params
 */
static const struct nla_policy
wlan_cfg80211_set_qdepth_thresh_policy
[QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_MAC_ADDR] = {.type = NLA_BINARY },
    [QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_TID] = {.type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_UPDATE_MASK] = {.type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_VALUE] = {.type = NLA_U32 },
};

static const struct
nla_policy qca_wlan_vendor_add_sta_node_attr
[QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_PARAM_MAX + 1 ] = {
    [QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_MAC_ADDR]  = {.type = NLA_BINARY,
                                             .len = QDF_MAC_ADDR_SIZE},
    [QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_AUTH_ALGO] = {.type = NLA_U16},
    [QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_IS_ML] = {.type = NLA_U16},
};

static const struct nla_policy
reconfig_req_policy[QCA_WLAN_VENDOR_ATTR_MLO_LINK_REMOVAL_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_MLO_LINK_REMOVAL_TBTT] = {.type = NLA_U32 },
};
static const struct nla_policy
reconfig_btmreq_policy[QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_MAC] = {.type = NLA_BINARY,
                                               .len = QDF_MAC_ADDR_SIZE },
    [QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_DISASSOC] = {.type = NLA_U16 },
    [QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_BSSTERM] = {.type = NLA_U64 },
};

static const struct nla_policy
qca_wlan_vendor_send_egid_attr
[QCA_WLAN_VENDOR_ATTR_SEND_EGID_MAX + 1 ] = {
    [QCA_WLAN_VENDOR_ATTR_SEND_EGID_1]  = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SEND_EGID_2]  = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SEND_EGID_3]  = {.type = NLA_U32},
    [QCA_WLAN_VENDOR_ATTR_SEND_EGID_4]  = {.type = NLA_U32},
};

#ifdef WLAN_SUPPORT_SCS
static const struct nla_policy
scs_config_resp_rule_id_policy[QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_MAX + 1 ] = {
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_RULE_ID] = {.type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_REQUEST_TYPE] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_OUTPUT_TID] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_CLASSIFIER_TYPE] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_VERSION] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_SRC_IPV4_ADDR] = VENDOR_NLA_POLICY_IPV4_ADDR,
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_DST_IPV4_ADDR] = VENDOR_NLA_POLICY_IPV4_ADDR,
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_SRC_IPV6_ADDR] = VENDOR_NLA_POLICY_IPV6_ADDR,
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_DST_IPV6_ADDR] = VENDOR_NLA_POLICY_IPV6_ADDR,
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_SRC_PORT] = {.type = NLA_U16 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_DST_PORT] = {.type = NLA_U16 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_DSCP] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_NEXT_HEADER] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_FLOW_LABEL] = {.type = NLA_BINARY },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS10_PROTOCOL_INSTANCE] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS10_NEXT_HEADER] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS10_FILTER_MASK] = {.type = NLA_BINARY },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS10_FILTER_VALUE] = {.type = NLA_BINARY },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_SERVICE_CLASS_ID] = {.type = NLA_U16 },
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_DST_MAC_ADDR] = VENDOR_NLA_POLICY_MAC_ADDR,
    [QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_NETDEV_IF_INDEX] = {.type = NLA_U32 },
};
#endif

#if WLAN_SUPPORT_TELEMETRY
static const struct nla_policy
telemetric_req_policy[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_LEVEL] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_OBJECT] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_TYPE] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_INFO] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_LINK_ID] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_FEATURE_FLAG] = {.type = NLA_U64 },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_STA_MAC] = {.type = NLA_BINARY,
                                                 .len = QDF_MAC_ADDR_SIZE },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_SERVICEID] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MLD_LINK] = {.type = NLA_FLAG },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_PEER_TYPE] = {.type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_TELEMETRIC_REQUEST_ID] = {.type = NLA_U64 },
};
#endif

#ifdef CONFIG_SAWF
static const struct nla_policy
qca_wlan_vendor_sla_policy[QCA_WLAN_VENDOR_ATTR_SLA_MAX + 1] = {
	[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC] = {.type = NLA_BINARY,
		                             .len = QDF_MAC_ADDR_SIZE },
	[QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID] = {.type = NLA_U8 },
	[QCA_WLAN_VENDOR_ATTR_SLA_PARAM] = {.type = NLA_U8 },
	[QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR] = {.type = NLA_U8 },
	[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC] = {.type = NLA_BINARY,
		                                 .len = QDF_MAC_ADDR_SIZE },
	[QCA_WLAN_VENDOR_ATTR_SLA_AC] = {.type = NLA_U8 },
	[QCA_WLAN_VENDOR_ATTR_SLA_MSDUQ_ID] = {.type = NLA_U8 },
	[QCA_WLAN_VENDOR_ATTR_SLA_HW_LINK_ID] = {.type = NLA_U16 },
};
#endif

struct tid_config{
   wlan_if_t vap;
   uint16_t noack_map;
};

/* funtion prototype */
static void clear_roam_params(wlan_if_t vap);

/*
 * wlan_cfg80211_set_channel_internal() - Set frequency to the radio
 * @ic: ic object handle
 * @vap: vap object handle
 * @chan_p: channel parameters
 * @command_type: command type
 *
 * This function sets the radio frequency
 *
 * Return: 0 on success, -EINVAL on failure
 */
static int wlan_cfg80211_set_channel_internal(struct ieee80211com *ic,
                                              wlan_if_t vap,
                                              struct chan_params *chan_p,
                                              enum command_execution_type command_type);

#ifdef WLAN_FEATURE_11BE_MLO
bool is_mld_phy(struct wiphy *wiphy)
{
    struct cfg80211_mld_wiphy_context *mld_cfg_ctx_grp0, *mld_cfg_ctx_grp1;
    mld_cfg_ctx_grp0 = &mld_wiphy_ctx[0];
    mld_cfg_ctx_grp1 = &mld_wiphy_ctx[1];

    if ((wiphy == mld_cfg_ctx_grp0->mld_wiphy) ||
            (wiphy == mld_cfg_ctx_grp1->mld_wiphy))
        return true;
    else
        return false;
}

static inline bool is_valid_sigle_phy_command(enum qca_nl80211_vendor_subcmds_internal cmd)
{
    bool result = false;

    switch (cmd) {
        case QCA_NL80211_VENDOR_SUBCMD_MCTBL_UPDATE:
        case QCA_NL80211_VENDOR_SUBCMD_T2LM:
        case QCA_NL80211_VENDOR_SUBCMD_LINK_INFO:
            result = true;
            break;
        case QCA_NL80211_VENDOR_SUBCMD_ENABLE_OL_STATS:
            result = true;
            break;
        default:
            result = false;
            break;
    }
    return result;
}
#else
static inline bool is_valid_sigle_phy_command(enum qca_nl80211_vendor_subcmds_internal cmd)
{
    return false;
}
#endif

/*
 * ieee80211_cfg80211_update_scanband:
 * Update the scan band configutation in the scan params for vendor scan.
 *
 * @osifp : Pointer to the private netdev object.
 * @params: Pointer to the scan_params.
 *
 * Return: void
 */
static void ieee80211_cfg80211_update_scanband(osif_dev *osifp,
                                               struct scan_params *params)
{
    if (!osifp) {
        qdf_err("Invalid osifp");
        return;
    }

    if (!params) {
        qdf_err("Invalid scan params");
        return;
    }

    /*
     * Select which band to scan
     */
    switch(osifp->os_scan_band) {
        case OSIF_SCAN_BAND_2G_ONLY:
            params->scan_f_2ghz = true;
            params->scan_f_5ghz = false;
            break;

        case OSIF_SCAN_BAND_5G_ONLY:
            params->scan_f_2ghz = false;
            params->scan_f_5ghz = true;
            break;

        case OSIF_SCAN_BAND_ALL:
        default:
            params->scan_f_2ghz = true;
            params->scan_f_5ghz = true;
            break;
    }

    return;
}

/**
 *ieee80211_cfg80211_schedule_channel_notify: WorkQ for cfg80211_ch_switch_notify
 * Return: None
 */
void ieee80211_cfg80211_schedule_channel_notify(void *context)
{
    wlan_if_t vap = (wlan_if_t) context;
    osif_dev *osifp = (osif_dev *)vap->iv_ifp;
    struct net_device *dev = get_cfg80211_notification_ndev(osifp);
    struct ieee80211com *ic = vap->iv_ic;
    struct ol_ath_softc_net80211 *scn;
    struct cfg80211_chan_def chandef
            = (struct cfg80211_chan_def)vap->chan_notify.chandef_notify;

    scn = OL_ATH_SOFTC_NET80211(ic);

    /*
     * If strict_channel_mode is set, send the event to user-space even if
     * the VAP is in the down state
     */
    if (!(dev->flags & IFF_UP) &&
        !wlan_psoc_nif_feat_cap_get(scn->soc->psoc_obj, WLAN_SOC_F_STRICT_CHANNEL)) {
        return;
    }

    if (!cfg80211_chandef_valid(&chandef)) {
        qdf_err("Channel definition is invalid\n");
        if (chandef.chan)
            qdf_err("center_freq=%d, center_freq1=%d, center_freq2=%d\n",
                    chandef.chan->center_freq,
                    chandef.center_freq1,
                    chandef.center_freq2);
#ifdef WLAN_FEATURE_11BE
            qdf_err("puncture bitmap=%x",
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
                    chandef.puncture_bitmap
#else
                    vap->chan_notify.punct_bitmap
#endif
                    );
#endif /* WLAN_FEATURE_11BE */
        return;
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
    ieee80211_cfg80211_dump_chandef(&chandef);
#else
    ieee80211_cfg80211_dump_chandef(&chandef, vap->chan_notify.punct_bitmap);
#endif
#ifdef CFG80211_SINGLE_NETDEV_MULTI_LINK_SUPPORT
#ifdef CFG80211_PUNCTURING_SINGLE_NETDEV_API
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
    cfg80211_ch_switch_notify(dev, &chandef, 0, 0);
#else
    if (osifp->mldev && (vap->vif_type == VIF_TYPE_MLD_LINK_VAP))
        cfg80211_ch_switch_notify(dev, &chandef, vap->link_id, ((vap->chan_notify.punct_bitmap == PUNCTURE_INVALID) ? PUNCTURE_NONE : vap->chan_notify.punct_bitmap));
    else
        cfg80211_ch_switch_notify(dev, &chandef, 0, ((vap->chan_notify.punct_bitmap == PUNCTURE_INVALID) ? PUNCTURE_NONE : vap->chan_notify.punct_bitmap));
#endif
#else
    cfg80211_ch_switch_notify(dev, &chandef, 0);
#endif /* CFG80211_PUNCTURING_SINGLE_NETDEV_API */
#else
    cfg80211_ch_switch_notify(dev, &chandef);
#endif /* CFG80211_SINGLE_NETDEV_MULTI_LINK_SUPPORT */
    return;
}

void ieee80211_cfg80211_schedule_channel_started_notify(void *context)
{
    wlan_if_t vap = (wlan_if_t) context;
    osif_dev *osifp = (osif_dev *)vap->iv_ifp;
    struct net_device *dev = get_cfg80211_notification_ndev(osifp);
    struct ieee80211com *ic = vap->iv_ic;
    struct ol_ath_softc_net80211 *scn;
    struct cfg80211_chan_def chandef
            = (struct cfg80211_chan_def)vap->chan_notify.chandef_notify;

    scn = OL_ATH_SOFTC_NET80211(ic);

    /*
     * If strict_channel_mode is set, send the event to user-space even if
     * the VAP is in the down state
     */
    if (!(dev->flags & IFF_UP) &&
        !wlan_psoc_nif_feat_cap_get(scn->soc->psoc_obj, WLAN_SOC_F_STRICT_CHANNEL)) {
        return;
    }

    if (!cfg80211_chandef_valid(&chandef)) {
        qdf_err("Channel definition is invalid\n");
        if (chandef.chan)
            qdf_err("center_freq=%d, center_freq1=%d, center_freq2=%d\n",
                    chandef.chan->center_freq,
                    chandef.center_freq1,
                    chandef.center_freq2);
#ifdef WLAN_FEATURE_11BE
            qdf_err("puncture bitmap=%x",
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
                    chandef.puncture_bitmap
#else
                    vap->chan_notify.punct_bitmap
#endif
                    );
#endif /* WLAN_FEATURE_11BE */
        return;
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
    ieee80211_cfg80211_dump_chandef(&chandef);
#else
    ieee80211_cfg80211_dump_chandef(&chandef, vap->chan_notify.punct_bitmap);
#endif

#ifdef CFG80211_SINGLE_NETDEV_MULTI_LINK_SUPPORT
#ifdef CFG80211_PUNCTURING_SINGLE_NETDEV_API
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
    cfg80211_ch_switch_started_notify(dev, &chandef, 0,
                                      vap->cfg80211_channel_started_count, 0,
                                      0);
#else
    cfg80211_ch_switch_started_notify(dev, &chandef, 0,
                                      vap->cfg80211_channel_started_count, 0,
                                      vap->chan_notify.punct_bitmap);
#endif
#else
    cfg80211_ch_switch_started_notify(dev, &chandef, 0,
                                      vap->cfg80211_channel_started_count, 0);
#endif /* CFG80211_PUNCTURING_SINGLE_NETDEV_API */
#else
    cfg80211_ch_switch_started_notify(dev, &chandef,
                                      vap->cfg80211_channel_started_count);
#endif /* CFG80211_SINGLE_NETDEV_MULTI_LINK_SUPPORT */

    return;
}

/**
 * extract_command : extract if it is radio or vap command
 * @ic; pointer to ic
 * @wdev :pointer to wdev
 * @cmd_type : command type
 * @link_id: link ID
 * return pointer to data
 */
void * extract_command(struct ieee80211com *ic, struct wireless_dev *wdev,
                       int *cmd_type, uint8_t link_id) {

    struct net_device *dev = NULL;
    osif_dev *osifp = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    void *data = NULL;
    struct wiphy *wiphy = NULL;

    wiphy = ic->ic_wiphy;
    if (ic->ic_wdev.netdev == wdev->netdev) {
        dev = wdev->netdev;
        scn = get_radio_device_context(wiphy, wdev->netdev);
        data = (void *) scn;
        *cmd_type = RADIO_CMD;
    } else {
        dev = wdev->netdev;
        osifp = get_vap_device_context(wiphy, wdev->netdev, link_id);
        if (!osifp) {
            qdf_err("%s: NULL osifp\n", __func__);
            return NULL;
        }
        data = (void *)osifp->os_if;
        *cmd_type = VAP_CMD;
    }

    return data;
}

qdf_export_symbol(extract_command);

/**
 * cfg80211_reply_command : reply skb to the user space
 * @wiphy: pointer to wiphy object
 * @length : data length
 * @data : point to data
 * @flag : flag value
 * return 0 on success and -1 on failure
 */
int
cfg80211_reply_command(struct wiphy *wiphy, int length, void *data, u_int32_t flag)
{
    struct sk_buff *reply_skb = NULL;
    QDF_STATUS status;

    reply_skb = wlan_cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
                                                         length +
                                                         REPLY_SKB_SIZE);
    if (reply_skb) {
        if ((nla_put(reply_skb, QCA_WLAN_VENDOR_ATTR_PARAM_DATA, length, data)) ||
                (nla_put_u32(reply_skb, QCA_WLAN_VENDOR_ATTR_PARAM_LENGTH, length))
                || (nla_put_u32(reply_skb, QCA_WLAN_VENDOR_ATTR_PARAM_FLAGS, flag))){
            wlan_cfg80211_vendor_free_skb(reply_skb);
            return -EINVAL;
        }
        status = wlan_cfg80211_qal_devcfg_send_response((qdf_nbuf_t)reply_skb);
        return qdf_status_to_os_return(status);
    } else {
        return -ENOMEM;
    }
    return -EIO;
}

qdf_export_symbol(cfg80211_reply_command);

/**
 * wlan_cfg80211_getopmode : Given the nl opmode type , the function return the corresponding
 * ieee80211 opmode type.
 * @type: nl80211_iftype
 * @flags: point to flag
 *
 * returns ieee80211 mode  and return 0 on invalid input.
 */
int
wlan_cfg80211_getopmode(enum nl80211_iftype type, u_int32_t *flags)
{
    if (type == NL80211_IFTYPE_UNSPECIFIED) {
        return IEEE80211_M_HOSTAP;
    }
    if (type == NL80211_IFTYPE_ADHOC) {
        return IEEE80211_M_IBSS;
    }
    if (type == NL80211_IFTYPE_MONITOR) {
        return IEEE80211_M_MONITOR;
    }
    if (type == NL80211_IFTYPE_AP) {
        return IEEE80211_M_HOSTAP;
    }
    if(type == NL80211_IFTYPE_STATION) {
        return IEEE80211_M_STA;
    }
    if(type == NL80211_IFTYPE_WDS) {
        return IEEE80211_M_HOSTAP;
    }
    if (type == NL80211_IFTYPE_P2P_GO) {
        return IEEE80211_M_P2P_GO;
    }
    if (type == NL80211_IFTYPE_P2P_CLIENT) {
        return IEEE80211_M_P2P_CLIENT;
    }
    if (type == NL80211_IFTYPE_P2P_DEVICE) {
        return IEEE80211_M_P2P_DEVICE;
    }
#if MESH_MODE_SUPPORT
    if (type == NL80211_IFTYPE_MESH_POINT) {
        if (flags)
            *flags |= IEEE80211_MESH_VAP;
        return IEEE80211_M_HOSTAP;
    }
#endif
    return IEEE80211_M_ANY;
}

#ifdef WLAN_FEATURE_11BE_MLO
#define WLAN_LINK_ID_BRIDGE_OFFSET   0xF0
bool mlo_psoc_check_group_for_bridge_links(struct wlan_objmgr_psoc *psoc)
{
    uint8_t grp_id;
    struct cnss_mlo_group_info info;

    if (!mlo_psoc_get_grp_id(psoc, &grp_id)) {
        qdf_err("Unable to get group id!");
        return false;
    }

    if (!cnss_get_mlo_group_info(grp_id, &info)) {
        qdf_err("Unable to get mlo group info!");
        return false;
    }

    if (info.num_chips < MLO_NUM_CHIPS_FOR_BRIDGE_LINK) {
        qdf_info("Num chips in MLO group%d: %d\n", grp_id, info.num_chips);
        return false;
    }

    return true;
}

int osif_create_mlo_bridge_vaps(struct ieee80211vap *vap)
{
    osif_dev *osifp = (osif_dev *)vap->iv_ifp;
    struct wlan_objmgr_psoc *psoc;
    struct wlan_objmgr_pdev *pdev;
    struct wlan_objmgr_vdev *vdev;
    struct wlan_objmgr_vdev *br_vdev_list[MLO_MAX_BRIDGE_LINKS_PER_MLD] = {NULL};
    struct wlan_objmgr_pdev *br_pdev_list[MLO_MAX_BRIDGE_LINKS_PER_MLD];
    osif_dev *br_osifp[MLO_MAX_BRIDGE_LINKS_PER_MLD] = {NULL};
    struct wlan_mlo_dev_context *ml_dev;
    struct ieee80211_mld_create_params mld_params = {0};
    struct ieee80211_clone_params cp = {0};
    struct ieee80211com *br_ic;
    wlan_if_t br_vap;
    uint16_t num_links = 0;
    uint8_t *mld_macaddr;
    int i;
    struct wiphy *wiphy = NULL;

    vdev = vap->vdev_obj;
    pdev = wlan_vdev_get_pdev(vdev);
    psoc = wlan_pdev_get_psoc(pdev);

    if (cfg_get(psoc, CFG_OL_BRIDGE_VAP_DISABLE)) {
        qdf_debug("Bridge VAP support disabled via ini");
        return 0;
    }

    /* Get the MLD MAC address, if not valid, just return */
    mld_macaddr = wlan_vdev_mlme_get_mldaddr(vdev);
    if (IEEE80211_ADDR_IS_VALID(mld_macaddr)) {
        IEEE80211_ADDR_COPY(&mld_params.mld_macaddr, mld_macaddr);
    } else {
        qdf_debug("Non-MLD VAP, not creating Bridge VAPs");
        return 0;
    }

    /* If bridge VAPs are already present then just return */
    mlo_ap_get_bridge_vdev_list(vdev, &num_links, br_vdev_list);
    for (i = 0; i < num_links; i++)
        mlo_release_vdev_ref(br_vdev_list[i]);

    if (num_links && !psoc->wsi_remap_add)
        return 0;

    if (num_links >= MLO_MAX_BRIDGE_LINKS_PER_MLD &&
        psoc->wsi_remap_add)
        return 0;

    /*
     * Check for num chips in this MLO group
     * and proceed to Bridge VAPs creation
     */
    if (!mlo_psoc_check_group_for_bridge_links(psoc))
        return 0;

    /*
     * Get 2 links for Bridge VAP creation.
     * Create one bridge VAP on an adjacent link,
     * and one on self link or opposite link
     */
    if (!mlo_pdev_derive_bridge_link_pdevs(pdev, br_pdev_list)) {
        qdf_err("Failed to derive bridge links");
        return -1;
    }

    ml_dev = vdev->mlo_dev_ctx;
    if (!ml_dev) {
        qdf_err("ML dev not created");
        return -EINVAL;
    }

    if (psoc->wsi_remap_add) {
        /* check if the mld has the bridge pdev saved */
        if(ml_dev->br_pdev_list[0] && ml_dev->br_pdev_list[1]){
            br_pdev_list[0] = ml_dev->br_pdev_list[0];
            br_pdev_list[1] = ml_dev->br_pdev_list[1];
        }
        else {
            qdf_err("MLD does not have saved bridge Pdevs investigate!!");
            return -1;
        }
    }

    /* Iterate over the derived pdev list and kick start bridge VAPs */
    for (i = 0; i < MLO_MAX_BRIDGE_LINKS_PER_MLD; i++) {
        struct net_device *dev = NULL;

        /* Create bridge VAP */
        br_ic = wlan_pdev_get_mlme_ext_obj(br_pdev_list[i]);
        if (!br_ic)
            goto err1;

        wiphy = br_ic->ic_wiphy;
        strlcpy(cp.icp_name, "ath-br", IFNAMSIZ - 1);
        cp.icp_opmode = IEEE80211_M_HOSTAP;
        cp.icp_flags = (IEEE80211_CLONE_BSSID | IEEE80211_MLO_BRIDGE_VAP);

        if (osif_brvap_is_bonding_mode(psoc)) {
            dev = (struct net_device *)osif_create_vap(br_ic, br_ic->ic_wdev.netdev, &cp, 0, &mld_params, vap->vif_type);
            if (!dev)
                goto err1;

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
            br_osifp[i] = get_vap_device_context(wiphy, dev, mld_params.link_id);
#else
            br_osifp[i] = get_vap_device_context(wiphy, dev, 0);
#endif
        } else {
            br_osifp[i] = (osif_dev *)osif_create_vap(br_ic, br_ic->ic_wdev.netdev, &cp, 0, &mld_params, vap->vif_type);
            if (!br_osifp[i])
                goto err1;
        }

        /* Increment the pdev bridge vap count */
        wlan_pdev_inc_mlo_bridge_vdev_count(br_pdev_list[i]);

        /* Set ESSID for bridge VAP */
        wlan_set_ssid_mlo_bridge_vap(br_osifp[i]->os_if);

        /* update DP params */
        if (!osif_mldev_bridge_link_add(br_osifp[i], osifp->mldev)) {
            qdf_err(" error while updating the bridge dp params");
        }
        /* update bridge pdevs which will be used during remap add */
        if (!psoc->wsi_remap_add)
             ml_dev->br_pdev_list[i] = br_pdev_list[i];
    }

    return 0;

err1:
    for (i = 0; i < MLO_MAX_BRIDGE_LINKS_PER_MLD; i++) {
        if(br_osifp[i]) {
            br_vap = br_osifp[i]->os_if;
            wlan_delete_mlo_bridge_vap(br_vap, 0);
        }
    }

    return -1;
}

int osif_delete_mlo_bridge_vaps(struct ieee80211vap *vap)
{
    struct wlan_objmgr_vdev *br_vdev_list[MLO_MAX_BRIDGE_LINKS_PER_MLD] = {NULL};
    wlan_if_t br_vap;
    struct wlan_objmgr_vdev *vdev;
    uint16_t num_links = 0;
    int i;

    if (!vap || !vap->vdev_obj) {
        mlo_err("NULL vap/vdev");
        return -1;
    }

    vdev = vap->vdev_obj;
    if (!vdev->mlo_dev_ctx)
        return 0;

    /* Get the MLO bridge VAP list */
    mlo_ap_get_bridge_vdev_list(vdev, &num_links, br_vdev_list);

    /* Iterate over the MLO bridge VAP list and delete the VAPs */
    for (i = 0; i < MLO_MAX_BRIDGE_LINKS_PER_MLD; i++) {
        if (!br_vdev_list[i])
            continue;

        br_vap = wlan_vdev_get_mlme_ext_obj(br_vdev_list[i]);
        mlo_release_vdev_ref(br_vdev_list[i]);

        if (br_vap)
            wlan_delete_mlo_bridge_vap(br_vap, 0);
    }

    return 0;
}
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
/* detects only MLD VAP, Legacy VAP on MLD and non-MLO legacy VAP */
enum virtual_interface_type wlan_cfg80211_get_vif_type(struct wiphy *wiphy,
        struct vif_params *params)
{
    struct cfg80211_context *cfg_ctx = NULL;
    enum virtual_interface_type vif_type = VIF_TYPE_LEGACY;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
    if (!cfg_ctx->is_mld_phy) {
        vif_type = VIF_TYPE_LEGACY;
    } else {
        /*
         * 1. parent_wifi_name is non-NULL, create Legacy VAP
         * 2. parent_wifi_name is NULL & valid MLD MAC Address, Create MLD device
         with given MLD Mac address.
         * 3. parent_wifi_name is NULL & in-valid MLD MAC Address, Create MLD device
         with Zero MAC
         */
         qdf_debug("RadioIface: %s mldmac: %s", params->radio_iface,
                   ether_sprintf(params->mld_macaddr));

        if (params->radio_iface) { /* MLD Legacy VAP */
            vif_type = VIF_TYPE_MLD_LEGACY_VAP;
        } else { /* MLD VAP */
            if (IEEE80211_ADDR_IS_VALID(params->mld_macaddr))
                vif_type = VIF_TYPE_MLD_WITH_MAC;
            else
                vif_type = VIF_TYPE_MLD_WITH_OUT_MAC;
        }
    }

    qdf_debug("vif_type is: %d", vif_type);

    return vif_type;
}
#else
enum virtual_interface_type  wlan_cfg80211_get_vif_type(struct wiphy *wiphy,
        struct vif_params *params)
{
    enum virtual_interface_type vif_type = VIF_TYPE_LEGACY;

#ifdef WLAN_FEATURE_11BE_MLO
    if (IEEE80211_ADDR_IS_VALID(params->mld_macaddr)) {
        vif_type = VIF_TYPE_MLD_WITH_MAC;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
    } else if (params->mld_reference) {
        vif_type = VIF_TYPE_MLD_WITH_OUT_MAC;
#endif
    } else {
        vif_type = VIF_TYPE_LEGACY;
    }
#endif

    return vif_type;
}
#endif

int delete_vap_intf(struct wiphy *wiphy, struct net_device *dev, uint8_t link_id)
{
    int retval = 0;
    osif_dev *osifp;
    wlan_if_t vap;
    struct cfg80211_context *cfg_ctx = NULL;
    struct ieee80211com *ic;
    struct ol_ath_soc_softc *soc;
#if defined(WLAN_FEATURE_11BE_MLO) && !defined(ENABLE_CFG80211_BACKPORTS_MLO)
    struct wlan_objmgr_vdev *vdev;
#endif

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

    ic = wlan_cfg80211_get_ic_ptr(wiphy, dev->ieee80211_ptr, link_id);
    if (!ic) {
        qdf_err("ic NULL");
        return -1;
    }

    soc = OL_ATH_SOFTC_NET80211(ic)->soc;
    /*
     * can not delete wifiX interface
     * when recovery_in_progress is set VAP destroy is already done.
     */
    if ((ic->ic_wdev.netdev == dev) || ic->recovery_in_progress) {
        return -1;
    }

    if (ic->ic_is_ifce_allowed_in_dynamic_mode &&
        !ic->ic_is_ifce_allowed_in_dynamic_mode(ic)) {
        qdf_err("Can't add/delete virtual interface - %s"
                "dynamic mode switch in progress or in DBS mode", dev->name);
        return -EPERM;
    }

    osifp = get_vap_device_context(wiphy, dev, link_id);
    if (!osifp) {
        qdf_err("NULL osifp");
        return -1;
    }
    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL VAP");
        return -1;
    }

    /* Delete MLO bridge VAPs when last VAP in the MLD being deleted */
#if defined(WLAN_FEATURE_11BE_MLO) && !defined(ENABLE_CFG80211_BACKPORTS_MLO)
    if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP) {
        vdev = vap->vdev_obj;
        /*
         * Normal case: if its last vap in the mld, bring down the bridge vap too
         * standby case: when flag is set, indicates standby mode with one active interface,
         * so bring down the bridge vap, if the current vap brought down is second last.
         * only if bridge vap is brougt down, pci will be down
         */
        if (vdev->mlo_dev_ctx) {
            if ((vdev->mlo_dev_ctx->wlan_vdev_count == 1) ||
                ((soc->standby_mode == WLAN_STANDBY_MODE_ACTIVE_ENTRY) && (vdev->mlo_dev_ctx->wlan_vdev_count == 2))) {
                 qdf_err("invoke osif_delete_mlo_bridge_vaps");
                 osif_delete_mlo_bridge_vaps(vap);
            }
        }
    }
#endif

#ifdef QCA_SUPPORT_WDS_EXTENDED
    if (wlan_psoc_nif_feat_cap_get(wlan_pdev_get_psoc(ic->ic_pdev_obj),
        WLAN_SOC_F_WDS_EXTENDED) && (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP_VLAN))
        retval = osif_wds_ext_delete_netdev(dev);
    else
#if defined(ENABLE_CFG80211_BACKPORTS_MLO) || defined(WLAN_FEATURE_11BE_MLO)
        retval = osif_ioctl_delete_vap(dev, vap->link_id);
#else
        retval = osif_ioctl_delete_vap(dev, INVALID_LINK_ID);
#endif
#else
#if defined(ENABLE_CFG80211_BACKPORTS_MLO) || defined(WLAN_FEATURE_11BE_MLO)
    retval = osif_ioctl_delete_vap(dev, vap->link_id);
#else
    retval = osif_ioctl_delete_vap(dev, INVALID_LINK_ID);
#endif
#endif

#if defined(ENABLE_CFG80211_BACKPORTS_MLO)
    /* Free only for Link VAPs -Extra condition */
    if (osifp->mldev)
        qdf_mem_free(osifp);
#endif
    return retval;
}

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
void wlan_cfg80211_del_intf_link(struct wiphy *wiphy, struct wireless_dev *wdev, unsigned int link_id)
{
    struct cfg80211_context *cfg_ctx = NULL;
    struct net_device *dev = wdev->netdev;
    osif_dev *osifp;
    struct osif_mldev *ml_dev;
    int i, num_valid_links = 0;

    qdf_err("Deleting LinkID: %d - Linkmac :%s", link_id,
            ether_sprintf(wdev->links[link_id].addr));

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
    if (!cfg_ctx->is_mld_phy)  {
        qdf_err("Invalid Opration on Non-SingleWiphy");
        return;
    }

    if (is_mld_phy_radio_command(wiphy, dev)) {
        qdf_err("del_intf_link not a radio level command");
        return;
    }

    if (!is_mld_netdev(dev)) {
        qdf_err("del intf link issued on non mld netdev");
        return;
    }

    /* Consider the following cases:
     *    1. 2-link MLO is configured in STA but association is in SLO
     *    2. 3-link MLO is configured in STA but association is in SLO
     *    3. 3-link MLO is configured in STA but association is in 2-link MLO
     *
     * The deletion of the vaps that are not associated are not done since
     * kernel returns false in nl80211_pre_doit for links that are present
     * but not part of wdev->valid_links. The below check finds those links
     * and deletes them before deleting the link for which this command was
     * originally issued.
     */
    if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_STATION) {
        ml_dev = osif_mld_get_mldev(wdev->netdev);
        if (!ml_dev) {
            qdf_err("ML dev is null");
            return;
        }

         for (i = 0; i < NUM_MAX_RADIOS; i++) {
              if (wdev->valid_links & BIT(i))
                  num_valid_links++;
         }

         if (num_valid_links < ml_dev->mlo_info.num_mlo_links) {
             for (i = 0; i < NUM_MAX_RADIOS; i++) {
                  osifp = get_vap_device_context(wiphy, wdev->netdev, i);
                  if (!osifp)
                      continue;

                  if (!(wdev->valid_links & BIT(i))) {
                      qdf_err("Deleting LinkID: %d - Linkmac :%s", i,
                              ether_sprintf(wdev->links[i].addr));
                      delete_vap_intf(wiphy, dev, i);
                  }
             }
         }
    }

    delete_vap_intf(wiphy, dev, link_id);
}

int wlan_cfg80211_add_intf_link(struct wiphy *wiphy, struct wireless_dev *wdev, unsigned int link_id)
{
    struct cfg80211_context *cfg_ctx = NULL;
    struct net_device *ndev= NULL;
    struct ieee80211_clone_params cp = {0};
    struct ieee80211_mld_create_params mld_params = {0};
    int hw_index = link_id;
    struct wlan_objmgr_pdev *pdev = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct pdev_osif_priv *osif_priv = NULL;
    struct ieee80211com * ic = NULL;
    struct osif_mldev *osifp_mld;
    osif_dev *osifp = get_vap_device_context(wiphy, wdev->netdev, link_id);

    qdf_debug("LinkID: %d - Linkmac :%s", link_id,
              ether_sprintf(wdev->links[link_id].addr));

    if (osifp) {
        qdf_warn("WARN!! Link already created\n");
        return 0;
    }

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
    if (!cfg_ctx->is_mld_phy)  {
        qdf_err("Invalid Opration on Non-SingleWiphy");
        return -1;
    }

    pdev = wlan_mlo_get_pdev_by_hw_link_id(hw_index,
                                           cfg_ctx->ml_grp_id,
                                           WLAN_MLO_MGR_ID);
    if (!pdev) {
        qdf_err("unable to get the pdev for hw_index %d", hw_index);
        return -1;
    }

    osif_priv = wlan_pdev_get_ospriv(pdev);
    if (!osif_priv) {
        qdf_err("Unable to get pdev ospriv object");
        wlan_objmgr_pdev_release_ref(pdev, WLAN_MLO_MGR_ID);
        return -1;
    }

    scn = (struct ol_ath_softc_net80211 *)osif_priv->legacy_osif_priv;
    if (!scn) {
        qdf_err("Unable to get scn object");
        wlan_objmgr_pdev_release_ref(pdev, WLAN_MLO_MGR_ID);
        return -1;
    }
    ic = &scn->sc_ic;

    if (scn->soc->sc_in_delete) {
        qdf_err("Delete in Progress, Vaps can't be created !");
        wlan_objmgr_pdev_release_ref(pdev, WLAN_MLO_MGR_ID);
        return -EBUSY;
    }

    if (ic->recovery_in_progress) {
        qdf_err("Recovery is in progress");
        wlan_objmgr_pdev_release_ref(pdev, WLAN_MLO_MGR_ID);
        return -EBUSY;
    }

    if (ic->ic_is_ifce_allowed_in_dynamic_mode &&
        !ic->ic_is_ifce_allowed_in_dynamic_mode(ic)) {
        qdf_err("Can't add/delete virtual interface - "
                "dynamic mode switch in progress or in DBS mode");
        wlan_objmgr_pdev_release_ref(pdev, WLAN_MLO_MGR_ID);
        return -EPERM;
    }

    osifp_mld = osif_mld_get_mldev(wdev->netdev);

    /* Populate Clone Flags in such a way
       to follow leagacy path to make sure future
       fixes will be applicable */

    strlcpy(cp.icp_name, "ath", IFNAMSIZ - 1);
    /* Should be same as MLDs */
    cp.icp_opmode = (u_int16_t)wlan_cfg80211_getopmode(osifp_mld->wdev.iftype, NULL);
    /* Ignore from user space and derive own*/
    cp.icp_flags = IEEE80211_CLONE_BSSID;

    /* Construct mld_params */
    if (IEEE80211_ADDR_IS_VALID(osifp_mld->mld_mac_addr)) {
        IEEE80211_ADDR_COPY(&mld_params.mld_macaddr, osifp_mld->mld_mac_addr);
    } else {
        mld_params.mld_ifname_valid = 1;
        OS_MEMCPY(mld_params.mld_ifname,
                  wdev->netdev->name, IFNAMSIZ - 1);
    }

    mld_params.link_id = link_id;
    ndev = (struct net_device *)osif_create_vap(ic, ic->ic_wdev.netdev, &cp,
                               CFG80211_VAP_CREATE, &mld_params, VIF_TYPE_MLD_LINK_VAP);

    if (ndev) {
        osifp_mld->mlo_info.num_mlo_links = osifp_mld->index + 1;
        osifp_mld->mlo_info.reconfig = 0;
        osifp_mld->mlo_info.mlo_link_ids[osifp_mld->index] = link_id;
        memcpy(osifp_mld->mlo_info.mlo_mac_addrs[osifp_mld->index].addr,
               cp.icp_bssid, ETH_ALEN);
        osifp_mld->index++;
    }

    /* Copy Generated MAC to wdev strcutures */
    osifp = get_vap_device_context(wiphy, wdev->netdev, link_id);
    if (osifp && osifp->os_if)
        IEEE80211_ADDR_COPY(wdev->links[link_id].addr,
                            ((wlan_if_t)osifp->os_if)->iv_myaddr);

    wlan_objmgr_pdev_release_ref(pdev, WLAN_MLO_MGR_ID);

    return 0;
}
#endif

/**
 *   wlan_cfg80211_add_virtual_intf: This function create a virtual interface.
 *   @wiphy: pointer to wiphy structure.
 *   @name: name of the interface
 *   @type: nl80211_type
 *   @flags: pointer to flags
 *   @vif_params: pointer to vif_params that contains macaddress
 *
 *   returns wirelessdev.
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
struct wireless_dev *wlan_cfg80211_add_virtual_intf(struct wiphy *wiphy,
        const char *name,
        unsigned char name_assign_type,
        enum nl80211_iftype type,
        struct vif_params *params)
{
#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
struct wireless_dev *wlan_cfg80211_add_virtual_intf(struct wiphy *wiphy,
        const char *name,
        unsigned char name_assign_type,
        enum nl80211_iftype type,
        u_int32_t *flags,
        struct vif_params *params)
{
#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0))
struct wireless_dev *wlan_cfg80211_add_virtual_intf(struct wiphy *wiphy,
        const char *name,
        enum nl80211_iftype type,
        u_int32_t *flags,
        struct vif_params *params)
{
#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
struct wireless_dev *wlan_cfg80211_add_virtual_intf(struct wiphy *wiphy, char *name,
        enum nl80211_iftype type,
        u_int32_t *flags,
        struct vif_params *params)
{
#else
struct net_device *wlan_cfg80211_add_virtual_intf(struct wiphy *wiphy, char *name,
        enum nl80211_iftype type,
        u_int32_t *flags,
        struct vif_params *params)
{
#endif
    struct cfg80211_context *cfg_ctx = NULL;
    struct net_device *ndev= NULL;
    struct ieee80211_clone_params cp;
    struct ieee80211com *ic;
    osif_dev *osifp;
    wlan_if_t vap;
    int retv;
    int found_cp_entry = 0;
    struct ieee80211_clone_params_list *cp_entry, *next_entry;
    struct ol_ath_softc_net80211 *scn = NULL;
    enum virtual_interface_type vif_type;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    /* for mld phy wds_ext is mandatory */
    if ((cfg_ctx->is_mld_phy) && (type == NL80211_IFTYPE_AP_VLAN)) {
        /* In case of single wiphy will be just creating
         * AP_VLAN interface and initialization of parent osif
         * will be done as part of change station
         */
        strlcpy(cp.icp_name, name, IFNAMSIZ - 1);

        ndev = osif_mld_phy_create_wds_ext_netdev(&cp);
        if (ndev == NULL) {
            qdf_err("Failed to create WDS_EXT interface %s", name);
            return ERR_PTR(-EINVAL);
        }
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
        return ndev->ieee80211_ptr;
#else
        return ndev;
#endif
    }
#endif /* ENABLE_CFG80211_BACKPORTS_MLO */

    vif_type = wlan_cfg80211_get_vif_type(wiphy, params);

    if (vif_type == VIF_TYPE_INVALID) {
        qdf_err("Vif type is INVALID");
        return ERR_PTR(-EINVAL);
    }

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if ((vif_type == VIF_TYPE_MLD_WITH_MAC) ||
        (vif_type == VIF_TYPE_MLD_WITH_OUT_MAC)) {
        return wlan_cfg80211_mld_add_virtual_intf(wiphy, name,
                                                  name_assign_type, type,
                                                  params);
    }
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    ic = wlan_cfg80211_find_ic_by_netdev_name(wiphy, params->radio_iface);
#else
    ic = cfg_ctx->ic;
#endif

    if (!ic) {
        qdf_debug("ic is NULL");
        return ERR_PTR(-EINVAL);
    }

    scn = (struct ol_ath_softc_net80211 *) ic;

    if (scn->soc->sc_in_delete) {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD, IEEE80211_MSG_CFG80211, "Delete in Progress, Vaps can't be created !");
        return ERR_PTR(-EBUSY);
    }

    if (ic->recovery_in_progress) {
        return ERR_PTR(-EBUSY);
    }

    if (ic->ic_is_ifce_allowed_in_dynamic_mode &&
        !ic->ic_is_ifce_allowed_in_dynamic_mode(ic)) {
        qdf_err("Can't add/delete virtual interface - %s"
                "dynamic mode switch in progress or in DBS mode", name);
        return ERR_PTR(-EPERM);
    }

    /* Adding support for creating vaps in proprietary mode
       This is needed to create vaps in modes that are not
       supported by cfg80211
    */
    LIST_FOREACH_SAFE(cp_entry, &ic->ic_cp, link_entry, next_entry)
    {
        if(!(strcmp(name, cp_entry->cp.icp_name)))
        {
            found_cp_entry = 1;
            qdf_mem_copy(&cp, &cp_entry->cp, sizeof(struct ieee80211_clone_params));
            LIST_REMOVE(cp_entry,link_entry);
            qdf_mem_free(cp_entry);
            qdf_debug("proprietary mode %d for interface: %s : clone params: 0x%08X ",
                   cp.icp_opmode, name, cp.icp_flags);
        }
    }

    if(found_cp_entry == 0)
    {
        /*
         * Device Name
         */
        strlcpy(cp.icp_name, name, IFNAMSIZ - 1);
        /*
         * NL80211_IFTYPE_UNSPECIFIED,
         * NL80211_IFTYPE_ADHOC,
         * NL80211_IFTYPE_STATION,
         * NL80211_IFTYPE_AP,
         * NL80211_IFTYPE_AP_VLAN,
         * NL80211_IFTYPE_WDS,
         * NL80211_IFTYPE_MONITOR,
         * NL80211_IFTYPE_MESH_POINT,
         * NL80211_IFTYPE_P2P_CLIENT,
         * NL80211_IFTYPE_P2P_GO,
         * NL80211_IFTYPE_P2P_DEVICE,
         * NL80211_IFTYPE_OCB,
         * NUM_NL80211_IFTYPES,
         * NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1
         * For other mode like NAWDS need to follow wlanconfig to populate cp flags.
         */

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
        cp.icp_opmode = (u_int16_t)wlan_cfg80211_getopmode(type, NULL);
#else
        cp.icp_opmode = (u_int16_t)wlan_cfg80211_getopmode(type, flags);
#endif
        if (type != NL80211_IFTYPE_AP_VLAN && cp.icp_opmode == IEEE80211_M_ANY) {
            qdf_print("%s: Unsupported wireless mode : %d ", __func__, type) ;
            return ERR_PTR(-EINVAL);
        }

        /*
         * Based on opmode we have differnt icp_flags
         * using wlanconfig we can populate flags
         * for cfg80211 if hostpad gives mac addres in vif_params
         * we need to clear IEEE80211_CLONE_BSSID and populate mac
         * address in ieee80211_clone_params
         *
         */
        /* TODO: do experments with hostpad bssid options and confim */

        cp.icp_flags = IEEE80211_CLONE_BSSID;
    }

#define CFG80211_VAP_CREATE 1
#ifdef QCA_SUPPORT_WDS_EXTENDED
    if (wlan_psoc_nif_feat_cap_get(wlan_pdev_get_psoc(ic->ic_pdev_obj),
        WLAN_SOC_F_WDS_EXTENDED) && (type == NL80211_IFTYPE_AP_VLAN)) {
        ndev = osif_create_wds_ext_netdev(ic, &cp);
    } else
#endif /* QCA_SUPPORT_WDS_EXTENDED */
    {
         /* Third parameter represents if the VAP is created using cfg80211 (1) or WEXT (0) */
#ifdef WLAN_FEATURE_11BE_MLO
        struct ieee80211_mld_create_params mld_params = {0};
        if (IEEE80211_ADDR_IS_VALID(params->mld_macaddr))
            IEEE80211_ADDR_COPY(&mld_params.mld_macaddr, params->mld_macaddr);
#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
        else if (params->mld_reference) {
            mld_params.mld_ifname_valid = 1;
            OS_MEMCPY(mld_params.mld_ifname,
                      (const void *)params->mld_reference, IFNAMSIZ - 1);
        }
#endif
        ndev = (struct net_device *)osif_create_vap(ic, ic->ic_wdev.netdev, &cp,
                               CFG80211_VAP_CREATE, &mld_params, vif_type);
#else
        ndev = (struct net_device *)osif_create_vap(ic, ic->ic_wdev.netdev, &cp,
                               CFG80211_VAP_CREATE, NULL, vif_type);
#endif /* WLAN_FEATURE_11BE_MLO */
    }

    if (ndev == NULL) {
        qdf_print("Failed to create VAP. osif_create_vap returned NULL!");
        return ERR_PTR(-EINVAL);
    }
    else {
        osifp = get_vap_device_context(wiphy, ndev, 0);
        if (!osifp) {
            qdf_err("NULL osifp\n");
            return NULL;
        }
        /* Adding support for WDS*/
#ifdef QCA_SUPPORT_WDS_EXTENDED
        if(!(wlan_psoc_nif_feat_cap_get(wlan_pdev_get_psoc(ic->ic_pdev_obj),
             WLAN_SOC_F_WDS_EXTENDED) && (type == NL80211_IFTYPE_AP_VLAN)))
#endif
        if(params->use_4addr) {
            vap = osifp->os_if;
            retv = wlan_rptr_vdev_ucfg_config(vap->vdev_obj, IEEE80211_PARAM_WDS, params->use_4addr);
        }
#ifdef WLAN_FEATURE_11BE_MLO
        /* Create MLO bridge VAPs by checking the MLO chip group */
        if (type == NL80211_IFTYPE_AP) {
            vap = osifp->os_if;

            if (vap->vdev_obj->mlo_dev_ctx &&
                (vap->vdev_obj->mlo_dev_ctx->wlan_vdev_count > 1)) {
                osif_create_mlo_bridge_vaps(vap);
            }
        }
#endif
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
        return ndev->ieee80211_ptr;
#else
        return ndev;
#endif
    }
}

/**
*  wlan_cfg80211_probe_client: Probe client
*  @wiphy: pointer to wiphy structure
*  @dev: pointer to dev
*  @peer: pointer to peer
*  @cookie : cookie information
*/

int wlan_cfg80211_probe_client(struct wiphy *wiphy, struct net_device *dev,const u8 *peer, u64 *cookie)
{
    int ret = 0;
    u8 peer_mac[QDF_MAC_ADDR_SIZE] = {0};
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    struct ieee80211_node *ni = NULL;

    osifp = ath_netdev_priv(dev);
    vap   = osifp->os_if;
    ni    = ieee80211_vap_find_node(vap, peer, WLAN_MLME_SB_ID);
    if (!ni) {
        qdf_err("ni NULL STA MAC:%s is not Associated", ether_sprintf(peer));
        return -ENOENT;
    }
    IEEE80211_ADDR_COPY(peer_mac, peer);
    ret = wlan_send_mgmt_null(vap, peer_mac, ni, cookie);
    ieee80211_free_node(ni, WLAN_MLME_SB_ID);
    if (!ret) {
        qdf_debug("NULL data frame Tx completed for STA MAC:%s", ether_sprintf(peer_mac));
        return ret;
    } else {
        qdf_err("Could not send NULL data frame to STA MAC:%s", ether_sprintf(peer_mac));
        return -EINVAL;
    }
}

/**
 *   wlan_cfg80211_change_virtual_intf: This function changes a virtual interface.
 *   @wiphy: pointer to wiphy structure.
 *   @name: name of the interface
 *   @type: nl80211_type
 *   @flags: pointer to flags
 *   @vif_params: pointer to vif_params that contains macaddress
 *
 *   returns 1/0 and -1 on invalid input
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
static int wlan_cfg80211_change_virtual_intf(struct wiphy *wiphy, struct net_device *ndev,
        enum nl80211_iftype type,
        struct vif_params *params)
{
#else
static int wlan_cfg80211_change_virtual_intf(struct wiphy *wiphy, struct net_device *ndev,
        enum nl80211_iftype type,
        u32 *flags,
        struct vif_params *params)
{
#endif
    struct ieee80211com *ic;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, ndev->ieee80211_ptr, 0);

    if (!ic) {
        qdf_err("ic NULL\n");
        return -1;
    }

    if (ndev->ieee80211_ptr->iftype != type) {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD, IEEE80211_MSG_CFG80211,"%s: type : %d Rejecting ...\n", __func__, type);
        return -1;
    }
    /* resolve vAP from ndev*/
    ndev->ieee80211_ptr->iftype = type;
    return 0;
}


/**
 *  wlan_cfg80211_add_station: Set Station parameters
 *  @wiphy: pointer to wiphy structure
 *  @dev: pointer to dev
 *  @mac: Pointer to mac
 *  @station_parameters: Pointer to station parameters
 */

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0))
static int wlan_cfg80211_add_station(struct wiphy *wiphy,
                                         struct net_device *dev,
                                         const uint8_t *mac,
                                         struct station_parameters *params)
#else
static int wlan_cfg80211_add_station(struct wiphy *wiphy,
                                         struct net_device *dev, uint8_t *mac,
                                         struct station_parameters *params)
#endif
{
     return 0;
}

/**
 *  wlan_cfg80211_del_station: Del client
 *  @wiphy: pointer to wiphy structure
 *  @dev: pointer to dev
 *  @mac: Pointer to mac
 */
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0))
int wlan_cfg80211_del_station(struct wiphy *wiphy,
                                  struct net_device *dev,
                                  struct station_del_parameters *params)
#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0))
int wlan_cfg80211_del_station(struct wiphy *wiphy,
                                  struct net_device *dev,
                                  const uint8_t *mac)
#else
int wlan_cfg80211_del_station(struct wiphy *wiphy,
                                  struct net_device *dev,
                                  uint8_t *mac)
#endif
{
    return 0 ;
}

/**
 * wlan_cfg80211_set_rekey_dataata() - set rekey data
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @data: Pointer to rekey data
 *
 * This function is used to offload GTK rekeying job to the firmware.
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_cfg80211_set_rekey_dataata(struct wiphy *wiphy,
        struct net_device *dev,
        struct cfg80211_gtk_rekey_data *data)
{
    return 0;
}

/**
 * wlan_cfg80211_sched_scan_start() - cfg80211 scheduled scan(pno) start
 * @wiphy: Pointer to wiphy
 * @dev: Pointer network device
 * @request: Pointer to cfg80211 scheduled scan start request
 *
 * Return: 0 for success, non zero for failure
 */
int wlan_cfg80211_sched_scan_start(struct wiphy *wiphy,
        struct net_device *dev,
        struct cfg80211_sched_scan_request
        *request)
{
    return 0;
}

/**
 * wlan_cfg80211_sched_scan_stop() - stop cfg80211 scheduled scan(pno)
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 *
 * Return: 0 for success, non zero for failure
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
int wlan_cfg80211_sched_scan_stop(struct wiphy *wiphy,
        struct net_device *dev, u64 reqid)
{
#else
int wlan_cfg80211_sched_scan_stop(struct wiphy *wiphy,
        struct net_device *dev)
{
#endif
    return 0;
}

/**
 * ieee80211_get_ath_band: get internal band from nl80211 band.
 * @nl_band: nl80211 band
 *
 * Return: internal wlan_band id
 */
int ieee80211_get_ath_band(enum nl80211_band nl_band)
{
    int band = WLAN_BAND_UNSPECIFIED;

    switch(nl_band) {
        case NL80211_BAND_2GHZ:
            band = WLAN_BAND_2GHZ;
            break;
        case NL80211_BAND_5GHZ:
            band = WLAN_BAND_5GHZ;
            break;
        case NL80211_BAND_6GHZ:
            band = WLAN_BAND_6GHZ;
            break;
        default:
            band = WLAN_BAND_UNSPECIFIED;
    }

    return band;
}

/**
 * wlan_cfg80211_set_ap_chanwidth- call back for AP channel width change
 * This is called when we need to change channel width (dynamic HT2040)
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @link_id: link_id of vdev in MLO ctx
 * @chandef: pointer to cfg80211_chan_def
 *
 * Return: 0 for success, non zero for failure
 */
#ifdef CFG80211_MLO_SINGLE_NETDEV_API
int wlan_cfg80211_set_ap_chanwidth(struct wiphy *wiphy, struct net_device *dev,
        unsigned int link_id, struct cfg80211_chan_def *chandef)
#else
int wlan_cfg80211_set_ap_chanwidth(struct wiphy *wiphy, struct net_device *dev,
        struct cfg80211_chan_def *chandef)
#endif
{
    struct ieee80211com *ic;
    enum wlan_band_id band;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t chan, tbtt, current_chan;
    u_int16_t ch_width;
    struct chan_params chan_p = {0};

    qdf_debug("band:%d cfreq:%d channel:%d flags:0x%x width:%d",
            chandef->chan->band, chandef->chan->center_freq,
            chandef->chan->hw_value, chandef->chan->flags,
            chandef->width);

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
    ic = wlan_cfg80211_get_ic_ptr(wiphy, dev->ieee80211_ptr, link_id);
#else
    ic = wlan_cfg80211_get_ic_ptr(wiphy, dev->ieee80211_ptr, INVALID_LINK_ID);
#endif

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
    cmd = extract_command(ic, dev->ieee80211_ptr, &cmd_type, link_id);
#else
    cmd = extract_command(ic, dev->ieee80211_ptr, &cmd_type, INVALID_LINK_ID);
#endif

    if (!cmd) {
        qdf_err("cmd is NULL");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    chan = chandef->chan->hw_value;
    tbtt = 0;
    ch_width = chandef->width;
    band = ieee80211_get_ath_band(chandef->chan->band);

    set_chan_params_puncture_bitmap(&chan_p, 0);
#if (LINUX_VERSION_CODE <= KERNEL_VERSION(5, 4, 0))
    if (chandef->puncture_bitmap) {
        set_chan_params_puncture_bitmap(&chan_p, chandef->puncture_bitmap);
    }
#endif
    chan_p.freq = wlan_get_wlan_band_id_chan_to_freq(ic->ic_pdev_obj, chan, band);
    chan_p.cfreq2 = chandef->center_freq2;

    if (ieee80211_is_phymode_8080(vap->iv_cur_mode)) {
        chan_p.cfreq2 = vap->iv_des_cfreq2_80_80;
    }

    qdf_debug("chan:%d tbtt:%d ch_width:%d band:%d chan_freq:%d cfreq2:%d"
#ifdef WLAN_FEATURE_11BE
              " puncture_bitmap:%x"
#endif
              , chan, tbtt, ch_width, band, chan_p.freq, chan_p.cfreq2
#ifdef WLAN_FEATURE_11BE
              ,chan_p.puncture_bitmap
#endif
              );

    if (!chan_p.freq) {
        qdf_err("freq is NULL");
        return -EINVAL;
    }

    chan_p.input_6g_pwr_mode = REG_BEST_PWR_MODE;
#ifdef WLAN_FEATURE_11BE
    chan_p.puncture_low_pwr = true;
#endif
    current_chan = ic->ic_curchan->ic_ieee;
    qdf_debug("current_chan: %d, chan: %d", current_chan, chan);

    if (current_chan != chan) {
        qdf_debug("Enabling Channel Switch Announcement on current channel");

        return ieee80211_ucfg_set_chanswitch(vap, &chan_p, tbtt, ch_width);
    }

    return 0;
}

/**
 * ieee80211_cfg80211_dump_chandef:  dump channel def
 * @chandef: pointer to cfg80211_chan_def
 * @punct_bitmap: puncture pattern
 *
 * Return: 0 for success, non zero for failure
 */
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
int ieee80211_cfg80211_dump_chandef(struct cfg80211_chan_def *chan_def)
#else
int ieee80211_cfg80211_dump_chandef(struct cfg80211_chan_def *chan_def, uint32_t punct_bitmap)
#endif
{
    QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
              "band:%d cfreq:%d channel:%d flags:0x%x",
              chan_def->chan->band, chan_def->chan->center_freq,
              chan_def->chan->hw_value, chan_def->chan->flags);
    QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
              "antenna_gain:%d max_power:%d max_reg_power:%d date_state:%d cac_ms:%d",
              chan_def->chan->max_antenna_gain, chan_def->chan->max_power,
              chan_def->chan->max_reg_power, chan_def->chan->dfs_state,
              chan_def->chan->dfs_cac_ms);
    QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
              "width:%d cfreq1:%d cfreq2:%d", chan_def->width,
              chan_def->center_freq1, chan_def->center_freq2);
#ifdef WLAN_FEATURE_11BE
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
    QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
              "puncture bitnap:%x", chan_def->puncture_bitmap);
#else
    QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
              "puncture bitmap:%x", punct_bitmap);
#endif
#endif

    return 0;
}

/**
 *  ieee80211_get_nl80211_chwidth: get nl80211 channel width for a given internal width
 *  and phymode.
 *  @ch_width: internal channel width.
 *  @phymode: wireless mode / phymode
 *  return nl80211_chan_width.
 */
enum nl80211_chan_width ieee80211_get_nl80211_chwidth(enum ieee80211_cwm_width ch_width ,
        enum ieee80211_phymode phymode)
{
    enum nl80211_chan_width nl_ch_width = NL80211_CHAN_WIDTH_20_NOHT;

    switch (phymode) {
        case IEEE80211_MODE_11B:
        case IEEE80211_MODE_11G:
        case IEEE80211_MODE_11A:
        case IEEE80211_MODE_FH:
        case IEEE80211_MODE_TURBO_G:
        case IEEE80211_MODE_TURBO_A:
            return NL80211_CHAN_WIDTH_20_NOHT;
            break;
        default:
            break;
    }

    switch (ch_width) {
        case IEEE80211_CWM_WIDTH20:
            nl_ch_width = NL80211_CHAN_WIDTH_20;
            break;
        case IEEE80211_CWM_WIDTH40:
            nl_ch_width = NL80211_CHAN_WIDTH_40;
            break;
        case IEEE80211_CWM_WIDTH80:
            nl_ch_width = NL80211_CHAN_WIDTH_80;
            break;
        case IEEE80211_CWM_WIDTH160:
            nl_ch_width = NL80211_CHAN_WIDTH_160;
            break;
        case IEEE80211_CWM_WIDTH80_80:
            nl_ch_width = NL80211_CHAN_WIDTH_80P80;
            break;
#ifdef WLAN_FEATURE_11BE
        case IEEE80211_CWM_WIDTH320:
            nl_ch_width = NL80211_CHAN_WIDTH_320;
            break;
#endif /* WLAN_FEATURE_11BE */
        default:
            nl_ch_width = NL80211_CHAN_WIDTH_20_NOHT;
            break;
    }
    return nl_ch_width;
}

/**
 *  ieee80211_get_ath_chwidth: get internal channel width from nl80211 channel width.
 *  @nl_ch_width: nl80211 channel width.
 *  return ch_width. (Channel width used in Wide Bandwidth Channel Switch Element)
 */
int ieee80211_get_ath_chwidth(enum nl80211_chan_width nl_ch_width)
{
    int ch_width = CHWIDTH_VHT20;

    switch (nl_ch_width) {
        case NL80211_CHAN_WIDTH_20_NOHT:
            ch_width = CHWIDTH_20;
            break;
        case NL80211_CHAN_WIDTH_20:
            ch_width = CHWIDTH_20;
            break;
        case NL80211_CHAN_WIDTH_40:
            ch_width = CHWIDTH_40;
            break;
        case NL80211_CHAN_WIDTH_80:
            ch_width = CHWIDTH_80;
            break;
        case NL80211_CHAN_WIDTH_160:
            ch_width = CHWIDTH_160;
            break;
        case NL80211_CHAN_WIDTH_80P80:
            ch_width = CHWIDTH_80;
            break;
#ifdef WLAN_FEATURE_11BE
        case NL80211_CHAN_WIDTH_320:
            ch_width = CHWIDTH_320;
            break;
#endif /* WLAN_FEATURE_11BE */
        default:
            ch_width = CHWIDTH_20;
            break;
    }
    return ch_width;
}

/**
 *  ieee80211_cfg80211_construct_chandef: construct channel def from the given
 *              nl_channel and ath_channel
 *
 *  This function constructs the chan_def structure from the given
 *  ieee80211_channel and ieee80211_ath_channel objects
 *
 *  @chan_def: pointer to channel def that we need to construct.
 *  @nl_chan: Pointer to ieee80211_channel(nl channel)
 *  @channel: Pointer to ieee80211_ath_channel object (ath channel)
 *
 *  return 0/-1 on success/fail
 */
int ieee80211_cfg80211_construct_chandef(struct cfg80211_chan_def *chan_def,
                                         struct ieee80211_channel *nl_chan,
                                         struct ieee80211_ath_channel *channel)
{
    enum ieee80211_phymode  phymode;
    enum ieee80211_cwm_width ch_width;
    uint16_t vht_seg1_freq = 0, vht_seg0_freq = 0;

    if (!IEEE80211_IS_CHAN_VALID(channel)) {
        qdf_info("%s: channel NULL ", __func__);
        return -1;
    }

    /* Create Channel def with NL80211_CHAN_NO_HT, later update
     width, cfreq1 and cfreq2 */
    cfg80211_chandef_create(chan_def, nl_chan, NL80211_CHAN_NO_HT);

    phymode = wlan_channel_phymode(channel);
    ch_width = get_chwidth_phymode(phymode);
    chan_def->width = ieee80211_get_nl80211_chwidth(ch_width, phymode);

    chan_def->center_freq1 = 0;
    chan_def->center_freq2 = 0;
    switch(phymode)  {
        /*
         * compute center_freq1 & center_freq1 for 2G
         * as these are not populated by driver
         */
        case IEEE80211_MODE_11B:
        case IEEE80211_MODE_11G:
        case IEEE80211_MODE_TURBO_G:
        case IEEE80211_MODE_FH:
        case IEEE80211_MODE_11NG_HT20:
        case IEEE80211_MODE_11AXG_HE20:
#ifdef WLAN_FEATURE_11BE
        case IEEE80211_MODE_11BEG_EHT20:
#endif /* WLAN_FEATURE_11BE */
            chan_def->center_freq1 = nl_chan->center_freq;
            break;
        case IEEE80211_MODE_11NG_HT40PLUS:
        case IEEE80211_MODE_11AXG_HE40PLUS:
        case IEEE80211_MODE_11AXG_HE40:
        case IEEE80211_MODE_11NG_HT40:
#ifdef WLAN_FEATURE_11BE
        case IEEE80211_MODE_11BEG_EHT40PLUS:
        case IEEE80211_MODE_11BEG_EHT40:
#endif /* WLAN_FEATURE_11BE */
            chan_def->center_freq1 = (nl_chan->center_freq+10);
            break;
        case IEEE80211_MODE_11NG_HT40MINUS:
        case IEEE80211_MODE_11AXG_HE40MINUS:
#ifdef WLAN_FEATURE_11BE
        case IEEE80211_MODE_11BEG_EHT40MINUS:
#endif /* WLAN_FEATURE_11BE */
            chan_def->center_freq1 = (nl_chan->center_freq-10);
            break;
        /*
         * Note:
         * Driver adheres to 802.11-2016 wherein seg2 should contain center of entire 160 MHz span
         * and seg1 contains center of primary 80 MHz.
         * However hostapd currently adheres to the older 802.11ac-2013 wherein seg1 contains center
         * of entire 160MHz span and seg2 contains zero.
         */
        case IEEE80211_MODE_11AC_VHT160:
        case IEEE80211_MODE_11AXA_HE160:
#ifdef WLAN_FEATURE_11BE
        case IEEE80211_MODE_11BEA_EHT160:
#endif /* WLAN_FEATURE_11BE */
            vht_seg0_freq = channel->ic_vhtop_freq_seg2;
            vht_seg1_freq = 0;
            break;
        case IEEE80211_MODE_11AC_VHT80_80:
        case IEEE80211_MODE_11AXA_HE80_80:
            vht_seg0_freq = channel->ic_vhtop_freq_seg1;
            vht_seg1_freq = channel->ic_vhtop_freq_seg2;
            break;
#ifdef WLAN_FEATURE_11BE
        case IEEE80211_MODE_11BEA_EHT320:
            vht_seg0_freq = channel->ic_vhtop_freq_seg2;
            vht_seg1_freq = 0;
            break;
#endif /* WLAN_FEATURE_11BE */
        default: /* All A, NA, AC, AXA phy modes with chwidth < 160 */
            vht_seg0_freq = channel->ic_vhtop_freq_seg1;
            vht_seg1_freq = 0;
            break;
    }
    if (vht_seg0_freq) {
        chan_def->center_freq1 = vht_seg0_freq;
    }
    if (vht_seg1_freq) {
        chan_def->center_freq2 = vht_seg1_freq;
    }

#ifdef WLAN_FEATURE_11BE
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
    chan_def->puncture_bitmap = channel->op_puncture_bitmap;
#endif
#endif
    return 0;
}

/**
 * wlan_cfg80211_channel_switch - do channel switch
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @csa_params - pointer to CSA params
 * Return: 0 for success, non zero for failure
 */
static int wlan_cfg80211_channel_switch(struct wiphy *wiphy,
        struct net_device *dev,
        struct cfg80211_csa_settings *csa_params)
{
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    osif_dev *osnetdev = get_vap_device_context(wiphy, dev, csa_params->beacon_csa.link_id);
#else
    osif_dev *osnetdev = get_vap_device_context(wiphy, dev, 0);
#endif
    wlan_if_t vap = osnetdev->os_if;
    struct chan_params chan_p = {0};
    int tbtt = 0;
    int ret = 0;
    enum ieee80211_cwm_width ch_width;

    chan_p.freq = csa_params->chandef.chan->center_freq;
    chan_p.cfreq2 = csa_params->chandef.center_freq2;
    chan_p.input_6g_pwr_mode = REG_BEST_PWR_MODE;
#ifdef WLAN_FEATURE_11BE
    chan_p.puncture_low_pwr = true;
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
    set_chan_params_puncture_bitmap (&chan_p, csa_params->chandef.puncture_bitmap);
#else
#ifdef CFG80211_PUNCTURING_SINGLE_NETDEV_API
    set_chan_params_puncture_bitmap (&chan_p, csa_params->punct_bitmap);
#endif
#endif
#endif
    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: freq: %d tbtt: %d freq: %d ch_width: %d \n",
            __func__, csa_params->chandef.chan->center_freq, csa_params->count,
            chan_p.freq, csa_params->chandef.width);

#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
    ieee80211_cfg80211_dump_chandef(&csa_params->chandef);
#else
#ifdef CFG80211_PUNCTURING_SINGLE_NETDEV_API
    ieee80211_cfg80211_dump_chandef(&csa_params->chandef, csa_params->punct_bitmap);
#endif
#endif

    ch_width = ieee80211_get_ath_chwidth(csa_params->chandef.width);
    tbtt = csa_params->count;
    if (tbtt > 0) {
        ret = ieee80211_ucfg_set_chanswitch(vap, &chan_p, tbtt, ch_width);
    } else {
        /* if tbtt is ZERO then do channel change immediately */
        ret = ieee80211_ucfg_set_freq(vap, &chan_p);
    }
    return ret;
}

/**
 *  wlan_cfg80211_change_station: Set Station parameters
 *  @wiphy: pointer to wiphy structure
 *  @dev: pointer to dev
 *  @mac: Pointer to mac
 *  @station_parameters: Pointer to station parameters
 *  return 0/-1 on success/fail
 */

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)) || defined(WITH_BACKPORTS)
static int wlan_cfg80211_change_station(struct wiphy *wiphy,
        struct net_device *dev,
        const u8 *mac,
        struct station_parameters *params)
#else
static int wlan_cfg80211_change_station(struct wiphy *wiphy,
        struct net_device *dev,
        u8 *mac,
        struct station_parameters *params)
#endif
{
    struct ieee80211req_mlme mlme;
    struct ieee80211_node *ni;
    osif_dev *osifp;
    wlan_if_t vap;
#ifdef QCA_NSS_WIFI_OFFLOAD_SUPPORT
    struct ol_ath_softc_net80211 *scn;
    struct ieee80211com *ic = NULL;
#endif
    ol_txrx_soc_handle soc_txrx_handle;

#ifdef WLAN_FEATURE_11BE_MLO
    struct wlan_objmgr_vdev *primary_vdev = NULL;
    uint8_t primary_link_id;
    wlan_if_t primary_vap = NULL;
#endif
#ifdef QCA_SUPPORT_WDS_EXTENDED
    struct wlan_objmgr_psoc *psoc = NULL;
#endif

    if (!params) {
        qdf_err("Params is null");
        return 0;
    }

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if (params->link_sta_params.link_id >= 0 &&
        params->link_sta_params.link_id <= IEEE80211_MLD_MAX_NUM_LINKS)
        osifp = get_vap_device_context(wiphy, dev, params->link_sta_params.link_id);
    else
        osifp = get_vap_device_context_no_linkid(wiphy, dev, mac);
#else
    osifp = get_vap_device_context(wiphy, dev, 0);
#endif
    if (!osifp) {
        qdf_err("NULL osifp\n");
        return 0;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL vap\n");
        return 0;
    }

#ifdef QCA_NSS_WIFI_OFFLOAD_SUPPORT
    scn = OL_ATH_SOFTC_NET80211(vap->iv_ic);
#endif

#ifdef QCA_SUPPORT_WDS_EXTENDED
    if (!vap) {
        qdf_err("VAP is null");
        return 0;
    }

    psoc = wlan_vdev_get_psoc(vap->vdev_obj);
    if (!psoc) {
        qdf_err("PSOC is null");
        return 0;
    }
    soc_txrx_handle = wlan_psoc_get_dp_handle(psoc);
    if (!soc_txrx_handle) {
         qdf_err("soc_txrx_handle is null");
    }

    /*
     * params->vlan is enabled when wds ext is enabled.
     * params->vlan_id is enabled when MPSK is enabled.
     * Execute code after this check only if both features
     * are enabled simultaneouly.
     */
    if (params->vlan && !params->vlan_id) {
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
        if (is_mld_phy(wiphy)) {
            osif_dev *osdev = ath_netdev_priv(params->vlan);

            if (osdev->dev_type == OSIF_NETDEV_TYPE_WDS_EXT)
                osif_mld_phy_configure_parent_param(params->vlan, mac);
        }
#endif
        if (wlan_psoc_nif_feat_cap_get(psoc,
                                       WLAN_SOC_F_WDS_EXTENDED)) {
            qdf_info("Ignore set station for ap vlan %s",
                     params->vlan->name);
            return 0;
        }
    }
#endif

    if (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED)) {
        mlme.im_op = IEEE80211_MLME_AUTHORIZE;
    } else {
        mlme.im_op = IEEE80211_MLME_UNAUTHORIZE;
    }

    mlme.im_reason = 0;
    memcpy(mlme.im_macaddr, mac, QDF_MAC_ADDR_SIZE);

    IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_AUTH, mlme.im_macaddr,
                       "%s: %s", __func__,
                       (mlme.im_op == IEEE80211_MLME_AUTHORIZE)?
                       "authorize" : "unauthorize");

    if (mlme.im_op == IEEE80211_MLME_AUTHORIZE) {
        wlan_node_authorize(vap, 1, mlme.im_macaddr);
#ifdef WLAN_FEATURE_11BE_MLO
        if (mlo_sta_bridge_exists(vap->vdev_obj) &&
            (!vap->vdev_obj->mlo_dev_ctx->bridge_sta_ctx->bridge_node_auth)) {
            primary_link_id = vap->vdev_obj->mlo_dev_ctx->bridge_sta_ctx->bridge_link_id;
            primary_vdev = mlo_get_vdev_by_link_id(vap->vdev_obj, primary_link_id,
                                                   WLAN_MLO_MGR_ID);
            if (primary_vdev) {
                primary_vap = wlan_vdev_get_mlme_ext_obj(primary_vdev);
                if (primary_vap) {
                    wlan_node_authorize(primary_vap, 1, &primary_vdev->mlo_dev_ctx->mld_addr.bytes[0]);
                    /* Set bridge auth to true*/
                    vap->vdev_obj->mlo_dev_ctx->bridge_sta_ctx->bridge_node_auth = true;
                }
                wlan_objmgr_vdev_release_ref(primary_vdev, WLAN_MLO_MGR_ID);
            }
        }
#endif
    } else {
        wlan_node_authorize(vap, 0, mlme.im_macaddr);
    }

    if (params->vlan_id)
    {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_AUTH, "%s: macaddr :%s  vlan_id : %d \n",
            __func__, ether_sprintf(mac), params->vlan_id);
        ni = ieee80211_find_node(vap->iv_ic, mac, WLAN_MLME_SB_ID);
        if (ni) {
            ni->vlan_id = params->vlan_id;
            if (vap->enable_multi_group_key && vap->hw_vlan_acceleration_en) {
                if (vap->hw_vlan_acceleration_en(vap, ni) != QDF_STATUS_SUCCESS)
                    qdf_err("Failed to configure vlan hw acceleration support for Rx");

                cdp_peer_set_vlan_id(soc_txrx_handle,  wlan_vdev_get_id(vap->vdev_obj), mlme.im_macaddr, ni->vlan_id);

            }
#ifdef QCA_NSS_WIFI_OFFLOAD_SUPPORT
            ic = vap->iv_ic;
            if (ic->nss_radio_ops) {
                if (vap->enable_multi_group_key) {
                        ic->nss_radio_ops->ic_nss_ol_peer_set_vlan_id(scn, wlan_vdev_get_id(vap->vdev_obj),
                                                                      mlme.im_macaddr, ni->vlan_id);
                }
            }

#endif
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);
        }
    }
    return 0;
}

/**
 * wlan_cfg80211_check_and_set_br_vap_param: Check and set the param in bridge vap
 * @vap: pointer to active vap.
 * @br_vap: pointer to bridge vap
 * @param: param to be set
 *
 * returns: None
 */
static inline void
wlan_cfg80211_check_and_set_br_vap_param(struct ieee80211vap *vap,
                                         struct ieee80211vap *br_vap,
                                         ieee80211_param param)
{
    int val = 0;
    int br_val = 0;

    ieee80211_ucfg_getparam(vap, param, &val);
    ieee80211_ucfg_getparam(br_vap, param, &br_val);

    if (br_val != val)
        ieee80211_ucfg_setparam_util(br_vap, param, val, NULL, false, false);
}

/**
 * wlan_cfg80211_and_set_br_scn_param: Check and set the param in bridge scn
 * @vscn: pointer to active vscn
 * @br_vscn: pointer to bridge vscn
 * @param: param to be set
 *
 * returns: None
 */
static inline void
wlan_cfg80211_check_and_set_br_scn_param(struct ol_ath_softc_net80211 *vscn,
                                         struct ol_ath_softc_net80211 *br_vscn,
                                         int param)
{
	int val = 0;
	int br_val = 0;

	vscn->sc_ic.ic_cfg80211_radio_handler.getparam((void *)vscn, param, &val);
	br_vscn->sc_ic.ic_cfg80211_radio_handler.getparam((void *)br_vscn, param, &br_val);

	if (br_val != val)
		br_vscn->sc_ic.ic_cfg80211_radio_handler.setparam((void *)br_vscn, param, val, NULL);
}

/**
 * wlan_cfg80211_set_br_security: Set RSN caps for bridge vap from
                                  one of real link
 * @vap: pointer to real link vap handle
 * @br_vap: pointer to bridge link vap handle
 *
 * returns: QDF_STATUS_SUCCESS in case of success, QDF_STATUS_E_* otherwise.
 */
static inline QDF_STATUS
wlan_cfg80211_set_br_security(struct ieee80211vap *vap,
                              struct ieee80211vap *br_vap)
{
    int32_t rsn_caps;

    if (!vap || !br_vap)
        return QDF_STATUS_E_NULL_VALUE;

    rsn_caps = wlan_crypto_get_param(vap->vdev_obj, WLAN_CRYPTO_PARAM_RSN_CAP);
    if (rsn_caps < 0)
        return QDF_STATUS_E_INVAL;

    return wlan_crypto_set_vdev_param(br_vap->vdev_obj,
                                      WLAN_CRYPTO_PARAM_RSN_CAP, rsn_caps);
}

/**
 * wlan_cfg80211_inherit_br_vap_param: inherit params from active vap
 * @vap: pointer to active vap.
 * @br_vap: pointer to bridge vap
 *
 * returns: None
 */
static void
wlan_cfg80211_inherit_br_vap_param(struct ieee80211vap *vap,
                                   struct ieee80211vap *br_vap)
{
    struct ol_ath_softc_net80211 *scn = NULL;
    struct ol_ath_softc_net80211 *br_scn = NULL;

    scn = OL_ATH_SOFTC_NET80211(vap->iv_ic);
    br_scn = OL_ATH_SOFTC_NET80211(br_vap->iv_ic);

    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_ME);
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_IGMP_ME);
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_PROXYARP_CAP);
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_APBRIDGE);
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_HLOS_TID_OVERRIDE);
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_DROP_3ADDR_MCAST);

#ifdef QCA_SUPPORT_WDS_EXTENDED
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_DROP_TX_MCAST);
#endif
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_VAP_TX_ENCAP_TYPE);
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_VAP_RX_DECAP_TYPE);
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_RAWMODE_PKT_SIM);
    wlan_cfg80211_check_and_set_br_vap_param(vap, br_vap, IEEE80211_PARAM_PRIVACY);
    wlan_cfg80211_check_and_set_br_scn_param(scn, br_scn, OL_SPECIAL_PARAM_SHIFT | OL_SPECIAL_PARAM_ENABLE_OL_STATS);
    if (QDF_STATUS_SUCCESS != wlan_cfg80211_set_br_security(vap, br_vap)) {
        qdf_err("Failed to set security param for bridge vap %pM",
                br_vap->iv_myaddr);
        return;
    }
}

/**
 *   wlan_cfg80211_del_virtual_intf: This function deletes a virtual interface.
 *   @wiphy: pointer to wiphy structure.
 *   @wdev: pointer to wireless_dev
 *
 *   returns 0/-1 on success/fail
 */

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
int wlan_cfg80211_del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
#else
int wlan_cfg80211_del_virtual_intf(struct wiphy *wiphy, struct net_device *dev)
#endif
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
    struct net_device *dev = wdev->netdev;
#endif
    struct cfg80211_context *cfg_ctx = NULL;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if (cfg_ctx->is_mld_phy && (wdev->iftype == NL80211_IFTYPE_AP_VLAN)) {
        return osif_wds_ext_delete_netdev(dev);
    }

    if (is_mld_phy_radio_command(wiphy, dev)) {
        qdf_err("del_virtual_intf not a radio level command");
        return -1;
    }
    if (is_mld_netdev(dev)) {
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
        return wlan_cfg80211_mld_del_virtual_intf(wiphy, wdev);
#else
        return wlan_cfg80211_mld_del_virtual_intf(wiphy, dev->ieee80211_ptr);
#endif
    }
#endif
    return delete_vap_intf(wiphy, dev, INVALID_LINK_ID);
}

#ifdef WLAN_FEATURE_11BE_MLO
int osif_start_mlo_bridge_vaps(struct ieee80211vap *vap)
{
    struct wlan_objmgr_vdev *br_vdev_list[MLO_MAX_BRIDGE_LINKS_PER_MLD] = {NULL};
    osif_dev *br_osifp;
    wlan_if_t br_vap;
    struct wlan_objmgr_vdev *vdev;
    uint16_t num_links = 0;
    int i;

    if (!vap || !vap->vdev_obj) {
        mlo_err("NULL vap/vdev");
        return -1;
    }

    vdev = vap->vdev_obj;
    if (!vdev->mlo_dev_ctx)
        return 0;

    /* Get the MLO bridge VAP list */
    mlo_ap_get_bridge_vdev_list(vdev, &num_links, br_vdev_list);

    for (i = 0; i < MLO_MAX_BRIDGE_LINKS_PER_MLD; i++) {
        if (!br_vdev_list[i])
            continue;

        br_vap = wlan_vdev_get_mlme_ext_obj(br_vdev_list[i]);
        mlo_release_vdev_ref(br_vdev_list[i]);

        if (!br_vap) {
            qdf_err("Bridge VAP is null!");
            continue;
        }

        /* Do not Start bridge VAP if already started */
        if (br_vap->iv_is_mlo_bridge_up)
            continue;

        br_osifp = (osif_dev *)br_vap->iv_ifp;

        /* Set MLO id */
        wlan_vdev_set_link_id(br_vdev_list[i], WLAN_LINK_ID_BRIDGE_OFFSET | i);

        /* Bringup the Bridge VAP */
        if (wlan_init_mlo_bridge_vap(br_vap))
            goto err1;

        wlan_cfg80211_inherit_br_vap_param(vap, br_vap);

#ifdef CONFIG_BOND_MOD_SUPPORT
        if (br_osifp->netdev) {
            int r;

            r = qal_bond_create_slave(br_osifp->mldev->mld_dev,
                                      br_osifp->netdev);
            if (r) {
                qdf_err("Failed to add br link dev %s (chip_id %u ) to %s - err %d",
                        br_osifp->netdev->name,
                        wlan_mlo_get_psoc_mlo_chip_id(wlan_vdev_get_psoc(br_vdev_list[i])),
                        br_osifp->mldev->mld_dev->name,
                        r);
                goto err1;
            }
        }
#endif
    }

    return 0;

err1:
    for (i = 0; i < MLO_MAX_BRIDGE_LINKS_PER_MLD; i++) {
        if(br_vdev_list[i]) {
            br_vap = wlan_vdev_get_mlme_ext_obj(br_vdev_list[i]);
            if (!br_vap) {
                qdf_err("Bridge VAP is null!");
                continue;
            }
#ifdef CONFIG_BOND_MOD_SUPPORT
            br_osifp = (osif_dev *)br_vap->iv_ifp;
            if (br_osifp->netdev) {
                    qal_bond_slave_release(br_osifp->mldev->mld_dev,
                                           br_osifp->netdev);
            }
#endif
            wlan_delete_mlo_bridge_vap(br_vap, 0);
        }
    }

    return -1;
}
#endif

int wlan_cfg80211_add_link_station(struct wiphy *wiphy, struct net_device *dev,
                                   struct link_station_parameters *params)
{
#ifdef WLAN_FEATURE_11BE_MLO
    int status = 0;
    wlan_if_t vap;
    struct ieee80211_node *ni = NULL;
    osif_dev *osifp = get_vap_device_context(wiphy, dev, 0);

    if (!osifp) {
        qdf_err("NULL osifp");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL VAP");
        return -EINVAL;
    }

    if (!wlan_vdev_mlme_is_mlo_vdev(vap->vdev_obj))
        return 0;

    if (!vap->vdev_obj->mlo_dev_ctx
        || !vap->vdev_obj->mlo_dev_ctx->ap_ctx->mlo_link_reject)
        return 0;

    ni = ieee80211_vap_find_node(vap, params->link_mac, WLAN_MLME_NB_ID);
    if (ni == NULL) {
        qdf_err("MAC Address Not Found " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(params->link_mac));
        return -EINVAL;
    }

    /* Clear the Assoc rejected flag when hostapd also accepts partner link */
    if (ni->ni_assocstatus != IEEE80211_STATUS_SUCCESS) {
        qdf_err("Add link sta failed " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(ni->ni_macaddr));
        status = -EINVAL;
    }
    else {
        qdf_debug("Add link sta success " QDF_MAC_ADDR_FMT,
                  QDF_MAC_ADDR_REF(ni->ni_macaddr));
        wlan_peer_clear_assoc_rejected(ni->peer_obj);
    }

    ieee80211_free_node(ni, WLAN_MLME_NB_ID);

    return status;
#else
    return 0;
#endif
}

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
int wlan_cfg80211_mod_link_station(struct wiphy *wiphy, struct net_device *dev,
                                   struct link_station_parameters *params)
{
	return 0;
}

int wlan_cfg80211_del_link_station(struct wiphy *wiphy, struct net_device *dev,
                                   struct link_station_del_parameters *params)
{
	return 0;
}
#endif

/**
 * wlan_cfg80211_set_hecap: Set HE capabilities
 * @vap: VAP handle.
 * @he_cap: HE capabilities IE received from start_ap/change_beacon
 * Return: QDF_STATUS_SUCCESS if HECAP set successfully.
           QDF_STATUS_E_* otherwise.
 */
static
QDF_STATUS wlan_cfg80211_set_hecap(struct ieee80211vap *vap,
                                   const struct ieee80211_he_cap_elem *hecap)
{
    int status;
    uint32_t value;
    uint8_t phy_cap_info[11], mac_cap_info[6];

    if (!vap || !vap->iv_ic || !hecap)
        return QDF_STATUS_E_NULL_VALUE;

    if (!(vap->iv_ic->ic_cfg80211_compliance_mode &
          CFG80211_SUPPORT_SET_HE_CAP))
         return QDF_STATUS_SUCCESS;

    memcpy(phy_cap_info, hecap->phy_cap_info, 11);
    memcpy(mac_cap_info, hecap->mac_cap_info, 6);
    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                      "vap%d:compliance_mode: HECAP: TWT_RESP: %u, SU_BFER: %u, "
                      "SU_BFEE: %u, MUBFR %u, ER_SU_4X: %u, ER_SU_1X: %u",
                      vap->iv_unit, HECAP_MAC_TWTRSP_GET_FROM_IE(&mac_cap_info),
                      HECAP_PHY_SUBFMR_GET_FROM_IE(&phy_cap_info),
                      HECAP_PHY_SUBFME_GET_FROM_IE(&phy_cap_info),
                      HECAP_PHY_MUBFMR_GET_FROM_IE(&phy_cap_info),
                      HECAP_PHY_ERSU_4XLTF800NSGI_GET_FROM_IE(&phy_cap_info),
                      HECAP_PHY_ERSU1XLTF800NSGI_GET_FROM_IE(&phy_cap_info));

    if (!qdf_mem_cmp(&vap->hecap, hecap,
                     sizeof(struct ieee80211_he_cap_elem))) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                          "vap%d: HE CAP already configured\n",
                          vap->iv_unit);
        return QDF_STATUS_SUCCESS;
    }

    qdf_mem_copy(&vap->hecap, hecap,
                 sizeof(struct ieee80211_he_cap_elem));

    value = HECAP_MAC_TWTRSP_GET_FROM_IE(&mac_cap_info);
    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_TWT_RESPONDER_SUPRT,
                                          value,
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HECAP: TWT_RESP config failed",
                vap->iv_unit);

    value = HECAP_PHY_SUBFMR_GET_FROM_IE(&phy_cap_info);
    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_HE_SU_BFER,
                                          value,
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HECAP: SU_BFER config failed",
                vap->iv_unit);

    value = HECAP_PHY_SUBFME_GET_FROM_IE(&phy_cap_info);
    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_HE_SU_BFEE,
                                          value,
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HECAP: SU_BFEE config failed",
                vap->iv_unit);

    value = HECAP_PHY_MUBFMR_GET_FROM_IE(&phy_cap_info);
    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_HE_MU_BFER,
                                          value,
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HECAP: MU_BFER config failed",
                vap->iv_unit);

    value = HECAP_PHY_ERSU_4XLTF800NSGI_GET_FROM_IE(&phy_cap_info);
    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_HE_ER_SU_PPDU_4X_LTF_800NS_GI,
                                          value,
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HECAP: ER_SU_4X config failed",
                vap->iv_unit);

    value = HECAP_PHY_ERSU1XLTF800NSGI_GET_FROM_IE(&phy_cap_info);
    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_HE_ER_SU_PPDU_1X_LTF_800NS_GI,
                                          value,
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HECAP: ER_SU_1X config failed",
                vap->iv_unit);

    return QDF_STATUS_SUCCESS;
}

/**
 * wlan_cfg80211_set_vhtcap: Set VHT capabilities
 * @vap: VAP handle.
 * @vht_cap: VHT capabilities IE received from start_ap/change_beacon
 * Return: QDF_STATUS_SUCCESS if VHTCAP set successfully.
           QDF_STATUS_E_* otherwise.
 */
static
QDF_STATUS wlan_cfg80211_set_vhtcap(struct ieee80211vap *vap,
                                    const struct ieee80211_vht_cap *vht_cap)
{
    struct ieee80211_ie_vhtcap *vhtcap =  (struct ieee80211_ie_vhtcap *)vht_cap;
    uint32_t cap_flags;
    int status;

    if (!vap || !vap->iv_ic || !vhtcap)
        return QDF_STATUS_E_NULL_VALUE;

    if (!(vap->iv_ic->ic_cfg80211_compliance_mode &
          CFG80211_SUPPORT_SET_VHT_CAP))
         return QDF_STATUS_SUCCESS;

    cap_flags = le32toh(vhtcap->vht_cap_info);
    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                      "vap%d:compliance_mode: VHTCAP: SG80: %u, SG160: %u, "
                      "LDPC: %u, TX_STBC: %u, RX_STBC: %u, SUBFER: %u, "
                      "SUBFEE: %u, STS: %u, SOUNDING_DIM: %u, MUBFR: %u, "
                      "MAX_AMPDU: %u", vap->iv_unit,
                      !!(cap_flags & IEEE80211_VHTCAP_SHORTGI_80),
                      !!(cap_flags & IEEE80211_VHTCAP_SHORTGI_160),
                      !!(cap_flags & IEEE80211_VHTCAP_RX_LDPC),
                      !!(cap_flags & IEEE80211_VHTCAP_TX_STBC),
                      ((cap_flags & IEEE80211_VHTCAP_RX_STBC) >> IEEE80211_VHTCAP_RX_STBC_S),
                      !!(cap_flags & IEEE80211_VHTCAP_SU_BFORMER),
                      !!(cap_flags & IEEE80211_VHTCAP_SU_BFORMEE),
                      ((cap_flags >> IEEE80211_VHTCAP_STS_CAP_S) & IEEE80211_VHTCAP_STS_CAP_M),
                      ((cap_flags & IEEE80211_VHTCAP_SOUND_DIM) >> IEEE80211_VHTCAP_SOUND_DIM_S),
                      !!(cap_flags & IEEE80211_VHTCAP_MU_BFORMER),
                      ((cap_flags & IEEE80211_VHTCAP_MAX_AMPDU_LEN_EXP) >> IEEE80211_VHTCAP_MAX_AMPDU_LEN_EXP_S));

    if (!qdf_mem_cmp(&vap->vhtcap, vhtcap,
                     sizeof(struct ieee80211_vht_cap))) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                          "vap%d: VHT CAP already configured\n",
                          vap->iv_unit);
        return QDF_STATUS_SUCCESS;
    }

    qdf_mem_copy(&vap->vhtcap, vhtcap,
                 sizeof(struct ieee80211_vht_cap));

    if (cap_flags & (IEEE80211_VHTCAP_SHORTGI_80 | IEEE80211_VHTCAP_SHORTGI_160))
        status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_SHORT_GI,
                                              IEEE80211_GI_0DOT4_US,
                                              NULL, false, false);
    else
        status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_SHORT_GI,
                                              IEEE80211_GI_0DOT8_US,
                                              NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: SGI config failed",
                vap->iv_unit);

    if (cap_flags & IEEE80211_VHTCAP_RX_LDPC)
        status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_LDPC,
                                              IEEE80211_HTCAP_C_LDPC_TXRX,
                                              NULL, false, false);
    else
        status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_LDPC,
                                              !!(cap_flags & IEEE80211_VHTCAP_RX_LDPC),
                                              NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: LDPC config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_TX_STBC,
                                          !!(cap_flags & IEEE80211_VHTCAP_TX_STBC),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: TX_STBC config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_RX_STBC,
                                          ((cap_flags & IEEE80211_VHTCAP_RX_STBC) >> IEEE80211_VHTCAP_RX_STBC_S),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: RX_STBC config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_VHT_SUBFER,
                                          !!(cap_flags & IEEE80211_VHTCAP_SU_BFORMER),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: SUBFER config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_VHT_SUBFEE,
                                          !!(cap_flags & IEEE80211_VHTCAP_SU_BFORMEE),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: SUBFEE config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_VHT_STS_CAP,
                                          ((cap_flags >> IEEE80211_VHTCAP_STS_CAP_S) & IEEE80211_VHTCAP_STS_CAP_M),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: STS_CAP config failed",
                vap->iv_unit);
    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_VHT_SOUNDING_DIM,
                                          ((cap_flags & IEEE80211_VHTCAP_SOUND_DIM) >> IEEE80211_VHTCAP_SOUND_DIM_S),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: DIM config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_VHT_MUBFER,
                                          !!(cap_flags & IEEE80211_VHTCAP_MU_BFORMER),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: MUBFER config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_VHT_MAX_AMPDU,
                                          ((cap_flags & IEEE80211_VHTCAP_MAX_AMPDU_LEN_EXP) >> IEEE80211_VHTCAP_MAX_AMPDU_LEN_EXP_S),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: VHTCAP: AMPDU_EXP config failed",
                vap->iv_unit);

    return QDF_STATUS_SUCCESS;
}

/**
 * wlan_cfg80211_set_htcap: Set HT capabilities
 * @vap: VAP handle.
 * @ht_cap: HT capabilities IE received from start_ap/change_beacon
 * Return: QDF_STATUS_SUCCESS if HTCAP set successfully.
           QDF_STATUS_E_* otherwise.
 */
static
QDF_STATUS wlan_cfg80211_set_htcap(struct ieee80211vap *vap,
                                   const struct ieee80211_ht_cap *ht_cap)
{
    struct ieee80211_ie_htcap_cmn *htcap =  (struct ieee80211_ie_htcap_cmn *)ht_cap;
    uint16_t hc_cap;
    int status;

    if (!vap || !vap->iv_ic || !htcap)
        return QDF_STATUS_E_NULL_VALUE;

    if (!(vap->iv_ic->ic_cfg80211_compliance_mode &
          CFG80211_SUPPORT_SET_HT_CAP))
         return QDF_STATUS_SUCCESS;

    hc_cap = le16toh(htcap->hc_cap);
    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                      "vap%d:compliance_mode: HTCAP: SG20: %u, SG40: %u, LDPC: %u, "
                      "TX_STBC: %u, RX_STBC: %u, INTOL: %u, MAX_AMPDU: %u, "
                      "AMPDU_DENS: %u\n", vap->iv_unit,
                      !!(hc_cap & IEEE80211_HTCAP_C_SHORTGI20),
                      !!(hc_cap & IEEE80211_HTCAP_C_SHORTGI40),
                      !!(hc_cap & IEEE80211_HTCAP_C_ADVCODING),
                      !!(hc_cap & IEEE80211_HTCAP_C_TXSTBC),
                      ((hc_cap & IEEE80211_HTCAP_C_RXSTBC) >> IEEE80211_HTCAP_C_RXSTBC_S),
                      !!(hc_cap & IEEE80211_HTCAP_C_INTOLERANT40),
                      htcap->hc_maxampdu,
                      htcap->hc_mpdudensity);

    if (!qdf_mem_cmp(&vap->htcap, htcap,
                     sizeof(struct ieee80211_ht_cap))) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                          "vap%d: HT CAP already configured\n",
                          vap->iv_unit);
        return QDF_STATUS_SUCCESS;
    }

    qdf_mem_copy(&vap->htcap, htcap,
                 sizeof(struct ieee80211_ht_cap));

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_SHORT_GI20,
                                          !!(hc_cap & IEEE80211_HTCAP_C_SHORTGI20),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HTCAP: SGI20 config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_SHORT_GI40,
                                          !!(hc_cap & IEEE80211_HTCAP_C_SHORTGI40),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HTCAP: SGI20 config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_LDPC,
                                          !!(hc_cap & IEEE80211_HTCAP_C_ADVCODING),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HTCAP: LDPC config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_TX_STBC,
                                          !!(hc_cap & IEEE80211_HTCAP_C_TXSTBC),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HTCAP: TX_STBC config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_RX_STBC,
                                          ((hc_cap & IEEE80211_HTCAP_C_RXSTBC) >> IEEE80211_HTCAP_C_RXSTBC_S),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HTCAP: RX_STBC config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_HT40_INTOLERANT,
                                          !!(hc_cap & IEEE80211_HTCAP_C_INTOLERANT40),
                                          NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HTCAP: INTOL config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_MAX_AMPDU,
                                          htcap->hc_maxampdu, NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HTCAP: MAX_AMPDU config failed",
                vap->iv_unit);

    status = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_AMPDU_DENSITY_OVERRIDE,
                                          htcap->hc_mpdudensity, NULL, false, false);
    if (status)
        qdf_err("vap%d: compliance mode: HTCAP: AMPDU_DENSITY config failed",
                vap->iv_unit);

    return QDF_STATUS_SUCCESS;
}

/**
 * wlan_cfg80211_start_ap - start AP vap
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to netdev
 * @params: Pointer to start ap configuration parameters
 * struct cfg80211_ap_settings - AP configuration
 * Return: zero for success non-zero for failure
 */
int wlan_cfg80211_start_ap(struct wiphy *wiphy,
        struct net_device *dev,
        struct cfg80211_ap_settings *params)
{
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct cfg80211_context *cfg_ctx = NULL;
    struct osif_mldev *osifp_mld = NULL;
#else
    struct cfg80211_mld_wiphy_priv *cfg_ctx = NULL;
#endif
    struct ieee80211com *ic = NULL;
    int retval = 0, retv;
    int mode = 0;
    enum ieee80211_opmode opmode;
    enum ieee80211_phymode phymode;
    ieee80211_ssid   tmpssid;

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    osif_dev *osifp = get_vap_device_context(wiphy, dev, params->beacon.link_id);
#else
    osif_dev *osifp = get_vap_device_context(wiphy, dev, 0);
#endif

    wlan_if_t vap;
    struct ieee80211vap *tmpvap;
    struct wlan_objmgr_psoc *psoc;
    u_int8_t *wps_ie = NULL;
    u_int8_t *ptr = NULL;

    struct ol_ath_softc_net80211 *scn = NULL;
    ol_ath_soc_softc_t *soc = NULL;
    struct chan_params chan_p = {0};
    uint16_t start_aid = 0;

#ifdef WLAN_FEATURE_11BE_MLO
    struct cfg80211_mlo_info *cfg80211_mlo_info;
    struct wlan_mlme_mlo_info *mlme_mlo_info;
    struct qdf_mac_addr *mld_addr;
    int i;
    uint8_t reconfig = 0;
#if WLAN_SUPPORT_SPLITMAC
    struct wlan_objmgr_vdev *vdev_list[WLAN_UMAC_MLO_MAX_VDEVS] = {NULL};
    uint16_t num_links = 0;
    uint8_t splitmac_enable_count = 0;
#endif
#endif /* WLAN_FEATURE_11BE_MLO */

    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }

    vap = osifp->os_if;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
#else
    cfg_ctx = (struct cfg80211_mld_wiphy_priv*)wiphy_priv(wiphy);
#endif

    ic = vap->iv_ic;

    if (ic == NULL) {
        qdf_err("IC is NULL");
        return -EINVAL;
    }


    scn = OL_ATH_SOFTC_NET80211(ic);
    soc = scn->soc;

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if (psoc == NULL) {
        QDF_ASSERT(0);
        return -EINVAL;
    }

    if ((osifp->is_delete_in_progress) || (osifp->is_deleted) || !(soc->soc_attached)) {
        return -EINVAL;
    }

    opmode = wlan_vap_get_opmode(vap);

    if (opmode == IEEE80211_M_WDS) {
        return -EOPNOTSUPP;
    }

    qdf_info("Start %s psoc:%u vdev:%u", vap->iv_netdev_name,
             wlan_vdev_get_psoc_id(vap->vdev_obj), wlan_vdev_get_id(vap->vdev_obj));
#ifdef WLAN_FEATURE_11BE_MLO
#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
    reconfig = params->mlo_info.reconfig;
#endif
    mld_addr = (struct qdf_mac_addr *)wlan_vdev_mlme_get_mldaddr(vap->vdev_obj);
    if (!qdf_is_macaddr_zero(mld_addr)) {
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
        osifp_mld = osif_mld_get_mldev(dev);
        cfg80211_mlo_info = &osifp_mld->mlo_info;
#else
        cfg80211_mlo_info = &params->mlo_info;
#endif
        mlme_mlo_info = &vap->mlo_info;
        if (cfg80211_mlo_info->num_mlo_links > WLAN_UMAC_MLO_MAX_VDEVS) {
            mlo_err("Num links from user space: %d are more than supported: %d",
                    cfg80211_mlo_info->num_mlo_links, WLAN_UMAC_MLO_MAX_VDEVS);
            return -EINVAL;
        }

        mlo_info("Num links from user space: %d  Max: %d",
                 cfg80211_mlo_info->num_mlo_links, WLAN_UMAC_MLO_MAX_VDEVS);

        mlme_mlo_info->num_mlo_links = cfg80211_mlo_info->num_mlo_links;
        for (i = 0; i < cfg80211_mlo_info->num_mlo_links; i++) {
            mlme_mlo_info->mlo_link_ids[i] = cfg80211_mlo_info->mlo_link_ids[i];
            IEEE80211_ADDR_COPY(&mlme_mlo_info->mlo_mac_addrs[i].bytes,
                    cfg80211_mlo_info->mlo_mac_addrs[i].addr);
        }

        qdf_debug("%s Num ML links %u",vap->iv_netdev_name,
                 cfg80211_mlo_info->num_mlo_links);

        if (reconfig) {
            QDF_STATUS status;

            qdf_err("start-ap with reconfig flag ON %s", vap->iv_netdev_name);
            status = wlan_mlo_validate_link_add_request(vap);
            if (QDF_IS_STATUS_ERROR(status)) {
                mlo_err("Validation of link addition request failed");
                return qdf_status_to_os_return(status);
            }

            wlan_vdev_mlme_op_flags_set(vap->vdev_obj,
                                        WLAN_VDEV_OP_MLO_LINK_ADD);
        }
    }
#if WLAN_SUPPORT_SPLITMAC
    /* Check whether all VAPs are configured with splitmac, if not return */
    mld_addr = (struct qdf_mac_addr *)wlan_vdev_mlme_get_mldaddr(vap->vdev_obj);
    if (!qdf_is_macaddr_zero(mld_addr)) {
        mlo_ap_get_vdev_list(vap->vdev_obj, &num_links, vdev_list);
        for (i = 0; i < num_links; i++) {
            if (splitmac_is_enabled(vdev_list[i]))
               splitmac_enable_count++;

            mlo_release_vdev_ref(vdev_list[i]);
        }
        if (splitmac_enable_count && (splitmac_enable_count != num_links)) {
            mlo_err("splitmac is not enabled on all VAPs of MLD num links %d splitmac enabled %d",
                    num_links, splitmac_enable_count);
            return -EINVAL;
        }
    }
#endif

#endif /* WLAN_FEATURE_11BE_MLO */
    OS_MEMZERO(&tmpssid, sizeof(ieee80211_ssid));


    /*
     * wlan_set_desired_ssidlist
     */

    if (params->ssid != NULL) {

        if (params->ssid_len > IEEE80211_NWID_LEN) {
            params->ssid_len = IEEE80211_NWID_LEN;
        }

        tmpssid.len = params->ssid_len;
        qdf_mem_copy(tmpssid.ssid, params->ssid, params->ssid_len);
        tmpssid.ssid[tmpssid.len] = '\0';
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211," \n DES SSID SET=%s length: %d\n", tmpssid.ssid, tmpssid.len);
        ieee80211_ucfg_set_essid(vap, &tmpssid, 0);
    } else {
        /* ANY */
        tmpssid.ssid[0] = '\0';
        tmpssid.len = 0;
    }

    /*
     * cfg80211_vap_set_phymode - @chandef
     *
     */
    mode = wlan_cfg80211_set_phymode(wiphy, dev, params, params->chandef);

    if(mode < 0) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s : Invalid phymode\n",
                __func__);
        return -EOPNOTSUPP;
    } else {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s : Phymode set to %d \n",
                __func__, wlan_get_desired_phymode(vap));
    }

    if (wlan_vdev_is_up(vap->vdev_obj) == QDF_STATUS_SUCCESS)
       phymode = vap->iv_cur_mode;
    else
       phymode = vap->iv_des_mode;

    if (ieee80211vap_update_ampdu(ic, vap, phymode))
        qdf_err("Failed to update ampdu");

    /*
     * TODO: iv_des_cfreq2 -  vendorcmd application need to set this
     */

    /*
     * Setting dtim period
     */
    if ((osifp->os_opmode == IEEE80211_M_HOSTAP ||
                osifp->os_opmode == IEEE80211_M_IBSS) &&
            (params->dtim_period > IEEE80211_DTIM_MAX ||
             params->dtim_period < IEEE80211_DTIM_MIN)) {

        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                "DTIM_PERIOD should be within %d to %d\n",
                IEEE80211_DTIM_MIN,
                IEEE80211_DTIM_MAX);
        return -EINVAL;
    } else {
        retv = wlan_set_param(vap, IEEE80211_DTIM_INTVAL, params->dtim_period);
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                "%s: DTIM_PERIOD:%d \n",
                __func__,
                params->dtim_period);

        if (retv != EOK) {
            IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s : DTIM period not set \n",
                    __func__);
        }
    }

    /*
     * Set beacon interval
     */
    if (vap->iv_create_flags & IEEE80211_LP_IOT_VAP) {
        params->beacon_interval = IEEE80211_BINTVAL_LP_IOT_IWMIN;
    }

    retv = ieee80211_ucfg_set_beacon_interval(vap, ic, params->beacon_interval, 0);
    if (retv != EOK) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s : Beacon Interval not set \n",
                __func__);
    }

    /*
     * Hidden SSID
     */
    if ((params->hidden_ssid == NL80211_HIDDEN_SSID_ZERO_LEN) ||
            (params->hidden_ssid == NL80211_HIDDEN_SSID_ZERO_CONTENTS)) {
        IEEE80211_VAP_HIDESSID_ENABLE(vap);
    } else {
        IEEE80211_VAP_HIDESSID_DISABLE(vap);
    }

    if (!(wiphy->features & NL80211_FEATURE_INACTIVITY_TIMER))
    {
        /*
         * inactivity_timeout: time in seconds to determine station's inactivity.
         */
        wlan_set_param(vap, IEEE80211_RUN_INACT_TIMEOUT, params->inactivity_timeout);
    }
    /* Set IEEE80211_TRIGGER_MLME_RESP to TRUE */
    wlan_set_param(vap, IEEE80211_TRIGGER_MLME_RESP, 1);

    chan_p.freq = params->chandef.chan->center_freq;
    /* As per spec if cfreq2 is non zero it is either center of secondary 80 or center of continuous bandwidth
     * if cfreq2 is zero the cfreq1 can be center frequency of continuous bandwidth
     */
    chan_p.cfreq2 = params->chandef.center_freq2 ? params->chandef.center_freq2 : params->chandef.center_freq1;

#ifdef WLAN_FEATURE_11BE
    vap->vdev_obj->is_user_punc = true;
    if (wlan_cfg80211_chan_to_phymode(vap, params, params->chandef) == vap->iv_des_mode) {
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
        set_chan_params_puncture_bitmap (&chan_p, params->chandef.puncture_bitmap);
#else
#ifdef CFG80211_PUNCTURING_SINGLE_NETDEV_API
	set_chan_params_puncture_bitmap (&chan_p, params->punct_bitmap);
#endif
#endif
    } else {
        /* PHY mode difference b/w des mode and start ap channel */
        if (osif_get_num_running_vaps(ic) && IEEE80211_IS_CHAN_VALID(ic->ic_curchan)) {
            set_chan_params_puncture_bitmap (&chan_p, ic->ic_curchan->op_puncture_bitmap);
        } else {
            /* likely condition for 5G 240 MHz case */
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
            set_chan_params_puncture_bitmap (&chan_p, params->chandef.puncture_bitmap);
#else
#ifdef CFG80211_PUNCTURING_SINGLE_NETDEV_API
	    set_chan_params_puncture_bitmap (&chan_p, params->punct_bitmap);
#endif
#endif
        }
    }

    if (ieee80211_is_phymode_320(vap->iv_des_mode) && (params->chandef.chan->band == NL80211_BAND_5GHZ)) {
        /* Currently hostapd give 160 channel for 5G 240 MHz configuration.
         * derive center channel for 320Mhz channel internally.
         */
        uint16_t tmp_cfreq2;
        wlan_get_320_center_freq(chan_p.freq, &chan_p.cfreq2, &tmp_cfreq2);
    }

    if (vap->iv_scs && ieee80211_is_phymode_11be(vap->iv_des_mode))
        wlan_set_param(vap, IEEE80211_CONFIG_ENABLE_SCS, 1);
#endif

    retval = ieee80211_ucfg_set_freq(vap, &chan_p);
    if (!((retval == EOK) || (retval == -EBUSY))) {
        qdf_err("Invalid channel params!!! freq %d cfreq2 %d 6gpwrmode %d", params->chandef.chan->center_freq, params->chandef.center_freq2 ? params->chandef.center_freq2 : params->chandef.center_freq1, chan_p.input_6g_pwr_mode);
#ifdef WLAN_FEATURE_11BE
	qdf_err("puncture_bitmap 0x%X puncture_strict %d",
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)) && \
	defined(CFG80211_PUNCTURING_SINGLE_NETDEV_API)
		params->punct_bitmap,
#else
		params->chandef.puncture_bitmap,
#endif
                chan_p.puncture_strict);
        vap->vdev_obj->is_user_punc = false;
#endif
        return retval;
    }

    /*Save the user configured channel during wifi load*/
    ic->ic_userconfiguredchan_obj = *(vap->iv_des_chan[vap->iv_des_mode]);

    if (wlan_mlme_check_mbss_mixed_modes_config(vap) != QDF_STATUS_SUCCESS) {
        qdf_err("PHY mode mismatch for MBSSID vap (%s)", vap->iv_netdev_name);
        return -EINVAL;
    }

    if (wlan_cfg80211_vap_is_open(params,dev)) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                          "%s : Delete key in case of open security \n", __func__);
        delete_default_vap_keys(vap);
    }

    retval =  wlan_cfg80211_security_init(vap, params, dev);
    if (retval != EOK) {
        qdf_err("wlan_cfg80211_security_init returned error:%d", retval);
#ifdef WLAN_FEATURE_11BE
        vap->vdev_obj->is_user_punc = false;
#endif
        return retval;
    }

    if (wlan_reg_is_6ghz_chan_freq(params->chandef.chan->center_freq)) {
        retval = wlan_cfg80211_6ghz_security_check(vap);
        if (retval != EOK) {
            qdf_warn("Error in 6GHz security configured !!");
#ifdef WLAN_FEATURE_11BE
            vap->vdev_obj->is_user_punc = false;
#endif
            return -EINVAL;
        }
    }

    if ((opmode == IEEE80211_M_HOSTAP) && ic->ic_is_start_aid_set) {
         start_aid = ieee80211_get_vap_start_aid(ic, vap);
         vap->iv_max_aid = (ic->ic_num_clients + start_aid + 1);
#ifdef WLAN_FEATURE_11BE_MLO
         wlan_vdev_mlme_set_start_aid(vap->vdev_obj, start_aid-1);
         wlan_vdev_mlme_aid_mgr_max_aid_set(vap->vdev_obj, vap->iv_max_aid);
#endif
         qdf_debug("Start_aid:%d, vap->iv_max_aid:%d, vap:%s, ic->ic_is_start_aid_set:%d",start_aid, vap->iv_max_aid, vap->iv_netdev_name, ic->ic_is_start_aid_set);
    }

    /* if first vap is a nawds vap, bring it up as a non-tx vap */
    if (ic->is_mbssid_enabled &&
        (ieee80211_mbssid_get_num_beaconing_ap_vaps_up(ic,
            vap->iv_mbss.group_id) == 1) &&
                ieee80211_mbss_is_beaconing_ap(vap)) {
        if (ieee80211_ucfg_reset_nawds_txvap(vap)) {
#ifdef WLAN_FEATURE_11BE
            vap->vdev_obj->is_user_punc = false;
#endif
            return -EINVAL;
        }
    }

    mbss_info("Set tx-vap %s: vdev_id:%d",vap->iv_netdev_name, vap->iv_unit);
    ieee80211_ucfg_set_txvap(vap);

    if (ic->is_mbssid_enabled &&
        !ieee80211_mbssid_get_num_beaconing_ap_vaps_up(ic, vap->iv_mbss.group_id)) {
        if (ieee80211_mbss_is_beaconing_ap(vap)) {
            ic->ic_ema_config_init(vap);
        } else {
            mbss_debug("Skip calling ic_ema_config_init as vap%d is"
                       " not an AP that is part of an MBSSID group",
                       vap->iv_unit);
        }
    }

    if (!ic->is_mbssid_enabled) {
        /*
         * Beacon interval consistency check on VAPs in case of MBSSID
         */
        wlan_vap_up_check_beacon_interval(vap,opmode);
        if (ic->ic_need_vap_reinit) {
            wlan_if_t tmpvap;
            TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next) {
                struct net_device *tmpvap_netdev = ((osif_dev *)tmpvap->iv_ifp)->netdev;
                osifp = (osif_dev *)wlan_vap_get_registered_handle(tmpvap);
                if ((tmpvap != vap) && IS_UP(tmpvap_netdev) &&
                    (wlan_vdev_chan_config_valid(tmpvap->vdev_obj) == QDF_STATUS_SUCCESS)) {
                    OS_DELAY(10000);
                    if (osif_vap_init(osifp, tmpvap_netdev, RESCAN)) {
                        qdf_err("VAP init failed");
                        wlan_vap_down_check_beacon_interval(vap, opmode);
                    }
                }
            }
            ic->ic_need_vap_reinit = 0;
        }
    }
    else {
       if ((!ic->ic_mbss_ctx->ic_mbss[vap->iv_mbss.group_id].transmit_vap) &&
           (ieee80211_mbss_is_beaconing_ap(vap))) {
          qdf_err("vap%d:Tx vap should be configured before bringup of first VAP",
                  vap->iv_unit);
#ifdef WLAN_FEATURE_11BE
          vap->vdev_obj->is_user_punc = false;
#endif
          return -EOPNOTSUPP;
       }
    }

    vap->iv_is_6g_wps = 0;
    if (params->beacon.beacon_ies_len) {
        ptr = (u_int8_t *)params->beacon.beacon_ies;
        while (((ptr + 1) < params->beacon.beacon_ies + params->beacon.beacon_ies_len) &&
               (ptr + ptr[1] + 1 < params->beacon.beacon_ies + params->beacon.beacon_ies_len)) {
            if (ptr[0] == WLAN_ELEMID_VENDOR && iswpsoui(ptr)) {
                wps_ie = ptr;
                vap->iv_is_6g_wps = 1;
            }
            ptr += ptr[1] + 2;
        }
    }

    retval =  osif_vap_init((osif_dev *)vap->iv_ifp, dev, 0);
    if (retval) {
        qdf_warn("Error starting %s, ret: %d!!", dev->name, retval);
#ifdef WLAN_FEATURE_11BE
        vap->vdev_obj->is_user_punc = false;
#endif
        return retval;
    }

    if (wlan_cfg80211_set_htcap(vap, params->ht_cap))
          qdf_err("vap%d:HT CAP setting failed",
                  vap->iv_unit);

    if (wlan_cfg80211_set_vhtcap(vap, params->vht_cap))
          qdf_err("vap%d:VHT CAP setting failed",
                  vap->iv_unit);

    if (wlan_cfg80211_set_hecap(vap, params->he_cap))
          qdf_err("vap%d:HE CAP setting failed",
                  vap->iv_unit);

    /* In MBSS case, we start transmitting VAP
     * first followed by non-transmitting VAPs */
    if (!wlan_psoc_nif_fw_ext_cap_get(psoc,
                     WLAN_SOC_CEXT_MBSS_PARAM_IN_START) &&
        (ic->is_mbssid_enabled &&
        (!IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap)))) {
        TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next) {
            if ((tmpvap != vap) &&
                    (tmpvap->iv_mbss.group_id == vap->iv_mbss.group_id) &&
                    (strcmp(tmpvap->iv_bss->ni_essid, ""))) {
                struct net_device *tmpdev = ((osif_dev *)tmpvap->iv_ifp)->netdev;

                retval = osif_vap_init((osif_dev *)tmpvap->iv_ifp, tmpdev, 0);
                if (retval) {
                    qdf_warn("Error starting %s, ret: %d!!", tmpdev->name, retval);
                    continue;
                }
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
                dev_open(tmpdev, NULL);
#else
                dev_open(tmpdev);
#endif
            }
        }
    }

#ifdef WLAN_FEATURE_11BE_MLO
    if (reconfig)
        osif_mld_reconfig_link_add_start_ap(dev, mld_addr->bytes, vap->link_id);

    /* Check and start bridge VAPs */
    osif_start_mlo_bridge_vaps(vap);

    TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next) {
        if (!IEEE80211_IS_MLO_BRIDGE_VAP(tmpvap) || !tmpvap->iv_is_mlo_bridge_up)
            continue;
        if (wlan_vdev_chan_config_valid(tmpvap->vdev_obj) == QDF_STATUS_SUCCESS)
            continue;
        wlan_init_mlo_bridge_vap(tmpvap);
    }
#endif

#ifdef WLAN_FEATURE_11BE
    vap->vdev_obj->is_prev_user_punc = vap->vdev_obj->is_user_punc;
    vap->vdev_obj->is_user_punc = false;
#endif
    return retval;
}

int wlan_cfg80211_phyerr(struct wiphy *wiphy,
                struct wireless_dev *wdev,
                const void *data,
                int data_len)

{
        struct ieee80211com *ic = NULL;
        u_int8_t error;
        int cmd_type;
        void *cmd;
        struct ol_ath_softc_net80211 *scn = NULL;
        struct ath_diag *req = (struct ath_diag *)data;

        ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

        if (!ic) {
            qdf_err("ic NULL\n");
            return -EINVAL;
        }
        cmd = extract_command(ic, wdev, &cmd_type, 0);

        if (!cmd) {
            qdf_err("%s: cmd is NULL\n", __func__);
            return -EINVAL;
        }
        if (cmd_type) {
            scn =  (struct ol_ath_softc_net80211 *)cmd;
        } else {
            qdf_print("Invalid vap Command !");
            return -EINVAL;
        }
        error = ic->ic_cfg80211_radio_handler.ucfg_phyerr(scn, req);

        error = cfg80211_reply_command(wiphy, sizeof (struct ath_diag), req, 0);
        return error;
}

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
static int wlan_cfg80211_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev,
        unsigned int link_id, struct cfg80211_chan_def *chandef)
#else
static int wlan_cfg80211_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev,
        struct cfg80211_chan_def *chandef)
#endif
{
    struct ieee80211com *ic = NULL;
    struct ieee80211_ath_channel *ath_chan;
    struct ieee80211_channel *nl_chan;
    uint8_t i;

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, link_id);
#else
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
#endif

    if(!ic) {
        qdf_print("%s: Invalid ic struct pointer .....", __func__);
        return -1;
    }

#define N_MAX_CHECKS  10
    for (i = 0; i < N_MAX_CHECKS; i++) {

        ath_chan = ic->ic_curchan;
        if (IEEE80211_IS_CHAN_VALID(ath_chan)) {

            nl_chan = ieee80211_get_channel(ic->ic_wiphy,
                                            wlan_channel_frequency(ath_chan));
            if (!nl_chan) {
                qdf_print("%s: ieee80211_get_channel Failed .....", __func__);
                return -1;
            }

            /*
             * Check whether the chandef is valid before returning from
             * this function. If if is not valid then try to construct
             * it again until MAX count is reached.
             */
            ieee80211_cfg80211_construct_chandef(chandef, nl_chan, ic->ic_curchan);
            if (cfg80211_chandef_valid(chandef)) {
                break;
            }
        } else {
            qdf_print("%s: invalid channel ....",__func__);
            return -1;
        }
    }
    return 0;
}

/*
 * wlan_cfg80211_set_phymode: This function sets the phymode.
 * @wiphy: pointer to wiphy
 * @dev: pointer to struct netdev
 * @chandef : cfg80211_chan_def structure
 *
 * return 1/0
 */
int wlan_cfg80211_set_phymode(struct wiphy *wiphy,
        struct net_device *dev,
        struct cfg80211_ap_settings *params,
        struct cfg80211_chan_def chandef)
{
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;

    if ((dev == NULL) || (params == NULL))
        return -EINVAL;

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    osifp = get_vap_device_context(wiphy, dev, params->beacon.link_id);
#else
    osifp = get_vap_device_context(wiphy, dev, 0);
#endif

    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }
    vap = osifp->os_if;

    if (vap == NULL)
        return -EINVAL;

#if !CFG80211_SUPPORT_11AX_HOSTAPD
    /* Don't use cfg80211 chandefs for 6GHz */
    if (!wlan_reg_is_6ghz_chan_freq(chandef.chan->center_freq)) {
        switch(vap->iv_des_hw_mode) {
            case IEEE80211_MODE_11NG_HT40:
            case IEEE80211_MODE_11NA_HT40:
            case IEEE80211_MODE_11AC_VHT40:
            case IEEE80211_MODE_11AXG_HE40:
            case IEEE80211_MODE_11AXA_HE40:
#ifdef WLAN_FEATURE_11BE
            case IEEE80211_MODE_11BEG_EHT40:
            case IEEE80211_MODE_11BEA_EHT40:
#endif /* WLAN_FEATURE_11BE */
                /*
                 * If the desired mode doesn't specify the secondary channel
                 * offset then gather that information from the
                 * cfg80211 chandef structure.
                 */
                goto set_chandef_mode;
            break;

            default:
            break;
        }
    }
#endif /*! CFG80211_SUPPORT_11AX_HOSTAPD */

    /*
     * Support wireless modes that are not supported by cfg80211
     */
    if (ieee80211_is_phymode_valid(vap->iv_des_hw_mode)) {
        qdf_nofl_info("desired hw mode: %d", vap->iv_des_hw_mode);
        return ieee80211_ucfg_set_wirelessmode(vap, vap->iv_des_hw_mode);
    }

#if !CFG80211_SUPPORT_11AX_HOSTAPD
set_chandef_mode:
#endif /*! CFG80211_SUPPORT_11AX_HOSTAPD */
    return ieee80211_ucfg_set_wirelessmode(vap, wlan_cfg80211_chan_to_phymode(vap, params, chandef));
}


#if CFG80211_SUPPORT_11AX_HOSTAPD

enum hostpad_wireless_mode get_max_hostapd_supported_wireless_mode(
        struct cfg80211_ap_settings *params)
{
    qdf_nofl_info("HT Support:%p VHT Support:%p HE Support:%p",
            params->ht_cap, params->vht_cap, params->he_cap);

#ifdef WLAN_FEATURE_11BE
    if (params->eht_cap)
        return MODE_EHT;
#endif /* WLAN_FEATURE_11BE */
    if (params->he_cap)
        return MODE_HE;
    else if (params->vht_cap)
        return MODE_VHT;
    else if (params->ht_cap)
        return MODE_HT;
    else
        return MODE_ABG;
}

int cfg80211_chan_to_phymode_2g(struct cfg80211_ap_settings *params,
        struct cfg80211_chan_def chandef)
{
    int phymode  = IEEE80211_MODE_AUTO;
    enum hostpad_wireless_mode max_ap_mode;

    if (params == NULL)
        return -EINVAL;

    max_ap_mode = get_max_hostapd_supported_wireless_mode(params);
    qdf_nofl_info("Max supported wireless mode: %d", max_ap_mode);

    switch (chandef.width) {
        case NL80211_CHAN_WIDTH_20_NOHT:
            phymode = IEEE80211_MODE_11G;
            break;
        case NL80211_CHAN_WIDTH_20:
            switch(max_ap_mode) {
                case MODE_HT:
                    phymode = IEEE80211_MODE_11NG_HT20;
                    break;
                case MODE_HE:
                    phymode = IEEE80211_MODE_11AXG_HE20;
                    break;
                case MODE_ABG:
                     phymode = IEEE80211_MODE_11G;
                     break;
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                     phymode = IEEE80211_MODE_11BEG_EHT20;
                     break;
#endif /* WLAN_FEATURE_11BE */
                default:
                    phymode = IEEE80211_MODE_AUTO;
            }
            break;
        case NL80211_CHAN_WIDTH_40:
            if (chandef.chan->center_freq < chandef.center_freq1) {
                switch(max_ap_mode) {
                    case MODE_HT:
                        phymode = IEEE80211_MODE_11NG_HT40PLUS;
                        break;
                    case MODE_HE:
                        phymode = IEEE80211_MODE_11AXG_HE40PLUS;
                        break;
                    case MODE_ABG:
                        phymode = IEEE80211_MODE_11G;
                        break;
#ifdef WLAN_FEATURE_11BE
                    case MODE_EHT:
                        phymode = IEEE80211_MODE_11BEG_EHT40PLUS;
                        break;
#endif /* WLAN_FEATURE_11BE */
                    default:
                        phymode = IEEE80211_MODE_AUTO;
                }
            } else {
                switch(max_ap_mode) {
                    case MODE_HT:
                        phymode = IEEE80211_MODE_11NG_HT40MINUS;
                        break;
                    case MODE_HE:
                        phymode = IEEE80211_MODE_11AXG_HE40MINUS;
                        break;
                    case MODE_ABG:
                        phymode = IEEE80211_MODE_11G;
                        break;
#ifdef WLAN_FEATURE_11BE
                    case MODE_EHT:
                        phymode = IEEE80211_MODE_11BEG_EHT40MINUS;
                        break;
#endif /* WLAN_FEATURE_11BE */
                    default:
                        phymode = IEEE80211_MODE_AUTO;
                }
            }
            break;
        default:
            phymode = IEEE80211_MODE_AUTO;
            break;
    }
    return phymode;
}

int cfg80211_chan_to_phymode_5g(struct cfg80211_ap_settings *params,
        struct cfg80211_chan_def chandef)
{
    int phymode  = IEEE80211_MODE_AUTO;
    enum hostpad_wireless_mode max_ap_mode;

    if (params == NULL)
        return -EINVAL;

    max_ap_mode = get_max_hostapd_supported_wireless_mode(params);
    qdf_nofl_info("Max supported wireless mode: %d", max_ap_mode);

    switch (chandef.width) {
        case NL80211_CHAN_WIDTH_20_NOHT:
            phymode = IEEE80211_MODE_11A;
            break;
        case NL80211_CHAN_WIDTH_20:
            switch(max_ap_mode) {
                case MODE_HT:
                    phymode = IEEE80211_MODE_11NA_HT20;
                    break;
                case MODE_VHT:
                    phymode = IEEE80211_MODE_11AC_VHT20;
                    break;
                case MODE_HE:
                    phymode = IEEE80211_MODE_11AXA_HE20;
                    break;
                case MODE_ABG:
                    phymode = IEEE80211_MODE_11A;
                    break;
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT20;
                    break;
#endif /* WLAN_FEATURE_11BE */
                default:
                    phymode = IEEE80211_MODE_AUTO;
                    break;
            }
            break;
        case NL80211_CHAN_WIDTH_40:
            if (chandef.chan->center_freq < chandef.center_freq1) {
                switch(max_ap_mode) {
                    case MODE_HT:
                        phymode = IEEE80211_MODE_11NA_HT40PLUS;
                        break;
                    case MODE_VHT:
                        phymode = IEEE80211_MODE_11AC_VHT40PLUS;
                        break;
                    case MODE_HE:
                        phymode = IEEE80211_MODE_11AXA_HE40PLUS;
                        break;
                    case MODE_ABG:
                        phymode = IEEE80211_MODE_11A;
                    break;
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT40PLUS;
                    break;
#endif /* WLAN_FEATURE_11BE */
                    default:
                        phymode = IEEE80211_MODE_AUTO;
                        break;
                }
            } else {
                switch(max_ap_mode) {
                    case MODE_HT:
                        phymode = IEEE80211_MODE_11NA_HT40MINUS;
                        break;
                    case MODE_VHT:
                        phymode = IEEE80211_MODE_11AC_VHT40MINUS;
                        break;
                    case MODE_HE:
                        phymode = IEEE80211_MODE_11AXA_HE40MINUS;
                        break;
                    case MODE_ABG:
                        phymode = IEEE80211_MODE_11A;
                        break;
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT40MINUS;
                    break;
#endif /* WLAN_FEATURE_11BE */
                    default:
                        phymode = IEEE80211_MODE_AUTO;
                        break;
                }
            }
            break;
        case NL80211_CHAN_WIDTH_80:
            switch(max_ap_mode) {
                case MODE_VHT:
                    phymode = IEEE80211_MODE_11AC_VHT80;
                    break;
                case MODE_HE:
                    phymode = IEEE80211_MODE_11AXA_HE80;
                    break;
                case MODE_ABG:
                    phymode = IEEE80211_MODE_11A;
                    break;
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT80;
                    break;
#endif /* WLAN_FEATURE_11BE */
                default:
                    phymode = IEEE80211_MODE_AUTO;
                    break;
            }
            break;
        case NL80211_CHAN_WIDTH_80P80:
            switch(max_ap_mode) {
                case MODE_VHT:
                    phymode = IEEE80211_MODE_11AC_VHT80_80;
                    break;
                case MODE_HE:
                    phymode = IEEE80211_MODE_11AXA_HE80_80;
                    break;
                case MODE_ABG:
                    phymode = IEEE80211_MODE_11A;
                    break;
                default:
                    phymode = IEEE80211_MODE_AUTO;
            }
            break;
        case NL80211_CHAN_WIDTH_160:
            switch(max_ap_mode) {
                case MODE_VHT:
                    phymode = IEEE80211_MODE_11AC_VHT160;
                    break;
                case MODE_HE:
                    phymode = IEEE80211_MODE_11AXA_HE160;
                    break;
                case MODE_ABG:
                    phymode = IEEE80211_MODE_11A;
                    break;
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT160;
                    break;
#endif /* WLAN_FEATURE_11BE */
                default:
                    phymode = IEEE80211_MODE_AUTO;
            }
            break;
#ifdef WLAN_FEATURE_11BE
        case NL80211_CHAN_WIDTH_320:
            switch(max_ap_mode) {
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT320;
                    break;
                default:
                    phymode = IEEE80211_MODE_AUTO;
	    }
	    break;
#endif /* WLAN_FEATURE_11BE */
        default:
            break;
    }

    return phymode;
}

int cfg80211_chan_to_phymode_6g(struct cfg80211_ap_settings *params,
        struct cfg80211_chan_def chandef)
{
    int phymode  = IEEE80211_MODE_AUTO;
    enum hostpad_wireless_mode max_ap_mode;

    max_ap_mode = get_max_hostapd_supported_wireless_mode(params);
    qdf_nofl_info("%s: Max supported wireless mode: %d", __func__, max_ap_mode);

    switch (chandef.width) {
        case NL80211_CHAN_WIDTH_20:
            switch(max_ap_mode) {
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT20;
                    break;
#endif /* WLAN_FEATURE_11BE */
                case MODE_HE:
                    phymode = IEEE80211_MODE_11AXA_HE20;
                    break;
                default:
                    phymode = IEEE80211_MODE_AUTO;
                    break;
            }
            break;
        case NL80211_CHAN_WIDTH_40:
            if (chandef.chan->center_freq < chandef.center_freq1) {
                switch(max_ap_mode) {
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT40PLUS;
                    break;
#endif /* WLAN_FEATURE_11BE */
                    case MODE_HE:
                        phymode = IEEE80211_MODE_11AXA_HE40PLUS;
                        break;
                    default:
                        phymode = IEEE80211_MODE_AUTO;
                        break;
                }
            } else {
                switch(max_ap_mode) {
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT40MINUS;
                    break;
#endif /* WLAN_FEATURE_11BE */
                    case MODE_HE:
                        phymode = IEEE80211_MODE_11AXA_HE40MINUS;
                        break;
                    default:
                        phymode = IEEE80211_MODE_AUTO;
                        break;
                }
            }
            break;
        case NL80211_CHAN_WIDTH_80:
            switch(max_ap_mode) {
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT80;
                    break;
#endif /* WLAN_FEATURE_11BE */
                case MODE_HE:
                    phymode = IEEE80211_MODE_11AXA_HE80;
                    break;
                default:
                    phymode = IEEE80211_MODE_AUTO;
                    break;
            }
            break;
        case NL80211_CHAN_WIDTH_80P80:
            switch(max_ap_mode) {
                case MODE_HE:
                    phymode = IEEE80211_MODE_11AXA_HE80_80;
                    break;
                default:
                    phymode = IEEE80211_MODE_AUTO;
            }
            break;
        case NL80211_CHAN_WIDTH_160:
            switch(max_ap_mode) {
#ifdef WLAN_FEATURE_11BE
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT160;
                    break;
#endif /* WLAN_FEATURE_11BE */
                case MODE_HE:
                    phymode = IEEE80211_MODE_11AXA_HE160;
                    break;
                default:
                    phymode = IEEE80211_MODE_AUTO;
            }
            break;
#ifdef WLAN_FEATURE_11BE
        case NL80211_CHAN_WIDTH_320:
            switch(max_ap_mode) {
                case MODE_EHT:
                    phymode = IEEE80211_MODE_11BEA_EHT320;
                    break;
                default:
                    phymode = IEEE80211_MODE_AUTO;
	    }
	    break;
#endif /* WLAN_FEATURE_11BE */
        default:
            break;
    }

    return phymode;
}

/*
 * wlan_cfg80211_chan_to_phymode ; Convert the channel to phymode.
 * @chandef: cfg80211_chan_def
 * VHT20 / VHT40 - cfg80211 kernel support required.
 * 80P80 - we need to set nlvendor commands
 * return 1/0
 */
int
wlan_cfg80211_chan_to_phymode(struct ieee80211vap *vap,
        struct cfg80211_ap_settings *params,
        struct cfg80211_chan_def chandef)
{
    int phymode = IEEE80211_MODE_AUTO;

    if ((vap == NULL) || (params == NULL))
        return -EINVAL;

    qdf_nofl_info("%s: band:%d width: %d channel_cfreq: %d center_freq1: %d chandef.center_freq2: %d flags: %d", __func__,
            chandef.chan->band, chandef.width, chandef.chan->center_freq, chandef.center_freq1,
            chandef.center_freq2, chandef.chan->flags);

    switch (chandef.chan->band) {
        case IEEE80211_BAND_2GHZ:
            phymode = cfg80211_chan_to_phymode_2g(params, chandef);
            break;
        case IEEE80211_BAND_5GHZ:
            phymode = cfg80211_chan_to_phymode_5g(params, chandef);
            break;
        case IEEE80211_BAND_6GHZ:
            phymode = cfg80211_chan_to_phymode_6g(params, chandef);
            break;
        default:
            qdf_nofl_info("Invalid Band, Setting phymode to AUTO");
            phymode = IEEE80211_MODE_AUTO;
            break;
    }

    qdf_nofl_info("Phymode: %d \n", phymode);
    return phymode;
}
#else
/*
 * wlan_cfg80211_chan_to_phymode ; Convert the channel to phymode.
 * @chandef: cfg80211_chan_def
 * VHT20 / VHT40 - cfg80211 kernel support required.
 * 80P80 - we need to set nlvendor commands
 * return 1/0
 */

int
wlan_cfg80211_chan_to_phymode(struct ieee80211vap *vap,
        struct cfg80211_ap_settings *params,
        struct cfg80211_chan_def chandef)
{
    int phymode         = IEEE80211_MODE_AUTO;
    int desired_phymode;

    if ((vap == NULL) || (params == NULL))
        return -EINVAL;

    qdf_nofl_info("%s: band:%d width: %d channel_cfreq: %d center_freq1: %d chandef.center_freq2: %d flags: %d", __func__,
		    chandef.chan->band, chandef.width, chandef.chan->center_freq, chandef.center_freq1,
		    chandef.center_freq2, chandef.chan->flags);

    desired_phymode = vap->iv_des_hw_mode;
    switch (chandef.chan->band) {
        case IEEE80211_BAND_2GHZ:
            switch (chandef.width) {
                case NL80211_CHAN_WIDTH_20_NOHT:
                    phymode = IEEE80211_MODE_11G;
                    break;
                case NL80211_CHAN_WIDTH_20:

                    /* VHT20/HE20/HT20 */
                    switch (desired_phymode) {
                        case IEEE80211_MODE_11AXG_HE20:
                        case IEEE80211_MODE_11AXG_HE40:
                        case IEEE80211_MODE_11AXG_HE40PLUS:
                        case IEEE80211_MODE_11AXG_HE40MINUS:
                            phymode = IEEE80211_MODE_11AXG_HE20;
                            break;

                        default:
                            phymode = IEEE80211_MODE_11NG_HT20;
                    }
                    break;
                case NL80211_CHAN_WIDTH_40:
                    if (chandef.chan->center_freq < chandef.center_freq1) {
                        switch (desired_phymode) {
#ifdef WLAN_FEATURE_11BE
                            case IEEE80211_MODE_11BEG_EHT40:
                            case IEEE80211_MODE_11BEG_EHT40PLUS:
                            case IEEE80211_MODE_11BEG_EHT40MINUS:
                                phymode = IEEE80211_MODE_11BEG_EHT40PLUS;
                                break;
#endif /* WLAN_FEATURE_11BE */
                            case IEEE80211_MODE_11AXG_HE40:
                            case IEEE80211_MODE_11AXG_HE40PLUS:
                            case IEEE80211_MODE_11AXG_HE40MINUS:
                                phymode = IEEE80211_MODE_11AXG_HE40PLUS;
                                break;

                            default:
                                phymode = IEEE80211_MODE_11NG_HT40PLUS;
                        }
                    } else {
                        switch (desired_phymode) {
#ifdef WLAN_FEATURE_11BE
                            case IEEE80211_MODE_11BEG_EHT40:
                            case IEEE80211_MODE_11BEG_EHT40PLUS:
                            case IEEE80211_MODE_11BEG_EHT40MINUS:
                                phymode = IEEE80211_MODE_11BEG_EHT40MINUS;
                                break;
#endif /* WLAN_FEATURE_11BE */
                            case IEEE80211_MODE_11AXG_HE40:
                            case IEEE80211_MODE_11AXG_HE40PLUS:
                            case IEEE80211_MODE_11AXG_HE40MINUS:
                                phymode = IEEE80211_MODE_11AXG_HE40MINUS;
                                break;

                            default:
                                phymode = IEEE80211_MODE_11NG_HT40MINUS;
                        }
                    }
                    break;
                default:
                    phymode = IEEE80211_MODE_AUTO;
                    break;
            }
            break;

        case IEEE80211_BAND_5GHZ:
            switch (chandef.width) {
                case NL80211_CHAN_WIDTH_20_NOHT:
                    phymode = IEEE80211_MODE_11A;
                    break;
                case NL80211_CHAN_WIDTH_20:
                    switch (desired_phymode) {
#ifdef WLAN_FEATURE_11BE
                        case IEEE80211_MODE_11BEA_EHT20:
                        case IEEE80211_MODE_11BEA_EHT40:
                        case IEEE80211_MODE_11BEA_EHT40PLUS:
                        case IEEE80211_MODE_11BEA_EHT40MINUS:
                        case IEEE80211_MODE_11BEA_EHT80:
                        case IEEE80211_MODE_11BEA_EHT160:
                        case IEEE80211_MODE_11BEA_EHT320:
                            phymode = IEEE80211_MODE_11BEA_EHT20;
                            break;
#endif /* WLAN_FEATURE_11BE */
                        case IEEE80211_MODE_11AXA_HE20:
                        case IEEE80211_MODE_11AXA_HE40:
                        case IEEE80211_MODE_11AXA_HE40PLUS:
                        case IEEE80211_MODE_11AXA_HE40MINUS:
                        case IEEE80211_MODE_11AXA_HE80:
                        case IEEE80211_MODE_11AXA_HE160:
                        case IEEE80211_MODE_11AXA_HE80_80:
                            phymode = IEEE80211_MODE_11AXA_HE20;
                            break;

                        case IEEE80211_MODE_11AC_VHT20:
                        case IEEE80211_MODE_11AC_VHT40:
                        case IEEE80211_MODE_11AC_VHT40PLUS:
                        case IEEE80211_MODE_11AC_VHT40MINUS:
                        case IEEE80211_MODE_11AC_VHT80:
                        case IEEE80211_MODE_11AC_VHT160:
                        case IEEE80211_MODE_11AC_VHT80_80:
                            phymode = IEEE80211_MODE_11AC_VHT20;
                            break;

                        default:
                            phymode = IEEE80211_MODE_11NA_HT20;
                    }
                    break;
                case NL80211_CHAN_WIDTH_40:
                    if (chandef.chan->center_freq < chandef.center_freq1) {
                        switch (desired_phymode) {
#ifdef WLAN_FEATURE_11BE
                            case IEEE80211_MODE_11BEA_EHT40:
                            case IEEE80211_MODE_11BEA_EHT40PLUS:
                            case IEEE80211_MODE_11BEA_EHT40MINUS:
                            case IEEE80211_MODE_11BEA_EHT80:
                            case IEEE80211_MODE_11BEA_EHT160:
                            case IEEE80211_MODE_11BEA_EHT320:
                                phymode = IEEE80211_MODE_11BEA_EHT40PLUS;
                                break;
#endif /* WLAN_FEATURE_11BE */
                            case IEEE80211_MODE_11AXA_HE40:
                            case IEEE80211_MODE_11AXA_HE40PLUS:
                            case IEEE80211_MODE_11AXA_HE40MINUS:
                            case IEEE80211_MODE_11AXA_HE80:
                            case IEEE80211_MODE_11AXA_HE160:
                            case IEEE80211_MODE_11AXA_HE80_80:
                                phymode = IEEE80211_MODE_11AXA_HE40PLUS;
                                break;

                            case IEEE80211_MODE_11AC_VHT40:
                            case IEEE80211_MODE_11AC_VHT40PLUS:
                            case IEEE80211_MODE_11AC_VHT40MINUS:
                            case IEEE80211_MODE_11AC_VHT80:
                            case IEEE80211_MODE_11AC_VHT160:
                            case IEEE80211_MODE_11AC_VHT80_80:
                                phymode = IEEE80211_MODE_11AC_VHT40PLUS;
                                break;

                            default:
                                phymode = IEEE80211_MODE_11NA_HT40PLUS;
                        }
                    } else {
                        switch (desired_phymode) {
#ifdef WLAN_FEATURE_11BE
                            case IEEE80211_MODE_11BEA_EHT40:
                            case IEEE80211_MODE_11BEA_EHT40PLUS:
                            case IEEE80211_MODE_11BEA_EHT40MINUS:
                            case IEEE80211_MODE_11BEA_EHT80:
                            case IEEE80211_MODE_11BEA_EHT160:
                            case IEEE80211_MODE_11BEA_EHT320:
                                phymode = IEEE80211_MODE_11BEA_EHT40MINUS;
                                break;
#endif /* WLAN_FEATURE_11BE */
                            case IEEE80211_MODE_11AXA_HE40:
                            case IEEE80211_MODE_11AXA_HE40PLUS:
                            case IEEE80211_MODE_11AXA_HE40MINUS:
                            case IEEE80211_MODE_11AXA_HE80:
                            case IEEE80211_MODE_11AXA_HE160:
                            case IEEE80211_MODE_11AXA_HE80_80:
                                phymode = IEEE80211_MODE_11AXA_HE40MINUS;
                                break;

                            case IEEE80211_MODE_11AC_VHT40:
                            case IEEE80211_MODE_11AC_VHT40PLUS:
                            case IEEE80211_MODE_11AC_VHT40MINUS:
                            case IEEE80211_MODE_11AC_VHT80:
                            case IEEE80211_MODE_11AC_VHT160:
                            case IEEE80211_MODE_11AC_VHT80_80:
                                phymode = IEEE80211_MODE_11AC_VHT40MINUS;
                                break;

                            default:
                                phymode = IEEE80211_MODE_11NA_HT40MINUS;
                        }
                    }
                    break;
                case NL80211_CHAN_WIDTH_80:
                    switch (desired_phymode) {
#ifdef WLAN_FEATURE_11BE
                        case IEEE80211_MODE_11BEA_EHT80:
                        case IEEE80211_MODE_11BEA_EHT160:
                        case IEEE80211_MODE_11BEA_EHT320:
                            phymode = IEEE80211_MODE_11BEA_EHT80;
                            break;
#endif /* WLAN_FEATURE_11BE */
                        case IEEE80211_MODE_11AXA_HE80:
                        case IEEE80211_MODE_11AXA_HE160:
                        case IEEE80211_MODE_11AXA_HE80_80:
                            phymode = IEEE80211_MODE_11AXA_HE80;
                            break;

                        default:
                            phymode = IEEE80211_MODE_11AC_VHT80;
                    }
                    break;
                case NL80211_CHAN_WIDTH_80P80:
                    switch (desired_phymode) {
                        case IEEE80211_MODE_11AXA_HE160:
                        case IEEE80211_MODE_11AXA_HE80_80:
                            phymode = IEEE80211_MODE_11AXA_HE80_80;
                            break;

                        default:
                            phymode = IEEE80211_MODE_11AC_VHT80_80;
                    }
                    break;
                case NL80211_CHAN_WIDTH_160:
                    switch (desired_phymode) {
#ifdef WLAN_FEATURE_11BE
                        case IEEE80211_MODE_11BEA_EHT160:
                            phymode = IEEE80211_MODE_11BEA_EHT160;
                            break;
#endif /* WLAN_FEATURE_11BE */
                        case IEEE80211_MODE_11AXA_HE160:
                        case IEEE80211_MODE_11AXA_HE80_80:
                            phymode = IEEE80211_MODE_11AXA_HE160;
                            break;

                        default:
                            phymode = IEEE80211_MODE_11AC_VHT160;
                    }
                    break;
                default:
                    phymode = IEEE80211_MODE_AUTO;
                    break;

            }
            break;
        default:
            qdf_print("Setting phymode to AUTO");
            phymode = IEEE80211_MODE_AUTO;
            break;
    }

    return phymode;
}
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */

#if ATH_SUPPORT_HS20
extern int ieee80211dbg_setqosmapconf(wlan_if_t vap,
                                      struct ieee80211req_athdbg *req);

int wlan_cfg80211_set_qos_map(struct wiphy *wiphy,
        struct net_device *dev,
        struct cfg80211_qos_map *qos_map)
{
   struct ieee80211req_athdbg *req;

   if (qos_map) {
      int status = 0;
      osif_dev *osifp = get_vap_device_context(wiphy, dev, INVALID_LINK_ID);
      if (!osifp || !osifp->os_if)
         return -EINVAL;

      req = qdf_mem_malloc(sizeof(struct ieee80211req_athdbg));
      if ( req == NULL )
         return -ENOMEM;
      OS_MEMCPY(req->data.qos_map.up, qos_map->up, IEEE80211_MAX_QOS_UP_RANGE * (sizeof(struct ieee80211_dscp_range)));
      OS_MEMCPY(req->data.qos_map.dscp_exception, qos_map->dscp_exception, IEEE80211_QOS_MAP_MAX_EX * (sizeof (struct ieee80211_dscp_exception)));
      req->data.qos_map.num_dscp_except = qos_map->num_des;
      req->data.qos_map.valid = 1;

      status = ieee80211dbg_setqosmapconf(osifp->os_if, req);
      qdf_mem_free(req);
      return status;
   }
   else
      return 0;
}
#endif


static void ieee80211_cfg80211_copy_rates(wlan_if_t vap,
                                          struct ieee80211_rateset *target_rs)
{
    int i =0;
    enum ieee80211_phymode mode = wlan_get_desired_phymode(vap);
    struct ieee80211_rateset *op_rs = &(vap->iv_op_rates[mode]);

    for (i = 0; i < op_rs->rs_nrates; i++) {
        /* Clear basic rates flag */
        target_rs->rs_rates[i] = op_rs->rs_rates[i] & IEEE80211_RATE_VAL;
    }
    target_rs->rs_nrates = op_rs->rs_nrates;
}

int ieee80211_cfg80211_mark_basic_rate(struct ieee80211_rateset *ops_rs,
                                       int basic_rate)
{
    int i =0, found = 0;
    for (i = 0; i < ops_rs->rs_nrates; i++) {
        /* set basic rates flag */
        if (ops_rs->rs_rates[i] == basic_rate) {
            ops_rs->rs_rates[i] |= IEEE80211_RATE_BASIC;
            found = 1;
            break;
        }
    }
    return found;
}

int is_valid_basic_rate(int *list, int rate)
{
    int i;

    if (list == NULL) {
        qdf_err("list is NULL");
        return 0;
    }

    for (i = 0; list[i] >= 0; i++) {
        qdf_debug("list[%d]:%u, rate:%u", i, list[i], rate);
        if (list[i] == rate) {
            return 1;
        }
    }
    return 0;
}


int wlan_cfg80211_change_bss(struct wiphy *wiphy,
        struct net_device *dev,
        struct bss_parameters *params)
{
    struct ieee80211com *ic;
    uint8_t enable_cfg80211_compliance;
    enum ieee80211_phymode mode;
    int basic_rates_a[] = { 12, 24, 48, -1 };
    int basic_rates_b[] = { 2, 4, -1 };
    int basic_rates_g[] = { 2, 4, 11, 22, -1 };
    int *valid_basic_rates = NULL;

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    ic = wlan_cfg80211_get_ic_ptr(wiphy, dev->ieee80211_ptr, params->link_id);
#else
    ic = wlan_cfg80211_get_ic_ptr(wiphy, dev->ieee80211_ptr, INVALID_LINK_ID);
#endif

    if (!ic) {
        qdf_err("ic is NULL\n");
        return -EINVAL;
    }

    enable_cfg80211_compliance = ic->ic_cfg80211_compliance_mode;

    if (enable_cfg80211_compliance & CFG80211_SUPPORT_BSS_PARAMS) {
        int retv = 0;
        wlan_if_t vap;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
        osif_dev *osifp = get_vap_device_context(wiphy, dev, params->link_id);
#else
        osif_dev *osifp = get_vap_device_context(wiphy, dev, INVALID_LINK_ID);
#endif
        struct ieee80211_rateset bss_rs = {0};
        struct ol_ath_softc_net80211 *scn = NULL;
        int i;

        if (!osifp) {
            qdf_err("NULL osifp\n");
            return -EINVAL;
        }

        vap = osifp->os_if;
        if (!vap) {
            qdf_err("vap is NULL\n");
            return -EINVAL;
        }

        scn = OL_ATH_SOFTC_NET80211(ic);

        if (params->ap_isolate == CFG80211_BSS_PARAM_SET) {
            qdf_debug("ap_isolate: %d", params->ap_isolate);
            retv = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_APBRIDGE, !params->ap_isolate, NULL, false, false);
            if (retv != EOK) {
                qdf_err("ap_isolate not set \n");
            }
        }

        if (params->use_cts_prot != CFG80211_BSS_PARAM_NOT_CHANGED) {
            qdf_debug("use_cts_prot:%d", params->use_cts_prot);
            retv = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_PROTMODE, params->use_cts_prot, NULL, false, false);
            if (retv != EOK) {
                qdf_err("use_cts_prot not set\n");
            }
        }

        if ((params->use_short_preamble != CFG80211_BSS_PARAM_NOT_CHANGED) &&
             (enable_cfg80211_compliance & CFG80211_SUPPORT_BSS_PARAMS_SHORT_PREAMBLE)) {
            qdf_debug("use_short_preamble:%d", params->use_short_preamble);
            retv = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_SHORTPREAMBLE, params->use_short_preamble, NULL, false, false);
            if (retv !=EOK) {
                qdf_err("use_short_preamble not set\n");
            }
        }

        if (params->use_short_slot_time != CFG80211_BSS_PARAM_NOT_CHANGED) {
            qdf_debug("use_short_slot_time:%d", params->use_short_slot_time);
            retv = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_SHORT_SLOT, params->use_short_slot_time, NULL, false, false);
            if (retv !=EOK) {
                qdf_err("use_short_slot_time not set\n");
            }
        }

        if (params->basic_rates) {
            mode = wlan_get_desired_phymode(vap);

            if (mode == IEEE80211_MODE_11B) {
                valid_basic_rates = &basic_rates_b[0];
            } else if (ieee80211_is_phymode_2g(mode)) {
                valid_basic_rates = &basic_rates_g[0];
            } else if (ieee80211_is_phymode_5g_or_6g(mode)) {
                valid_basic_rates = &basic_rates_a[0];
            } else {
                qdf_err("Invalid phymode");
                return -1;
            }

            /* Copy iv_op_rates to bss_rs and clear basic rates flag */
            ieee80211_cfg80211_copy_rates(vap, &bss_rs);

            qdf_debug("number of basic rates:%d\n", params->basic_rates_len);
            for (i = 0; i < (params->basic_rates_len) ; i++) {
                qdf_debug("basic_rates[%d]: %u", i, params->basic_rates[i]);
                /* Find it is valid basic rate or not for a given mode */
                if (is_valid_basic_rate(valid_basic_rates, params->basic_rates[i])) {
                    /* Loop Through rates list and mark that rate as Basic */
                    if(!ieee80211_cfg80211_mark_basic_rate(&bss_rs, params->basic_rates[i]))
                        qdf_err("Unable to set basic rate %u", params->basic_rates[i]);
                } else {
                    qdf_err("Invalid Rate %u", params->basic_rates[i]);
                }
            }

            /* At this point we have all supported rates from VAP
               all basic rates are set as per callback */
            retv = ic->ic_cfg80211_radio_handler.set_op_support_rates(scn, &bss_rs);
            if (retv != EOK) {
                qdf_err("basic_rates not set\n");
            }
        }

        return retv;
    } else {
        int retv;
        wlan_if_t vap;

        if (params->ap_isolate == 1) {
            osif_dev *osifp = get_vap_device_context(wiphy, dev, 0);
            if (!osifp) {
                qdf_err("NULL osifp\n");
                return -EINVAL;
            }

            vap = osifp->os_if;
            if (!vap) {
                qdf_err("vap is NULL\n");
                return -EINVAL;
            }

            retv = ieee80211_ucfg_setparam_util(vap, IEEE80211_PARAM_APBRIDGE, 0, NULL, false, false);

            if (retv != EOK) {
                qdf_err("ap_isolate not set \n");
            }
        }
    }

    return 0;
}

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
int wlan_cfg80211_add_key(struct wiphy *wiphy,
        struct net_device *ndev, int link_id,
        u8 key_index, bool pairwise,
        const u8 *mac_addr,
        struct key_params *params)
#else
int wlan_cfg80211_add_key(struct wiphy *wiphy,
        struct net_device *ndev,
        u8 key_index, bool pairwise,
        const u8 *mac_addr,
        struct key_params *params)
#endif
{
    int error = -EOPNOTSUPP;
    osif_dev *osifp = NULL;

#if defined(CFG80211_MLO_SINGLE_NETDEV_API) && defined(ENABLE_CFG80211_BACKPORTS_MLO)
    if (pairwise && link_id == -1)
       osifp = get_vap_device_context_no_linkid(wiphy, ndev, mac_addr);
    else
       osifp = get_vap_device_context(wiphy, ndev, link_id);
#else
    osifp = get_vap_device_context(wiphy, ndev, INVALID_LINK_ID);
#endif

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
    error = wlan_cfg80211_add_key_common(osifp, link_id, key_index, pairwise, mac_addr, params);
#else
    {
        wlan_if_t vap = NULL;
        if (!osifp) {
            qdf_err("osifp is null on add key");
            return -1;
        }

        vap = osifp->os_if;
        if (!vap || !vap->iv_ic) {
            qdf_err("VAP or ic is null on add key");
            return -1;
        }

        if (vap->iv_ic->recovery_in_progress) {
             qdf_info("Recovery in progress, unable to add key");
             return -1;
         }

        error = wlan_cfg80211_add_key_common(osifp, key_index, pairwise, mac_addr, params);
    }
#endif

    return error ? -1:0;
}

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
int wlan_cfg80211_del_key(struct wiphy *wiphy,
        struct net_device *ndev, int link_id,
        u8 key_index, bool pairwise,
        const u8 *mac_addr)
#else
int wlan_cfg80211_del_key(struct wiphy *wiphy,
        struct net_device *ndev,
        u8 key_index, bool pairwise,
        const u8 *mac_addr)
#endif
{
    int error = -EOPNOTSUPP;
    osif_dev *osifp = NULL;

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
    osifp = get_vap_device_context(wiphy, ndev, link_id);
#else
    osifp = get_vap_device_context(wiphy, ndev, INVALID_LINK_ID);
#endif
    if (!osifp)
       osifp = get_vap_device_context_no_linkid(wiphy, ndev, mac_addr);

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
    error = wlan_cfg80211_del_key_common(osifp, link_id, key_index, pairwise, mac_addr);
#else
    error = wlan_cfg80211_del_key_common(osifp, key_index, pairwise, mac_addr);
#endif

    return error;
}

#define HE_MAC_CAP_OFFSET 3
#define HE_MAC_CAP_SIZE 6
#define HE_PHY_CAP_OFFSET (HE_MAC_CAP_OFFSET + HE_MAC_CAP_SIZE)
#define HE_PHY_CAP_SIZE 11

/**
 * wlan_cfg80211_caps: Set HT, VHT and HE capabilities from Beacon data
 * @vap: VAP handle.
 * @beacon: BEacon data received from change_beacon.
 * Return: QDF_STATUS_SUCCESS if CAPs set successfully.
           QDF_STATUS_E_* otherwise.
 */
static QDF_STATUS wlan_set_caps(struct ieee80211vap *vap,
                                struct cfg80211_beacon_data *beacon)
{
    u_int8_t *ptr;
    u_int8_t *ht_cap_ie = NULL;
    u_int8_t *vht_cap_ie = NULL;
    u_int8_t *he_cap_ie = NULL;
    struct ieee80211_he_cap_elem hecap = {0};

    if (!vap || !beacon)
        return QDF_STATUS_E_NULL_VALUE;

    ptr = (u_int8_t *)beacon->tail;
    if (!ptr || !beacon->tail_len)
        return QDF_STATUS_E_NULL_VALUE;

    if ((vap->iv_opmode != IEEE80211_M_HOSTAP) ||
        !(vap->iv_ic->ic_cfg80211_compliance_mode & CFG80211_SUPPORT_CHANGE_BCN))
        return QDF_STATUS_SUCCESS;

    while (((ptr + 1) < (u_int8_t *)beacon->tail + beacon->tail_len) &&
           (ptr + ptr[1] + 1 < (u_int8_t *)beacon->tail + beacon->tail_len)) {
        if (ptr[0] == WLAN_ELEMID_HTCAP_ANA) {
            ht_cap_ie = ptr;
        } else if (ptr[0] == WLAN_ELEMID_VHTCAP) {
            vht_cap_ie = ptr;
        } else if (ptr[0] == WLAN_ELEMID_EXTN_ELEM) {
            if ((ptr[1] >= 1) && (ptr[2] == WLAN_EXTN_ELEMID_HECAP))
                he_cap_ie = ptr;
        }
        ptr += ptr[1] + 2;
    }

    if (ht_cap_ie &&
        ht_cap_ie[1] >= sizeof(struct ieee80211_ht_cap)) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                          "Setting HTCAP from change beacon\n");
        wlan_cfg80211_set_htcap(vap,
                                (struct ieee80211_ht_cap *)(ht_cap_ie + 2));
    }

    if (vht_cap_ie &&
        vht_cap_ie[1] >= sizeof(struct ieee80211_vht_cap)) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                          "Setting VHTCAP from change beacon\n");
        wlan_cfg80211_set_vhtcap(vap,
                                 (struct ieee80211_vht_cap *)(vht_cap_ie + 2));
    }

    if (he_cap_ie &&
        (he_cap_ie[1] > sizeof(struct ieee80211_he_cap_elem))) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                          "Setting HECAP from change beacon\n");
        qdf_mem_copy(hecap.mac_cap_info, he_cap_ie + HE_MAC_CAP_OFFSET,
                     HE_MAC_CAP_SIZE);
        qdf_mem_copy(hecap.phy_cap_info, he_cap_ie + HE_PHY_CAP_OFFSET,
                     HE_PHY_CAP_SIZE);
        wlan_cfg80211_set_hecap(vap, &hecap);
    }

    return QDF_STATUS_SUCCESS;
}

/**
 * wlan_cfg80211_change_beacon() - change beacon content in sap mode
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to netdev
 * @params: Pointer to change beacon parameters
 *
 * Return: zero for success non-zero for failure
 */

int wlan_cfg80211_change_beacon(struct wiphy *wiphy,
        struct net_device *dev,
        struct cfg80211_beacon_data *params)
{
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    osif_dev *osifp = get_vap_device_context(wiphy, dev, params->link_id);
#else
    osif_dev *osifp = get_vap_device_context(wiphy, dev, 0);
#endif
    wlan_if_t vap = osifp->os_if;
    if (EOK != wlan_set_beacon_ies(vap, dev, params))
        return -EINVAL;

    if (QDF_STATUS_SUCCESS != wlan_set_caps(vap, params))
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                          "vap%d:failed to set HT/VHT/HE caps", vap->iv_unit);
    return EOK;
}

#ifdef CONFIG_AFC_SUPPORT
/**
 * wlan_standalone_ap_afc_is_stop_ap_allowed - is stop_ap allowed for a standalone
 * AP. For a standalone AP, stop need not be processed, if,
 * i) the previous operating channel was 6GHz channel.
 * ii) the device is deployed in outdoor mode.
 * iii) a valid AFC power event was received.
 * iv) the AFC response is not valid for the previous channel.
 *
 * @vdev- vdev object manager.
 * @freq - previous operating 6GHz channel.
 * return true if allowed; false if not allowed.
 */
static bool
wlan_standalone_ap_afc_is_stop_ap_allowed(struct wlan_objmgr_vdev *vdev, qdf_freq_t freq)
{
    /* wlan_rptr_afc_is_stop_ap_allowed() API checks if the input vdev is a
     * standalone AP or has a STA vdev in its radio. So, it is common for
     * both standalone AP and a repeater AP.
     */
    return wlan_rptr_afc_is_stop_ap_allowed(vdev, freq);
}
#endif /*CONFIG_AFC_SUPPORT*/

/**
 * wlan_cfg80211_stop_ap - stop ap vap
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to netdev
 *
 * Return: zero for success non-zero for failure
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
int wlan_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,
                         unsigned int link_id)
#else
int wlan_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,
                         struct cfg80211_ap_settings *params)
#endif
{
    /*
     * Below cases possible with single wiphy arch
     * 1. Stop AP we will get for MLO link VAPs with link_id & mld netdev,
     * 2. single Wiphy + Legacy VAP with link_id = 0.
     * 3. Legacy Netdev (non Single Wiphy)
     */
    int retval = 0;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)) || defined(ENABLE_CFG80211_BACKPORTS_MLO)
    osif_dev *osdev = get_vap_device_context(wiphy, dev, link_id);
#else
    uint8_t  link_id = INVALID_LINK_ID;
    osif_dev *osdev = get_vap_device_context(wiphy, dev, link_id);
#endif
    wlan_if_t vap;
    wlan_if_t tmpvap;
    struct ieee80211com *ic;
    struct wlan_objmgr_psoc *psoc;
#ifdef WLAN_FEATURE_11BE_MLO
    uint8_t reconfig = 0;
    bool is_link_del_flag_set;
    struct wlan_mlo_dev_context *dev_ctx;
#endif
#ifdef CONFIG_AFC_SUPPORT
    enum reg_afc_dev_deploy_type reg_afc_deploy_type;
#endif

    if (!osdev) {
        qdf_err("NULL osdev");
        return -1;
    }

    vap = osdev->os_if;
    if (!vap) {
        qdf_err("NULL vap");
        return -1;
    }

    ic = vap->iv_ic;

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if (psoc == NULL) {
        QDF_ASSERT(0);
        return -1;
    }

#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
    if (!params) {
        qdf_err("params is NULL");
        return -1;
    }
#endif

    qdf_info("Stop %s psoc:%u vdev:%u", vap->iv_netdev_name,
             wlan_vdev_get_psoc_id(vap->vdev_obj), wlan_vdev_get_id(vap->vdev_obj));
#ifdef CONFIG_AFC_SUPPORT
    if (!wlan_rptr_afc_is_stop_ap_allowed(vap->vdev_obj,
                                          ic->ic_curchan->ic_freq) ||
        /* If the Hostapd sends a stop_ap for a standalone AP, the Hostapd
         * channel(vap->chandef_notify.chan) is not present in the current channel
         * held by Hostapd. In such cases, a stop_ap being sent would not be meant
         * current channel and so, it needs to be dropped.
         */
        (vap->chan_notify.chandef_notify.chan && !wlan_standalone_ap_afc_is_stop_ap_allowed(vap->vdev_obj,
                                                   vap->chan_notify.chandef_notify.chan->center_freq))) {
        qdf_nofl_info("stop_ap not processed for %s\n", vap->iv_netdev_name);
        return -1;
    }

    wlan_reg_get_afc_dev_deploy_type(ic->ic_pdev_obj, &reg_afc_deploy_type);

    if (wlan_reg_is_6ghz_chan_freq(ic->ic_curchan->ic_freq) &&
        reg_afc_deploy_type == AFC_DEPLOYMENT_OUTDOOR) {
        /* send a trigger to set CLIENT SP power mode */
        if (ic->ic_sta_vap)
            ieee80211_send_tpc_power_cmd(ic->ic_sta_vap);
    }
#endif

#ifdef WLAN_FEATURE_11BE_MLO
#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
    reconfig = params->mlo_info.reconfig;
#endif
    if (reconfig) {
        qdf_err("stop-ap with reconfig flag ON %s\n", vap->iv_netdev_name);
        if (ic->is_mbssid_enabled && !IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap)) {
            /* Iterate through all non-Tx vaps that are in "UP" state
             * and replicate WLAN_VDEV_OP_MLO_STOP_LINK_DEL flag for
             * each of them
             */
            is_link_del_flag_set = true;
            wlan_do_iter_fun_mbss_group(vap->iv_ic, vap->iv_mbss.group_id,
                MBSS_ITER_FUNC_PURPOSE_UPDATE_LINK_DEL_FLAG, &is_link_del_flag_set);
        }

        wlan_vdev_mlme_op_flags_set(vap->vdev_obj, WLAN_VDEV_OP_MLO_STOP_LINK_DEL);
        vap->ml_ap_removal_in_progress = true;
        /* Reset this flag not to send deauth during link removal */
        vap->iv_send_deauth = 0;

        dev_ctx = vap->vdev_obj->mlo_dev_ctx;

        mlo_dev_lock_acquire(dev_ctx);
        dev_ctx->ap_ctx->vdev_up_candidate_count--;
        mlo_dev_lock_release(dev_ctx);
    }
    else {
        if (ic->is_mbssid_enabled && !IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap)) {
            /* Iterate through all non-Tx vaps to check and clear
             * WLAN_VDEV_OP_MLO_STOP_LINK_DEL and WLAN_VDEV_OP_MLO_LINK_TBTT_COMPLETE
             */
            is_link_del_flag_set = false;
            wlan_do_iter_fun_mbss_group(vap->iv_ic, vap->iv_mbss.group_id,
                MBSS_ITER_FUNC_PURPOSE_UPDATE_LINK_DEL_FLAG, &is_link_del_flag_set);
        }
        vap->ml_ap_removal_in_progress = false;
        wlan_vdev_mlme_op_flags_clear(vap->vdev_obj, WLAN_VDEV_OP_MLO_STOP_LINK_DEL);
        wlan_vdev_mlme_op_flags_clear(vap->vdev_obj, WLAN_VDEV_OP_MLO_LINK_TBTT_COMPLETE);
        if (wlan_vdev_mlme_op_flags_get(vap->vdev_obj, WLAN_VDEV_OP_MLO_LINK_REMOVAL_IN_PROGRESS))
            wlan_vdev_dec_skip_pumac_cnt(vap->vdev_obj);
        wlan_vdev_mlme_op_flags_clear(vap->vdev_obj, WLAN_VDEV_OP_MLO_LINK_REMOVAL_IN_PROGRESS);
    }
    wlan_mlme_mlo_remove_vap_partner_mlinfo(vap);
#endif
    /*Reset wps flag*/
    vap->iv_wps_mode = 0;
    /* In MBSS case, non-transmitting VAPs are stopped first followed by transmitting VAP */

    if (!wlan_psoc_nif_fw_ext_cap_get(psoc,
                     WLAN_SOC_CEXT_MBSS_PARAM_IN_START) &&
        (ic->is_mbssid_enabled &&
        (!IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap)))) {
        TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next) {
            struct net_device *tmpdev = get_cfg80211_notification_ndev((osif_dev *)tmpvap->iv_ifp);

            if (IS_UP(tmpdev) && (tmpvap != vap) &&
                    (tmpvap->iv_mbss.group_id == vap->iv_mbss.group_id)) {
                wlan_mlme_mlo_remove_vap_partner_mlinfo(tmpvap);
                retval = osif_vap_stop_wrapper((osif_dev *)tmpvap->iv_ifp);
                if (retval) {
                    qdf_warn("Error while stopping %s, ret:%d", tmpdev->name, retval);
                    continue;
                }
#ifdef WLAN_FEATURE_11BE_MLO
                if (reconfig && ((osif_dev *)tmpvap->iv_ifp)->mldev) {
                    qdf_info("%s is in UP state", tmpdev->name);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
                    if (!((osif_dev *)tmpvap->iv_ifp)->mldev)
#endif
                        tmpdev->flags &= ~IFF_UP;
                    osif_mld_reconfig_link_delete_stop_ap(dev, vap->link_id);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
                    if (!((osif_dev *)tmpvap->iv_ifp)->mldev)
#endif
                        tmpdev->flags |= IFF_UP;
                }
                /**
                 * If Tx VAP is going through ML AP removal, avoid explicit dev_close on
                 * Non-Tx VAPs. This is because dev_close would trigger an internal
                 * wlan_cfg80211_stop_ap() to be sent by the kernel without the reconfig
                 * flag set. So, we would end up clearing the previously set reconfig flag,
                 * which would bringdown the entire MLD of Non-Tx VAP.
                 */
                if (!reconfig)
#endif
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
                    if (!((osif_dev *)tmpvap->iv_ifp)->mldev)
#endif
                        dev_close(tmpdev);
            }
        }
    }

    retval = osif_vap_stop_wrapper(osdev);

#ifdef WLAN_FEATURE_11BE_MLO
    if (!retval && reconfig && osdev->mldev) {
        if (dev->flags & IFF_UP) {
            qdf_info("%s is in UP state", dev->name);
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
            dev->flags &= ~IFF_UP;
#endif
            osif_mld_reconfig_link_delete_stop_ap(dev, vap->link_id);
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
            dev->flags |= IFF_UP;
#endif
        } else
            osif_mld_reconfig_link_delete_stop_ap(dev, vap->link_id);
    }
#endif
    return retval;
}

void wlan_cfg80211_scan_abort_internal(struct ieee80211com *ic,
                                       struct wlan_objmgr_vdev *vdev)
{
    struct wlan_objmgr_pdev *pdev = ic->ic_pdev_obj;
    uint32_t pdev_id = wlan_objmgr_pdev_get_pdev_id(pdev);
    uint32_t vdev_id = wlan_vdev_get_id(vdev);
    uint32_t scan_id = CANCEL_HOST_SCAN_ID;
    QDF_STATUS status;

    status = wlan_abort_scan(pdev, pdev_id, vdev_id, scan_id, true);
    if (QDF_IS_STATUS_ERROR(status)) {
        qdf_debug("scan abort failed. status: %d", status);
    }
}

/**
 * wlan_cfg80211_scan_abort - abort ongoing scan
 * @wiphy: Pointer to wiphy
 * @wdev: Pointer to wireless_dev
 *
 * Return: void
 */
void wlan_cfg80211_scan_abort(struct wiphy *wiphy, struct wireless_dev *wdev)
{
    struct net_device *dev;
    struct ieee80211com *ic;
    osif_dev *osifp = NULL;
    struct cfg80211_context *cfg_ctx = NULL;
    wlan_if_t vap;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct osif_mldev *osifp_mldev;
    int j;
#endif
    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
    dev = wdev->netdev;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    /* do not honour if this is radio netdev */
    if (cfg_ctx->is_mld_phy) {
        if (is_mld_phy_radio_command(wiphy, dev))
            return;
    } else {
        if (cfg_ctx->ic_list[0]->ic_wdev.netdev == dev)
            return;
    }
    osifp_mldev = osif_mld_get_mldev(dev);
    if ((!cfg_ctx->is_mld_phy) ||
        (osifp_mldev->dev_type != OSIF_NETDEV_TYPE_MLO)) {
        osifp_mldev = NULL;
        osifp = get_vap_device_context(wiphy, dev, 0);
        vap = osifp->os_if;
        ic = vap->iv_ic;
        wlan_cfg80211_scan_abort_internal(ic, vap->vdev_obj);
    } else {
        for (j = 0; j < IEEE80211_MLD_MAX_NUM_LINKS; j++) {
             osifp =  osifp_mldev->link_vifs[j];
             if (!osifp)
                 continue;
             vap = osifp->os_if;
             if (!vap) {
                 qdf_err("VAP NULL on link %d", j);
                 return;
             }
             ic = vap->iv_ic;
             wlan_cfg80211_scan_abort_internal(ic, vap->vdev_obj);
        }
     }
#else
    ic = cfg_ctx->ic;
    if (ic->ic_wdev.netdev == dev)
        return;
    osifp = get_vap_device_context(wiphy, dev, 0);
    vap = osifp->os_if;
    wlan_cfg80211_scan_abort_internal(ic, vap->vdev_obj);
#endif
}

#if ATH_SUPPORT_WRAP
static inline
bool wlan_cfg80211_is_bypass_of_scan_needed(wlan_if_t vap)
{
    /**
     * Indicate SCAN_DONE directly for VAP's not able to scan
     */
    if (wlan_rptr_vdev_is_scan_allowed(vap->vdev_obj) == 0) {
        qdf_nofl_info("[ %s ]Bypass scan for proxysta", vap->iv_netdev_name);
        return true;
    }
    return false;
}
#else
static inline
bool wlan_cfg80211_is_bypass_of_scan_needed(wlan_if_t vap)
{
    return false;
}
#endif

int wlan_cfg80211_scan_validate_req(struct net_device *dev,
                                    struct ieee80211com *ic,
                                    wlan_if_t vap)
{
    /* scan is not applicable for wifiX/single wiphy interface */
    if (ic->ic_wdev.netdev == dev) {
         return -1;
    }

    if (!vap) {
        qdf_err("vap is null");
        return -EINVAL;
    }

    if (!vap->vdev_obj) {
        qdf_err("vdev is null");
        return -EINVAL;
    }

    /* If connection is in progress, do not start scan */
    if (ieee80211_vap_is_connecting(vap)) {
        scan_info("%s: vap: 0x%pK is connecting, return BUSY", __func__, vap);
        return -EBUSY;
    }

    return 0;
}

static
int wlan_cfg80211_scan_enh_sec_check(struct cfg80211_scan_request *request,
                                     struct ieee80211com *ic,
                                     osif_dev *osifp,
                                     struct wlan_objmgr_pdev *pdev,
                                     struct pdev_osif_priv *osif_priv,
                                     struct scan_params *params,
                                     struct wlan_objmgr_psoc *psoc,
                                     struct wlan_objmgr_vdev *vdev)

{
    QDF_STATUS status;
    uint8_t *ie_end = NULL;
    u_int32_t ielen = 0;
    u_int16_t total_ie_len = 0;
    int error;
    int is_ap_cac_timer_running = 0;
    ieee80211_frame_type ftype = IEEE80211_FRAME_TYPE_PROBEREQ;
    uint16_t i;
    wlan_if_t vap = osifp->os_if;

#if DBDC_REPEATER_SUPPORT
    /*Flush the scan entries to remove old beacons*/
#if REPEATER_SAME_SSID
    if (wlan_rptr_global_is_s_ssid()) {
        request->flags |= NL80211_SCAN_FLAG_FLUSH;
    }
#endif
#endif

    if (ic->no_chans_available
#if ATH_SUPPORT_DFS && QCA_DFS_NOL_VAP_RESTART
            || ic->ic_pause_stavap_scan
#endif
       ) {
        return -EBUSY;
    }


    IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD, IEEE80211_MSG_CFG80211, "%s \n",
            __func__);

#if ATH_SUPPORT_DFS
    if (ic->ic_scan_over_cac && ((vap->iv_opmode == IEEE80211_M_HOSTAP && mlme_dfs_is_ap_cac_timer_running(pdev))
#if ATH_SUPPORT_STA_DFS
        || mlme_is_stacac_running(vap)
#endif
        )) {
        ieee80211_bringdown_sta_vap(ic);
        ieee80211_bringdown_vaps(ic);
        if(wlan_pdev_wait_to_bringdown_vdevs(ic, ALL_VDEVS) == QDF_STATUS_SUCCESS) {
            ic->ic_is_cac_cancelled_by_scan = 1;
        }
    }
#endif

    ucfg_dfs_is_ap_cac_timer_running(pdev, &is_ap_cac_timer_running);
    if (is_ap_cac_timer_running) {
        return -EBUSY;
    }

    if (ic->ic_flags & IEEE80211_F_CHANSWITCH) {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD, IEEE80211_MSG_CFG80211,
                "%s CSA in progress. Discard scan\n", __func__);
#if ATH_SUPPORT_DFS
        if(ic->ic_scan_over_cac && ic->ic_is_cac_cancelled_by_scan) {
            osif_restore_vaps(ic, vap);
            ic->ic_is_cac_cancelled_by_scan = 0;
        }
#endif
        return -EBUSY;
    }

    status = wlan_objmgr_vdev_try_get_ref(vdev, WLAN_OSIF_ID);
    if (QDF_IS_STATUS_ERROR(status)) {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD, IEEE80211_MSG_CFG80211,
                "%s Couldnt get vdev ref, fail new scan\n", __func__);
        return -EINVAL;
    }

    /* Initialize driver specific scan config param */
    params->source = NL_SCAN;
    params->default_ie.len = 0;
    params->default_ie.ptr = NULL;

    total_ie_len = vap->iv_app_ie_list[ftype].total_ie_len;
    if (total_ie_len > 0) {
        params->vendor_ie.ptr = qdf_mem_malloc(total_ie_len);
        if(!params->vendor_ie.ptr) {
            wlan_objmgr_vdev_release_ref(vdev, WLAN_OSIF_ID);
            return -ENOMEM;
        }

        error = wlan_mlme_get_appie(vap, ftype, params->vendor_ie.ptr, &ielen,
                total_ie_len, DEFAULT_IDENTIFIER);
        if (error) {
            wlan_objmgr_vdev_release_ref(vdev, WLAN_OSIF_ID);
#if ATH_SUPPORT_DFS
            if(ic->ic_scan_over_cac && ic->ic_is_cac_cancelled_by_scan) {
                osif_restore_vaps(ic, vap);
                ic->ic_is_cac_cancelled_by_scan = 0;
            }
#endif
            if (params->vendor_ie.ptr)
                qdf_mem_free(params->vendor_ie.ptr);
            return -EINVAL;
        }

        params->vendor_ie.len = ielen;
    } else {
        params->vendor_ie.len = 0;
        params->vendor_ie.ptr = NULL;
    }

    params->half_rate = false;
    params->quarter_rate= false;
    params->strict_pscan = false;
    params->priority = SCAN_PRIORITY_HIGH;

    if (request->n_channels) {
        if (IEEE80211_IS_FLAG_HALF(ic->ic_chanbwflag))
            params->half_rate = true;
        else if (IEEE80211_IS_FLAG_QUARTER(ic->ic_chanbwflag))
            params->quarter_rate= true;
    }
    if (ic->ic_strict_pscan_enable) {
        params->strict_pscan = true;
    }

    /* Override the supplicant provided extended capability IE with the host
     * populated extended capability IE to advertise the user configuration in
     * the broadcast probe request frame if honor_supplicant_scan_ie config is
     * set to 0 in the global ini file. */

    if (!cfg_get(psoc, CFG_OL_HONOR_SUPPLICANT_SCAN_IE) && vap->iv_bss) {

        /* Copy the supplicant provided IEs except extended capability IE to
         * params->default_ie.ptr and set the request->ie_len to 0. So that the
         * wlan_cfg80211_scan() does not copy the supplicant provided IEs from
         * request->ie to the scan start WMI command.
         */
        params->default_ie.ptr = qdf_mem_malloc(
                request->ie_len + sizeof(struct ieee80211_ie_ext_cap));
        if (!params->default_ie.ptr) {
            wlan_objmgr_vdev_release_ref(vdev, WLAN_OSIF_ID);
            if (params->vendor_ie.ptr)
                qdf_mem_free(params->vendor_ie.ptr);
            return -EINVAL;
        }

        i =  0;
        if (request->ie_len) {
            while (i < request->ie_len) {
                if (request->ie[i] != WLAN_ELEMID_XCAPS) {
                    qdf_mem_copy(params->default_ie.ptr + params->default_ie.len,
                                 &request->ie[i],
                                 request->ie[i + 1] + sizeof(struct ie_header));
                    params->default_ie.len +=
                        request->ie[i + 1] + sizeof(struct ie_header);
                }

                /* Go to the next IE*/
                i += request->ie[i + 1] + sizeof(struct ie_header);
            }
            request->ie_len = 0;
        }

        ie_end = ieee80211_add_extcap(
                params->default_ie.ptr + params->default_ie.len, vap->iv_bss,
                IEEE80211_FC0_SUBTYPE_PROBE_REQ);
        params->default_ie.len += (uint32_t)(ie_end -
                (params->default_ie.ptr + params->default_ie.len));
    }

    if (request->duration) {
        params->dwell_time_active = params->dwell_time_active_2g =
            params->dwell_time_passive = params->dwell_time_active_6g =
                params->dwell_time_passive_6g = request->duration;
    }

    wlan_objmgr_vdev_release_ref(vdev, WLAN_OSIF_ID);

    return 0;
}

int wlan_cfg80211_get_scan_priv_objs(struct ieee80211com *ic,
                                     wlan_if_t vap,
                                     struct wlan_objmgr_pdev **pdev,
                                     struct pdev_osif_priv **osif_priv,
                                     struct wlan_objmgr_psoc **psoc,
                                     struct wlan_objmgr_vdev **vdev)
{
    *pdev = ic->ic_pdev_obj;
    if (!(*pdev)) {
        qdf_err("null pdev");
        return -1;
    }

    *osif_priv = wlan_pdev_get_ospriv(*pdev);
    if (!(*osif_priv)) {
        qdf_err("PDEV OS private structure is NULL");
        return -EINVAL;
    }

    *psoc = wlan_pdev_get_psoc(*pdev);
    if (!(*psoc)) {
        qdf_err("null psoc");
        return -1;
    }

    *vdev = vap->vdev_obj;
    if (!(*vdev)) {
        return -EINVAL;
    }

    return 0;
}

#ifdef WLAN_FEATURE_11BE_MLO
static bool wlan_is_ml_probe_request_scan(uint8_t *buf, qdf_size_t buf_len, uint8_t **mlie_seq, qdf_size_t *mlie_seq_len)
{
    uint8_t ml_ie_ext_id[] = {IEEE80211_ELEMID_EXT_MULTILINK};
    uint8_t *ml_prbreq_ie;
    qdf_size_t ml_prbreq_ie_len;
    uint16_t mlcontrol;
    bool ret = false;

    if (!buf || !buf_len) {
        mlo_debug("ML Probe: Scan request buffer is empty");
        goto exit;
    }

    if (!mlie_seq || !mlie_seq_len) {
        mlo_debug("ML Probe: Invalid ML IE buffer output pointers");
        goto exit;
    }

    *mlie_seq = NULL;
    *mlie_seq_len = 0;

    /* The request should have a Probe-variant ML IE */
    ml_prbreq_ie = (uint8_t *)wlan_get_ext_ie_ptr_from_ext_id(ml_ie_ext_id,
                                                              sizeof(ml_ie_ext_id),
                                                              buf, buf_len);
    if (!ml_prbreq_ie) {
        mlo_debug("ML Probe: No Multi-link element found");
        goto exit;
    }

    ml_prbreq_ie_len = ml_prbreq_ie[TAG_LEN_POS] + MIN_IE_LEN;
    if (ml_prbreq_ie_len > buf_len)
        goto exit;

    /* Min length: ML IE fixed field (5B) + Common info length (1B) */
    if (ml_prbreq_ie_len < (sizeof(struct wlan_ie_multilink) + WLAN_ML_PRV_CINFO_LENGTH_SIZE))
        goto exit;

    mlcontrol = le16toh((uint16_t)ml_prbreq_ie[MULTI_LINK_CTRL_1]);
    if (IEEE80211_GET_BITS(mlcontrol, WLAN_ML_CTRL_TYPE) == WLAN_ML_VARIANT_PROBEREQ) {
        *mlie_seq = ml_prbreq_ie;
        *mlie_seq_len = ml_prbreq_ie[TAG_LEN_POS] + MIN_IE_LEN;
        ret = true;
        goto exit;
    }
    mlo_debug("ML Probe: No Probe-variant Multi-link element found");

exit:
    return ret;
}

int wlan_ml_preq_fill_link_info_from_scan_entry(struct ieee80211vap* vap)
{
    struct ml_prbreq_connect_info *info;
    struct scan_filter *filter = NULL;
    struct scan_cache_node *scan_entry = NULL;
    struct ieee80211com *ic = vap->iv_ic;
    qdf_list_t *candidate_list = NULL;
    qdf_list_node_t *curr_node = NULL;
    int ret = -1;

    filter = qdf_mem_malloc(sizeof(*filter));
    if (!filter) {
        mlo_err("ML Probe: Failed to alloc scan filter");
        goto exit;
    }

    info = &vap->iv_ml_prbreq_info;
    filter->num_of_bssid = 1;
    qdf_mem_copy(&filter->bssid_list[0], info->bssid.bytes, QDF_MAC_ADDR_SIZE);

    candidate_list = wlan_scan_get_result(ic->ic_pdev_obj, filter);
    if (!candidate_list || !qdf_list_size(candidate_list)) {
        mlo_err("ML Probe: Failed to fetch BSSID scan entry");
        goto exit;
    }

    if (qdf_list_peek_front(candidate_list, &curr_node) != QDF_STATUS_SUCCESS) {
        mlo_err("ML Probe: Failed to peek front of the candidate list");
        goto exit;
    }

    scan_entry = qdf_container_of(curr_node, struct scan_cache_node, node);
    info->rssi_raw = scan_entry->entry->rssi_raw;
    qdf_mem_copy(&info->ml_info, &scan_entry->entry->ml_info, sizeof(struct ml_info));
    qdf_mem_copy(info->trans_bssid.bytes, scan_entry->entry->mbssid_info.trans_bssid,
                 QDF_MAC_ADDR_SIZE);
    ret = 0;

exit:
    if (candidate_list)
        wlan_scan_purge_results(candidate_list);
    qdf_mem_free(filter);
    return ret;
}

static QDF_STATUS
wlan_trigger_ml_probe_request_for_connect(struct wlan_objmgr_vdev *vdev,
                                          uint8_t *mlie_seq, qdf_size_t mlie_seq_len,
                                          struct cfg80211_scan_request *req)
{
#define ML_PREQ_EN_ALL 0x7
#define ML_PREQ_MLDID_POS 0x2
#define ML_PREQ_LINKIDS_POS 0x4

#define ML_PREQ_SUPPLICANT_BM_MLD_ID 0x0010
#define ML_PREQ_SUPPLICANT_COMP_PFL 0x0010
#define ML_PREQ_SUPPLICANT_LINK_ID_MASK 0xF
#define ML_PREQ_SUPPLICANT_CMN_INFO_LEN_POS 0
#define ML_PREQ_SUPPLICANT_MLD_ID_POS 1

    wlan_if_t vap = NULL;
    struct ieee80211_node *ni = NULL;
    struct ml_prbreq_connect_info *info = NULL;
    uint16_t mlcontrol = 0;
    uint8_t *buf = NULL, *bssid = NULL;
    uint8_t ap_mld_id = ML_PROBE_MLDID_INVALID;
    int i = 0;
    QDF_STATUS status = QDF_STATUS_E_INVAL;
    ieee80211_ssid ssid;
    uint32_t set_ml_prbreq_value, scan_freq;
    bool mld_id_present;
    int des_nssid, ret;

    if (!mlie_seq || !mlie_seq_len || !req)
        goto exit;

    mlcontrol = (uint16_t)mlie_seq[MULTI_LINK_CTRL_1];
    buf = mlie_seq + sizeof(struct wlan_ie_multilink);
    bssid = req->bssid;
    scan_freq = req->channels[0]->center_freq;

    if (!bssid || qdf_is_macaddr_zero((struct qdf_mac_addr *)bssid)) {
        mlo_err("ML Probe: BSSID cannot be null to send an ML probe request");
        goto exit;
    }

    vap = wlan_vdev_get_mlme_ext_obj(vdev);
    if (!vdev || !vap)
        goto exit;

    info = &vap->iv_ml_prbreq_info;
    set_ml_prbreq_value = ML_PREQ_EN_ALL;
    set_ml_prbreq_value |= ML_PREQ_LINKIDS_VALUE_MASK;

    mld_id_present = qdf_le16_to_cpu(mlcontrol) & ML_PREQ_SUPPLICANT_BM_MLD_ID;
    if ((mld_id_present && buf[ML_PREQ_SUPPLICANT_CMN_INFO_LEN_POS] != 2) ||
        (!mld_id_present && buf[ML_PREQ_SUPPLICANT_CMN_INFO_LEN_POS] != 1)) {
        mlo_err("ML Probe: Common info length is not matching with MLD ID presence");
        goto exit;
    }

    if (mld_id_present) {
        ap_mld_id = buf[ML_PREQ_SUPPLICANT_MLD_ID_POS];
        buf++;
    }
    /* Start of per-STA profiles */
    buf++;

    if (ap_mld_id == ML_PROBE_MLDID_INVALID)
        set_ml_prbreq_value &= ~((uint32_t)ML_PREQ_MLDID_POS);
    set_ml_prbreq_value |= ((uint32_t)ap_mld_id << 8);

    if (buf < (mlie_seq + mlie_seq_len)) {
        while (buf < (mlie_seq + mlie_seq_len)) {
            uint8_t *persta_prof = buf;
            uint16_t sta_control;
            uint8_t link_id;

            /* Sanity check to make sure Link info is framed properly */
            if (persta_prof[ID_POS] != WLAN_ML_LINFO_SUBELEMID_PERSTAPROFILE)
                break;

            sta_control = qdf_le16_to_cpu((uint16_t)persta_prof[STA_CTRL_1]);

            if (persta_prof[TAG_LEN_POS] > MIN_IE_LEN || !(sta_control & ML_PREQ_SUPPLICANT_COMP_PFL)) {
                /* STA profile is present but currently supplicant will not add
                 * it in the request
                 */
            }
            link_id = sta_control & ML_PREQ_SUPPLICANT_LINK_ID_MASK;
            /* CLear the slot before OR-ing with the shifetd link ID */
            set_ml_prbreq_value &= ~(0xF << (16 + (i * 4)));
            set_ml_prbreq_value |= ((uint32_t)link_id) << (16 + (i++ * 4));

            /* Advance to next per-STA profile */
            buf += buf[TAG_LEN_POS] + MIN_IE_LEN;
        }
    } else {
        set_ml_prbreq_value &= ~((uint32_t)ML_PREQ_LINKIDS_POS);
    }

    mlo_info("ML Probe: Request for ML probe on %4u MHz for links 0x%x from %s",
             scan_freq, set_ml_prbreq_value & ML_PREQ_LINKIDS_VALUE_MASK,
             ether_sprintf(bssid));

    qdf_mem_zero(&ssid, sizeof(ieee80211_ssid));
    ret = ieee80211_ucfg_get_essid(vap, &ssid, &des_nssid);
    if (ret) {
        mlo_err("ML Probe: Unable to get ESSID for STA VAP (%s) with ret=%d", ether_sprintf(vap->iv_myaddr), ret);
        goto exit;
    }

    /* Set vdev as MLO vdev for ML Probe request */
    wlan_vdev_mlme_set_mlo_vdev(vdev);

    info->cfg_scan_req = req;
    qdf_mem_copy(info->bssid.bytes, bssid, QDF_MAC_ADDR_SIZE);
    info->scan_freq = scan_freq;

    if (wlan_ml_preq_fill_link_info_from_scan_entry(vap)) {
        mlo_err("ML Probe: Failed to fill link_info from scan entry");
        goto exit;
    }

    ret = ieee80211_ucfg_setparam(vap, IEEE80211_PARAM_EHT_ML_PROBE_REQ, set_ml_prbreq_value, NULL);
    if (ret) {
        mlo_err("ML Probe: Setting EHT ML Probe Request failed (%d)", ret);
        goto exit;
    }

    ni = ieee80211_ref_bss_node(vap, WLAN_OSIF_SCAN_ID);
    if (!ni) {
        mlo_err("ML Probe: Failed to get ni reference");
        goto reset_ml_preq;
    }

    qdf_spin_lock_bh(&info->status_lock);
    info->send_req = 1;
    qdf_spin_unlock_bh(&info->status_lock);
    if (ieee80211_send_probereq(ni, vap->iv_myaddr, bssid, bssid, ssid.ssid, ssid.len, NULL, 0)) {
        mlo_err("ML Probe: Sending ML probe request failed");
        goto release_ni;
    }

    status = QDF_STATUS_SUCCESS;
    qdf_timer_start(&info->prbresp_update_time, vap->iv_ic->ic_ml_prbresp_update_time);

release_ni:
    ieee80211_free_node(ni, WLAN_OSIF_SCAN_ID);

reset_ml_preq:
    (void)ieee80211_ucfg_setparam(vap, IEEE80211_PARAM_EHT_ML_PROBE_REQ, 0, NULL);

exit:
    if (wlan_vdev_mlme_is_mlo_vdev(vdev))
        wlan_vdev_mlme_clear_mlo_vdev(vdev);

    if (QDF_IS_STATUS_ERROR(status) && vap && info) {
        qdf_spin_lock_bh(&info->status_lock);
        info->send_req = 0;
        qdf_spin_unlock_bh(&info->status_lock);
    }

#undef ML_PREQ_SUPPLICANT_BM_MLD_ID
#undef ML_PREQ_SUPPLICANT_COMP_PFL
#undef ML_PREQ_SUPPLICANT_LINK_ID_MASK
#undef ML_PREQ_SUPPLICANT_CMN_INFO_LEN_POS
#undef ML_PREQ_SUPPLICANT_MLD_ID_POS

#undef ML_PREQ_EN_ALL
#undef ML_PREQ_MLDID_POS
#undef ML_PREQ_LINKIDS_POS

    return status;
}
#endif /* WLAN_FEATURE_11BE_MLO */

static
int wlan_cfg80211_scan_start_internal(struct cfg80211_scan_request *request,
                                      struct ieee80211com *ic,
                                      osif_dev *osifp,
                                      struct wlan_objmgr_vdev *vdev,
                                      struct scan_params *params)
{
#ifdef WLAN_FEATURE_11BE_MLO
    uint8_t *mlie_seq = NULL;
    qdf_size_t mlie_seq_len = 0;
#endif /* WLAN_FEATURE_11BE_MLO */
    QDF_STATUS status;

    status = wlan_objmgr_vdev_try_get_ref(vdev, WLAN_OSIF_ID);
    if (QDF_IS_STATUS_ERROR(status)) {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD, IEEE80211_MSG_CFG80211,
                "%s Couldnt get vdev ref, fail new scan\n", __func__);
        return -EINVAL;
    }

    /* Update scanning bands configuration */
    ieee80211_cfg80211_update_scanband(osifp, params);

#ifdef WLAN_FEATURE_11BE_MLO
    /**
     * Trigger an ML Probe request for connect if required.
     * If no (probe request) ML IE found in scan request, driver can proceed
     * with usual scan.
     */
    if (wlan_is_ml_probe_request_scan(params->default_ie.ptr, params->default_ie.len,
                                      &mlie_seq, &mlie_seq_len)) {
        status = wlan_trigger_ml_probe_request_for_connect(vdev, mlie_seq, mlie_seq_len,
                                                           request);
    } else {
#endif /* WLAN_FEATURE_11BE_MLO */

#ifndef QCA_DYNAMIC_STA_VAP_SUPPORT
    status = wlan_cfg80211_scan(vdev, request, params);
#else
    status = wlan_cfg80211_scan(vdev, request, params,ic);
#endif

#ifdef WLAN_FEATURE_11BE_MLO
    }
#endif /* WLAN_FEATURE_11BE_MLO */

    wlan_objmgr_vdev_release_ref(vdev, WLAN_OSIF_ID);

    if (params->vendor_ie.ptr)
        qdf_mem_free(params->vendor_ie.ptr);

    if (params->default_ie.ptr)
        qdf_mem_free(params->default_ie.ptr);

    return status;
}

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
static inline void
wlan_cfg80211_cleanup_request_copy(struct osif_mldev *osifp_mldev, uint8_t link_id)
{
    int i, j;

    for (i = 0; i < link_id; i++) {
         if (osifp_mldev->request_copy[i]) {
             for (j = 0; j < osifp_mldev->request_copy[i]->n_channels; j++) {
                  qdf_mem_free(osifp_mldev->request_copy[i]->channels[j]);
                  osifp_mldev->request_copy[i]->channels[j] = NULL;
             }
              qdf_mem_free(osifp_mldev->request_copy[i]);
              osifp_mldev->request_copy[i] = NULL;
         }
    }
}
#endif

/**
 * wlan_cfg80211_scan_start- API to process cfg80211 scan request
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to net device
 * @request: Pointer to scan request
 *
 * This API responds to scan trigger and update cfg80211 scan database
 * later, scan dump command can be used to recieve scan results
 *
 * Return: 0 for success, non zero for failure
 */
int wlan_cfg80211_scan_start(struct wiphy *wiphy,
#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
        struct net_device *dev,
#endif
        struct cfg80211_scan_request *request)
{
    /*
     * As scan can be triggered internally , we need to add a
     * flag in scan object to know that trigger happend from
     * internal/wext/cfg80211, and if possible store request
     * in scan object itself
     */
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
    struct net_device *dev = request->wdev->netdev;
#endif
    struct cfg80211_context *cfg_ctx = NULL;
    struct ieee80211com *ic = NULL;
    osif_dev *osifp;
    wlan_if_t vap;
    struct wlan_objmgr_pdev *pdev;
    struct pdev_osif_priv *osif_priv = NULL;
    int status;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct osif_mldev *osifp_mldev;
    uint16_t i, j, k;
    struct cfg80211_scan_request *request_copy;
#endif
    struct wlan_objmgr_psoc *psoc;
    struct wlan_objmgr_vdev *vdev = NULL;
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    struct scan_params params = {0};
#else
    struct scan_params params[IEEE80211_MLD_MAX_NUM_LINKS] = {0};
#endif
#ifdef QCA_DYNAMIC_STA_VAP_SUPPORT
    int n_chan;
    bool found = 0;
#endif
    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    osifp_mldev = osif_mld_get_mldev(dev);
    if ((!cfg_ctx->is_mld_phy) ||
        (osifp_mldev->dev_type != OSIF_NETDEV_TYPE_MLO)) {
        osifp_mldev = NULL;
        osifp = get_vap_device_context(wiphy, dev, 0);
        if (!osifp) {
            qdf_err("osifp NULL");
            return -EINVAL;
        }

        vap = osifp->os_if;
        if (!vap) {
            qdf_err("VAP NULL");
            return -EINVAL;
        }

        ic = vap->iv_ic;

        status = wlan_cfg80211_scan_validate_req(dev, ic, vap);
        if (status < 0)
            return status;

        status = wlan_cfg80211_get_scan_priv_objs(ic, vap, &pdev, &osif_priv, &psoc, &vdev);
        if (status < 0)
            return status;

        if (wlan_cfg80211_is_bypass_of_scan_needed(vap)) {
            wlan_cfg80211_scan_done(dev, request, false, osif_priv);
            return QDF_STATUS_SUCCESS;
        }

        status = wlan_cfg80211_scan_enh_sec_check(request, ic, osifp, pdev,
                                                  osif_priv, &params[0],
                                                  psoc, vdev);
        if (status < 0) {
            return status;
        }
        status = wlan_cfg80211_scan_start_internal(request, ic,
                                                   osifp, vdev, &params[0]);
    } else {
        bool scan_triggered = false;

        /* store original scan request in mlddev to return same to cfg80211 once scan done */
        osifp_mldev->mld_scan_req = request;
        for (j = 0; j < IEEE80211_MLD_MAX_NUM_LINKS; j++) {
             qdf_freq_t low_2g, high_2g, low_5g, high_5g;

             osifp =  osifp_mldev->link_vifs[j];
             if (!osifp)
                 continue;

             vap = osifp->os_if;
             if (!vap) {
                 qdf_err("VAP NULL on link %d", j);
                 wlan_cfg80211_cleanup_request_copy(osifp_mldev, j);
                 return -EINVAL;
             }

             ic = vap->iv_ic;
             status = wlan_cfg80211_scan_validate_req(dev, ic, vap);
             if (status < 0) {
                 wlan_cfg80211_cleanup_request_copy(osifp_mldev, j);
                 return status;
             }

             status = wlan_cfg80211_get_scan_priv_objs(ic, vap, &pdev, &osif_priv, &psoc, &vdev);
             if (status < 0) {
                 wlan_cfg80211_cleanup_request_copy(osifp_mldev, j);
                 return status;
             }

             if (wlan_cfg80211_is_bypass_of_scan_needed(vap)) {
                 wlan_cfg80211_cleanup_request_copy(osifp_mldev, j);
                 wlan_cfg80211_scan_done(dev, request, false, osif_priv);
                 return QDF_STATUS_SUCCESS;
             }
             status = wlan_reg_get_freq_range(pdev, &low_2g, &high_2g, &low_5g, &high_5g);
             if (QDF_IS_STATUS_ERROR(status)) {
                 wlan_cfg80211_cleanup_request_copy(osifp_mldev, j);
                 qdf_err("failed to get freq range");
                 return -1;
             }

             if (osifp_mldev->request_copy[j]) {
                 qdf_err("previous scan on this link vap %p not done?", vap);
                 return -EBUSY;
             } else {
                 osifp_mldev->request_copy[j] =
                         qdf_mem_malloc(struct_size(osifp_mldev->request_copy[j],
                                        channels,
                                        request->n_channels));
                 if (!osifp_mldev->request_copy[j]) {
                     qdf_err("Failed to allocate request_copy[%d]", j);
                     wlan_cfg80211_cleanup_request_copy(osifp_mldev, j);
                     return -ENOMEM;
                 }
                 *osifp_mldev->request_copy[j] = *request;
                 request_copy = osifp_mldev->request_copy[j];
             }

             /* update the channel list and n_channels according to the vifs cap */
             request_copy->n_channels = 0;
             qdf_err("low_2g = %d high_2g = %d, low_5g = %d high_5g = %d", low_2g, high_2g, low_5g, high_5g);
             for (i = 0; i < request->n_channels; i++) {
                  if ((low_2g && high_2g) &&
                      (util_scan_scm_freq_to_band(request->channels[i]->center_freq) == WLAN_BAND_2_4_GHZ) &&
                      ((request->channels[i]->center_freq >= low_2g) &&
                       (request->channels[i]->center_freq <= high_2g))) {
                      request_copy->channels[request_copy->n_channels] = qdf_mem_malloc(sizeof(struct ieee80211_channel));
                      if (!request_copy->channels[request_copy->n_channels]) {
                          qdf_err("NULL request_copy->channels[%d]", i);
                          wlan_cfg80211_cleanup_request_copy(osifp_mldev, j);
                          qdf_mem_free(osifp_mldev->request_copy[j]);
                          return -ENOMEM;
                      }
                      *(request_copy->channels[request_copy->n_channels++]) = *(request->channels[i]);
                  }
                  if ((low_5g && high_5g) &&
                      (util_scan_scm_freq_to_band(request->channels[i]->center_freq) == WLAN_BAND_5_GHZ) &&
                      ((request->channels[i]->center_freq >= low_5g) &&
                       (request->channels[i]->center_freq <= high_5g))) {
                      request_copy->channels[request_copy->n_channels] = qdf_mem_malloc(sizeof(struct ieee80211_channel));
                      if (!request_copy->channels[request_copy->n_channels]) {
                          qdf_err("NULL request_copy->channels[%d]", i);
                          wlan_cfg80211_cleanup_request_copy(osifp_mldev, j);
                          qdf_mem_free(osifp_mldev->request_copy[j]);
                          return -ENOMEM;
                      }
                      *request_copy->channels[request_copy->n_channels++] = *(request->channels[i]);
                  } else {
                      qdf_debug("freq %d not belong to this vap %p", request->channels[i]->center_freq, vap);
                  }
             }

             if (!request_copy->n_channels) {
                 qdf_err("No channels requested to be scanned on vap %p link_id %d", vap, vap->link_id);
                 qdf_mem_free(osifp_mldev->request_copy[j]);
                 osifp_mldev->request_copy[j] = NULL;
                 continue;
             }

             status = wlan_cfg80211_scan_enh_sec_check(osifp_mldev->request_copy[j],
                                                       ic, osifp, pdev,
                                                       osif_priv, &params[j], psoc, vdev);
             if (status < 0) {
                 qdf_err("enhanced sanity check failed");
                 wlan_cfg80211_cleanup_request_copy(osifp_mldev, (j + 1));
                 return status;
             }
         }

         for (j = 0; j < IEEE80211_MLD_MAX_NUM_LINKS; j++) {
              if (!osifp_mldev->request_copy[j])
                 continue;

              osifp =  osifp_mldev->link_vifs[j];
              if (!osifp)
                  continue;

              vap = osifp->os_if;
              if (!vap) {
                  qdf_err("VAP NULL on link %d", j);
                  return -EINVAL;
              }

              ic = vap->iv_ic;
              status = wlan_cfg80211_get_scan_priv_objs(ic, vap, &pdev, &osif_priv, &psoc, &vdev);
              if (status < 0) {
                  qdf_err("failed to get privs");
                  return status;
              }

              status = wlan_cfg80211_scan_start_internal
                              (osifp_mldev->request_copy[j],
                               ic, osifp, vdev, &params[j]);
              if (status < 0) {
                  qdf_err("error happened during scan of link %d, free remaining requests", j);
                  for (i = j; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {
                       for (k = 0; k < osifp_mldev->request_copy[j]->n_channels; k++) {
                            qdf_mem_free(osifp_mldev->request_copy[j]->channels[k]);
                       }
                       qdf_mem_free(osifp_mldev->request_copy[j]);
                  }
                  /* should we abort the scan on already triggered link vifs */
                 return status;
              }
              /* atleast for 1 link, scan triggered, so mark it */
              scan_triggered = true;
         }

         if (!scan_triggered) {
             qdf_err("none of link's scan triggered");
             return -EINVAL;
         }
    }
#else
    osifp = get_vap_device_context(wiphy, dev, 0);
    vap = osifp->os_if;
    ic = cfg_ctx->ic;

#ifdef QCA_DYNAMIC_STA_VAP_SUPPORT
    /* Check if the frequency in which we are operating in
     * the corresponding AP vaps is a subset of this freq_list or not.
     * If its present then, scan only on that particular channel.
     * Else, reject this scan.
     */
    qdf_info("%s: vdev id:%d ic_curchan freq %hu n_channels:%d", vap->iv_netdev_name,\
         vap->iv_unit, ic->ic_curchan->ic_freq, request->n_channels);
    for(n_chan = 0; n_chan < request->n_channels; n_chan++){
        if (ic && (request->channels[n_chan]->center_freq == ic->ic_curchan->ic_freq) &&
            (ic->interference_type == CAP_DCS_NONE) && (!ic->cw_inter_found) &&
            (!atomic_read(&ic->dcs_chan_change.dcs_in_progress))) {
            found = true;
            break;
        }
    }
    if(!found){
        qdf_err("%s: vdev id:%d Scan rejected! curchan:%d ic->interference_type: %d",
            vap->iv_netdev_name, vap->iv_unit, ic->ic_curchan->ic_freq,
            ic->interference_type);
        return -EINVAL;
    }
#endif

    status = wlan_cfg80211_scan_validate_req(dev, ic, vap);
    if (status < 0)
        return status;

    status = wlan_cfg80211_get_scan_priv_objs(ic, vap, &pdev, &osif_priv, &psoc, &vdev);
    if (status < 0)
        return status;

    if (wlan_cfg80211_is_bypass_of_scan_needed(vap)) {
        wlan_cfg80211_scan_done(dev, request, false, osif_priv);
        return QDF_STATUS_SUCCESS;
    }

    status = wlan_cfg80211_scan_enh_sec_check(request, ic, osifp, pdev,
                                              osif_priv, &params,
                                              psoc, vdev);
    if (status < 0)
    {
        return status;
    }
#ifdef QCA_DYNAMIC_STA_VAP_SUPPORT
    else{
        /* Remove all the old scan entries in cfg80211 layer */
        cfg80211_bss_flush(wiphy);
    }
#endif
    status = wlan_cfg80211_scan_start_internal(request, ic, osifp,
                                               vdev, &params);
#endif
    return status;
}



int wlan_cfg80211_external_auth(struct wiphy *wiphy, struct net_device *dev,
                                 struct cfg80211_external_auth_params *params)
{
    osif_dev *osifp = get_vap_device_context_from_bssid(wiphy, dev,
                                                        params->bssid);
    wlan_if_t vap;

    if (!osifp) {
        qdf_err("%s: osifp NULL\n", __func__);
        return -EINVAL;
    }

    vap = osifp->os_if;

    if (!vap) {
        qdf_err("%s: vap is NULL", __func__);
        return -EINVAL;
    }

    qdf_timer_sync_cancel(&vap->iv_sta_external_auth_timer);
    qdf_info("external auth status %d", params->status);

    if (vap->iv_mlme_priv->im_request_type == MLME_REQ_AUTH) {
        vap->iv_mlme_priv->im_request_type = 0;
        IEEE80211_DELIVER_EVENT_MLME_AUTH_COMPLETE(vap, NULL, params->status);
    }
    return 0;
}

#ifdef WLAN_FEATURE_11BE_MLO
void wlan_set_desired_ssid_for_partner_links(wlan_if_t vap,
                                             ieee80211_ssid *ssidlist)
{
    wlan_if_t partner_vap;
    int i;
    struct wlan_mlo_dev_context *mlo_dev_ctx;
    struct wlan_objmgr_vdev *temp_vdev;

    mlo_dev_ctx = vap->vdev_obj->mlo_dev_ctx;
    if (!mlo_dev_ctx)
        return;

    for (i = 0; i < WLAN_UMAC_MLO_MAX_VDEVS; i++) {
         temp_vdev = mlo_dev_ctx->wlan_vdev_list[i];
         if (!temp_vdev)
             continue;

         partner_vap = wlan_vdev_get_mlme_ext_obj(temp_vdev);
         if (partner_vap && (partner_vap != vap))
             wlan_set_desired_ssidlist(partner_vap, 1, ssidlist);
         }
}
#endif

/**
 * wlan_cfg80211_connect() - cfg80211 connect api
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @req: Pointer to cfg80211 connect request
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_cfg80211_connect(struct wiphy *wiphy,
        struct net_device *ndev,
        struct cfg80211_connect_params *req)
{
    /* This API to be handled for single wiphy for getting netdev_priv and ic */
    struct ieee80211com *ic = NULL;
    enum ieee80211_opmode opmode;
    osif_dev *osifp = osif_get_mlsta_osif_dev(ndev, req);
    wlan_if_t vap;
    wlan_if_t tempvap = NULL;
    u_int8_t des_bssid[QDF_MAC_ADDR_SIZE] = {0};
    u_int8_t skip_bssid_set = 0;
    struct osif_connect_params conn_param = {0};
    int is_ap_cac_timer_running = 0;
    ieee80211_ssid   tmpssid;
    u_int8_t *ptr;
    uint8_t sae_pwe = SAE_PWE_UNSPECIFIED;
#if ATH_SUPPORT_WRAP
    struct ieee80211vap *tmp_vap = NULL;
#endif
    const uint8_t *old_bssid;
#if REPEATER_SAME_SSID
    uint8_t retv = 0;
#endif
    struct net_device *comdev;
    u_int8_t *rsn_ie = NULL, *pmkid = NULL;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    uint32_t freq;
#endif
#ifdef WLAN_FEATURE_11BE_MLO
    int i = 0;
    struct qdf_mac_addr *ap_mld_addr_ptr = NULL;
    struct qdf_mac_addr ap_mld_addr = {0};
    struct scan_cache_entry *scan_entry = NULL;
    struct ieee80211com *tmp_ic = NULL;
    wlan_if_t tvap = NULL;
    osif_dev *temp_osifp = NULL;
    struct wlan_ssid scan_ssid = {0};
#endif
#ifdef QCA_DYNAMIC_STA_VAP_SUPPORT
    int j, sta_vap_count = 0;
    struct ieee80211com *temp_ic = NULL;
    int desmode_set = 0;
    enum ieee80211_phymode common_desmode = IEEE80211_MODE_AUTO;
    wlan_if_t iter_vap = NULL;
#endif

   if (!osifp) {
       qdf_err("NULL osifp\n");
       return -EINVAL;
   }

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
   if (osifp->mldev) {
       /* cfg80211_connect_params has two field: channel_hint and channel.
        * Channel is populated directly from frequency in the kernel and
        * channel_hint is populated from frequency_hint in the kernel.
        *
        * If frequency is present, the channel field is updated. Else
        * channel_hint is updated based on frequency_hint.
        *
        * In 6.6 kernel, frequency is moved to per link_vifs basis and
        * thus is not present. So in this case, only frequency_hint is
        * populated due to which only channel_hint field would be accessible
        * and not channel field.
        */

       if (req->channel)
           freq = req->channel->center_freq;
       else if (req->channel_hint)
           freq = req->channel_hint->center_freq;

       vap = get_sta_link_vap_by_freq(osifp->mldev, freq);
   } else
#endif
   vap = osifp->os_if;

   if (!vap || !vap->vdev_obj) {
       qdf_err("%s: VAP/VDEV is NULL\n", __func__);
       return -EINVAL;
   }

   /* Link id not present in connect_params, for now leaving it as it is */
    ic = vap->iv_ic;

#ifdef QCA_DYNAMIC_STA_VAP_SUPPORT
    qdf_info("%s: vdev id:%d ic_curchan freq %hu", vap->iv_netdev_name,\
         vap->iv_unit, ic->ic_curchan->ic_freq);
    if ((ic->interference_type != CAP_DCS_NONE) || (ic->cw_inter_found) ||
        atomic_read(&ic->dcs_chan_change.dcs_in_progress)) {
        qdf_info("DCS interference in progress. Cannot proceed with STA connect %s: vdev id:%d",
            vap->iv_netdev_name, vap->iv_unit);
        return QDF_STATUS_E_FAILURE;
    }

    if (req->channel->center_freq != ic->ic_curchan->ic_freq) {
        qdf_info("%s: vdev id:%d connect req channel: %d, ic_curchan: %d",\
            vap->iv_netdev_name, vap->iv_unit, req->channel->center_freq, ic->ic_curchan->ic_freq);
        return QDF_STATUS_E_FAILURE;
     }

     if (ic->ic_global_list) {
         GLOBAL_IC_LOCK_BH(ic->ic_global_list);
         for (j = 0; j < MAX_RADIO_CNT; j++) {
            temp_ic = ic->ic_global_list->global_ic[j];
             if (temp_ic && temp_ic->ic_sta_vap) {
                 sta_vap_count++;
                 if (sta_vap_count > 1) {
                     GLOBAL_IC_UNLOCK_BH(ic->ic_global_list);
                     qdf_err("%s: vdev id:%d STA vap already exists in other band", \
                        temp_ic->ic_sta_vap->iv_netdev_name, temp_ic->ic_sta_vap->iv_unit);
                     return -EBUSY;
                     }
             }
         }
         GLOBAL_IC_UNLOCK_BH(ic->ic_global_list);
     }
 #endif /* QCA_DYNAMIC_STA_VAP_SUPPORT */

    opmode = wlan_vap_get_opmode(vap);

#ifdef QCA_DYNAMIC_STA_VAP_SUPPORT
    TAILQ_FOREACH(iter_vap, &ic->ic_vaps, iv_next) {
        /* Consider only valid VAP entries */
        if (!desmode_set) {
            common_desmode = iter_vap->iv_des_mode;
            desmode_set = 1;
        } else if (iter_vap->iv_des_mode != common_desmode) {
            qdf_err("Multiple VAPs with different desmode present in ic: vap %d mode %d vs mode %d",
                    iter_vap->iv_unit, iter_vap->iv_des_mode, common_desmode);
            return -EINVAL;
        }
    }
#endif

    if (osifp->is_delete_in_progress)
        return -EINVAL;

    /*Set essid, channel , bssid*/
    if (opmode == IEEE80211_M_WDS)
        return -EOPNOTSUPP;

#if ATH_SUPPORT_WRAP
    if (wlan_rptr_vdev_is_no_event(vap->vdev_obj) && ic->ic_sta_vap) {
        if (!wlan_is_connected(ic->ic_sta_vap)) {
            return -EBUSY;
        }
    }
#endif

    ucfg_dfs_is_ap_cac_timer_running(ic->ic_pdev_obj, &is_ap_cac_timer_running);
    if (is_ap_cac_timer_running) {
        return -EBUSY;
    }

    if (wlan_autoselect_in_progress(vap) && wlan_rptr_pdev_is_eir(ic->ic_pdev_obj)) {
        qdf_err("ACS in progress..return");
        return -EBUSY;
    }

    OS_MEMZERO(&tmpssid, sizeof(ieee80211_ssid));
    tmpssid.len = req->ssid_len;
    OS_MEMCPY(tmpssid.ssid, req->ssid, req->ssid_len);
    /*
     * Deduct a trailing \0 since iwconfig passes a string
     * length that includes this.  Unfortunately this means
     * that specifying a string with multiple trailing \0's
     * won't be handled correctly.  Not sure there's a good
     * solution; the API is botched (the length should be
     * exactly those bytes that are meaningful and not include
     * extraneous stuff).
     */
    if (req->ssid_len > 0 &&
            tmpssid.ssid[req->ssid_len-1] == '\0'){
        tmpssid.len--;
    }
    wlan_set_desired_ssidlist(vap,1,&tmpssid);
#ifdef WLAN_FEATURE_11BE_MLO
    wlan_set_desired_ssid_for_partner_links(vap, &tmpssid);
#endif

    old_bssid = req->bssid;
    if (req->bssid && !IS_NULL_ADDR(req->bssid)) {
        /*If AP mac to which our sta vap is trying to connect has
          same mac as one of our ap vaps ,dont set that as sta bssid */
        TAILQ_FOREACH(tempvap, &ic->ic_vaps, iv_next) {
            if (tempvap->iv_opmode == IEEE80211_M_HOSTAP && IEEE80211_ADDR_EQ(tempvap->iv_myaddr,req->bssid)) {
                qdf_print("[%s] Mac collision for [%s]",__func__,ether_sprintf(req->bssid));
                skip_bssid_set = 1;
                break;
            }
        }
        if (skip_bssid_set == 0) {
            IEEE80211_ADDR_COPY(des_bssid, req->bssid);
        }
    }
#if REPEATER_SAME_SSID
    if (wlan_rptr_global_is_s_ssid()) {
        retv = wlan_rptr_validate_stavap_bssid(vap->vdev_obj, des_bssid);
        if (retv != QDF_STATUS_SUCCESS) {
            return -EBUSY;
        }
    }
#endif
    req->bssid = des_bssid;
    if (!IS_NULL_ADDR(des_bssid))
        wlan_aplist_set_desired_bssidlist(vap, 1, &des_bssid);

    qdf_info("DES SSID SET=%s",req->ssid);
    qdf_info("DES BSSID SET=%s",ether_sprintf(req->bssid));

#ifdef WLAN_FEATURE_11BE_MLO
    scan_ssid.length = req->ssid_len;
    if (req->ssid && req->ssid_len)
        qdf_mem_copy(scan_ssid.ssid, req->ssid, req->ssid_len);

    scan_entry = ieee80211_get_scan_entry_by_ssid_and_bssid(
                                            vap->vdev_obj, scan_ssid,
                                            (struct qdf_mac_addr *)req->bssid);
    if (scan_entry) {
        ap_mld_addr_ptr = util_scan_entry_mldaddr(scan_entry);
        if (ap_mld_addr_ptr)
            qdf_mem_copy(ap_mld_addr.bytes, ap_mld_addr_ptr->bytes,
                         QDF_MAC_ADDR_SIZE);
        util_scan_free_cache_entry(scan_entry);
    }

    if (!IS_NULL_ADDR(ap_mld_addr.bytes)) {
        qdf_err("AP MLD mac is: %s", ether_sprintf(ap_mld_addr.bytes));
        if (!vap->iv_ic->ic_global_list) {
            qdf_err("Global IC list is NULL");
            return -EINVAL;
        }

        for (i = 0; i < MAX_RADIO_CNT; i++) {
             GLOBAL_IC_LOCK_BH(vap->iv_ic->ic_global_list);
             tmp_ic = vap->iv_ic->ic_global_list->global_ic[i];
             GLOBAL_IC_UNLOCK_BH(vap->iv_ic->ic_global_list);

             if (!tmp_ic)
                 continue;

             TAILQ_FOREACH_SAFE(tempvap, &tmp_ic->ic_vaps, iv_next, tvap) {
                 if (!tempvap || !tempvap->iv_ifp)
                     continue;

                 temp_osifp = (osif_dev *)tempvap->iv_ifp;
                 if (tempvap->iv_opmode == IEEE80211_M_HOSTAP &&
                     temp_osifp && (temp_osifp->mldev != NULL) &&
                     (temp_osifp->mldev->mld_dev != NULL) &&
                     (temp_osifp->mldev->mld_mac_addr != NULL) &&
                     IEEE80211_ADDR_EQ(temp_osifp->mldev->mld_mac_addr,
                                       ap_mld_addr.bytes)) {
                     qdf_err("AP MLD Mac collision for [%s] collided MLD is [%s]",
                             ether_sprintf(ap_mld_addr.bytes),
                             temp_osifp->mldev->mld_dev->name);
                     return -EINVAL;
                 }
             }
        }
    }
#endif /* WLAN_FEATURE_11BE_MLO */

    if(vap->vie_handle) {
         wlan_mlme_app_ie_delete_id(vap,IEEE80211_FRAME_TYPE_PROBEREQ,HOSTAPD_IE);
         wlan_mlme_app_ie_delete_id(vap,IEEE80211_FRAME_TYPE_ASSOCREQ,HOSTAPD_IE);
    }

    if (req->ie_len) {
        /* Calculate length excluding IEEE80211_ELEMID_XCAPS */
        int len = wlan_mlme_parse_appie(vap, IEEE80211_FRAME_TYPE_ASSOCREQ, (u_int8_t *)req->ie,req->ie_len);
        wlan_mlme_app_ie_set_check(vap, IEEE80211_FRAME_TYPE_PROBEREQ, (u_int8_t *)req->ie, len, HOSTAPD_IE);
        wlan_mlme_app_ie_set_check(vap, IEEE80211_FRAME_TYPE_ASSOCREQ, (u_int8_t *)req->ie, len, HOSTAPD_IE);

        vap->iv_is_6g_wps = 0;
        ptr = (u_int8_t *)req->ie;
        while (((ptr + 1) < req->ie +req->ie_len) && (ptr + ptr[1] + 1 < req->ie +req->ie_len)) {
            if (ptr[0] == WLAN_ELEMID_VENDOR && iswpsoui(ptr)) {
                vap->iv_is_6g_wps = 1;
            }
            if (ptr[0] == WLAN_ELEMID_RSN)
                rsn_ie = ptr;

            ptr += ptr[1] + 2;
        }
    }

    /*set privacy */
    wlan_set_param(vap,IEEE80211_FEATURE_PRIVACY,req->privacy);

    wlan_get_pmkid_from_rsn(vap, rsn_ie, &pmkid);
    if ((req->flags & CONNECT_REQ_EXTERNAL_AUTH_SUPPORT) && !vap->iv_roam.iv_roaming
        && !pmkid) {
        vap->iv_sta_external_auth_enabled = true;
    } else {
        qdf_mem_free(pmkid);
        vap->iv_sta_external_auth_enabled = false;
    }


#ifdef ATH_SUPPORT_NO_KERNEL_SAEPWE
    if (wlan_reg_is_6ghz_chan_freq(ic->ic_curchan->ic_freq)) {
        sae_pwe = wlan_cfg80211_fetch_sae_pwe_from_scan(vap, req);
    }
#else
    sae_pwe = req->crypto.sae_pwe;
#endif
    vap->iv_sae_pwe = sae_pwe;
    conn_param.sae_pwe = sae_pwe;

#if ATH_SUPPORT_WRAP
    if (wlan_rptr_vdev_is_mpsta(vap->vdev_obj)) {
        TAILQ_FOREACH(tmp_vap, &ic->ic_vaps, iv_next) {
            if (wlan_rptr_vdev_is_psta(tmp_vap->vdev_obj) &&
                !wlan_rptr_vdev_is_mpsta(tmp_vap->vdev_obj)) {
                /* Disconnect all PSTA before MPSTA connect */
                if (ieee80211_vap_is_connected(tmp_vap)) {
                    wlan_mlme_cm_stop(tmp_vap->vdev_obj, CM_SB_DISCONNECT,
                                      REASON_DISASSOC_DUE_TO_INACTIVITY, false);
                }
            }
        }
    }
#endif
    if (vap->iv_roam.iv_roaming) {
        wlan_vdev_get_bss_peer_mac(vap->vdev_obj, &conn_param.prev_bssid);
        osif_vap_roam(ndev, vap);
        osif_cm_connect(ndev, vap->vdev_obj, req, &conn_param);
    } else {
        osif_vap_pre_init(osifp, ndev, 0);
        if (osif_cm_connect(ndev, vap->vdev_obj, req, &conn_param)) {
            comdev = osifp->os_comdev;
            if (ndev->flags & IFF_RUNNING) {
                ndev->flags &= ~IFF_RUNNING;
                if (osif_get_num_active_vaps(ic) == 0 &&
                    comdev->flags & IFF_RUNNING) {
                    dev_close(comdev);
                }
            }
        }
    }
    /* Restore bssid */
    req->bssid = old_bssid;
    return 0 ;
}

/**
 * wlan_cfg80211_disconnect() - cfg80211 disconnect api
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @reason: Disconnect reason code
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_cfg80211_disconnect(struct wiphy *wiphy,
        struct net_device *dev, u16 reason)
{
    /* This API need to be relooked to know what netdev comes, how to get ic & netdev priv, link_id etc */
    struct ieee80211com *ic = NULL;
    int retval = 0;
    enum ieee80211_opmode opmode;
#if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
    struct ieee80211_node *ni = NULL;
#endif
    osif_dev *osifp = get_assoc_vap_device_context(wiphy, dev);
    wlan_if_t vap;

    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("%s: VAP is NULL\n", __func__);
        return -EINVAL;
    }

    opmode = wlan_vap_get_opmode(vap);
    ic = vap->iv_ic;
    if(opmode == IEEE80211_M_STA || opmode == IEEE80211_M_P2P_CLIENT) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s Received disconnect with reason %d %s\n", __func__, reason, ucfg_cm_reason_code_to_str(reason));

        if (vap->vie_handle) {
            wlan_mlme_wps_ie_delete(vap, IEEE80211_FRAME_TYPE_PROBEREQ, HOSTAPD_IE);
            wlan_mlme_wps_ie_delete(vap, IEEE80211_FRAME_TYPE_ASSOCREQ, HOSTAPD_IE);
        }
#if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
        if (mlo_is_mld_sta(vap->vdev_obj) &&
            QDF_IS_STATUS_SUCCESS(wlan_mlme_mlo_is_stacac_running(vap->vdev_obj))) {
            return -EINVAL;
        } else if (wlan_mlme_is_stacac_running(vap)) {
            IEEE80211_DPRINTF(vap, IEEE80211_MSG_MLME, "Do not stop the BSS STA CAC is on\n");
            return -EINVAL;
        } else {
            ni = ieee80211_try_ref_node(vap->iv_bss, WLAN_MLME_NB_ID);
            if (ni) {
                if (!ieee80211node_has_extflag(ni, IEEE80211_NODE_DISCONNECT)) {
                    wlan_mlme_disassoc_request_with_callback(
                                                   vap, ni->ni_macaddr,
                                                   IEEE80211_REASON_ASSOC_LEAVE,
                                                   NULL, NULL);
                }
                ieee80211node_set_extflag(ni, IEEE80211_NODE_DISCONNECT);
                ieee80211_free_node(ni, WLAN_MLME_NB_ID);
            }
            osif_vap_pre_stop(osifp);
            retval = osif_cm_disconnect_sync(vap->vdev_obj, REASON_STA_LEAVING);
        }
#else
        osif_vap_pre_stop(osifp);
        retval = osif_cm_disconnect_sync(vap->vdev_obj, REASON_STA_LEAVING);
#endif
    }

    return retval;
}

/**
 * wlan_cfg80211_set_wiphy_params - set wiphy parameters
 * @wiphy: Pointer to wiphy
 * @changed: Parameters changed
 * Return: 0 for success, non-zero for failure
 */
int wlan_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
{
    struct cfg80211_context *cfg_ctx = NULL;
    struct ieee80211com *ic = NULL;
    int value = 0, curval = 0, retval = 0;
    wlan_if_t vap = NULL , tvap = NULL;
    osif_dev *osifp = NULL;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    int i;
#endif

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    for (i = 0; i < NUM_MAX_RADIOS; i++) {
         ic = cfg_ctx->ic_list[i];
#else
         ic = cfg_ctx->ic;
#endif

         if (changed & WIPHY_PARAM_RTS_THRESHOLD) {
             value = (wiphy->rts_threshold == CFG80211_RTS_THRESHOLD_DISABLE) ?
                     IEEE80211_RTS_MAX : wiphy->rts_threshold;

             if ((value < IEEE80211_RTS_MIN) ||
                 (value > IEEE80211_RTS_MAX)) {
                 return -EINVAL;
             }

             /* RTS values are validated, apply parameter for all vaps */
             if (!TAILQ_EMPTY(&ic->ic_vaps)) {
                 TAILQ_FOREACH_SAFE(vap, &ic->ic_vaps, iv_next, tvap) {
                     curval = wlan_get_param(vap, IEEE80211_RTS_THRESHOLD);
                     if (value != curval) {
                         osifp = (osif_dev *)vap->iv_ifp;
                         wlan_set_param(vap, IEEE80211_RTS_THRESHOLD, value);
                         if (IS_UP(osifp->netdev) && (vap->iv_novap_reset == 0)) {
                             osif_vap_init(osifp, osifp->netdev, RESCAN);
                         }
                     }
                 }
             }
         }

         if(changed & WIPHY_PARAM_FRAG_THRESHOLD) {
            value = (wiphy->frag_threshold == CFG80211_FRAG_THRESHOLD_DISABLE) ?
                      IEEE80211_FRAGMT_THRESHOLD_MAX : wiphy->frag_threshold;

            if ((value < IEEE80211_FRAGMT_THRESHOLD_MIN) ||
                (value > IEEE80211_FRAGMT_THRESHOLD_MAX)) {
                 return -EINVAL;
            }

            if (!TAILQ_EMPTY(&ic->ic_vaps)) {

                TAILQ_FOREACH_SAFE(vap, &ic->ic_vaps, iv_next, tvap) {
                    if((wlan_get_desired_phymode(vap) != IEEE80211_MODE_AUTO) &&
                       (wlan_get_desired_phymode(vap) < IEEE80211_MODE_11NA_HT20))
                    {
                       curval = wlan_get_param(vap, IEEE80211_FRAG_THRESHOLD);
                       if (value != curval) {
                           osifp = (osif_dev *)vap->iv_ifp;
                           wlan_set_param(vap, IEEE80211_FRAG_THRESHOLD, value);
                           if (IS_UP(osifp->netdev)) {
                               osif_vap_init(osifp, osifp->netdev, RESCAN);
                           }
                       }
                    } else {
                       qdf_err("WARNING: Fragmentation with HT mode NOT ALLOWED!!");
                       retval = -EINVAL;
                    }
                }
            }
         }
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    }
#endif
    return retval;
}

/**
 * wlan_cfg80211_set_txpower - set TX power
 * @wiphy: Pointer to wiphy
 * @wdev: Pointer to network device
 * @type: TX power setting type
 * @dbm: TX power in dbm
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_cfg80211_set_txpower(struct wiphy *wiphy,
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
        struct wireless_dev *wdev,
#endif
        enum nl80211_tx_power_setting type,
        int dbm)
{
    /* We need link id here for link vap case. for now this will work for legacy vaps */
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
    if (wdev && wdev->netdev) {
       osifp = get_vap_device_context(wiphy, wdev->netdev, 0);
       if (!osifp) {
           qdf_err("NULL osifp\n");
           return -EINVAL;
       }
       vap = osifp->os_if;

       if (!vap) {
           qdf_err("%s: VAP is NULL\n", __func__);
           return -EINVAL;
       }

       if (type == NL80211_TX_POWER_FIXED){
          return ieee80211_ucfg_set_txpow(vap, dbm);
       }
    }
#endif
    return 0;
}

/**
 * wlan_cfg80211_get_txpower - cfg80211 get power handler function
 * @wiphy: Pointer to wiphy structure.
 * @wdev: Pointer to wireless_dev structure.
 * @dbm: dbm
 *
 * Return: 0 for success, error number on failure.
 */
int wlan_cfg80211_get_txpower(struct wiphy *wiphy,
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0) || defined(WITH_BACKPORTS)
        struct wireless_dev *wdev,
#endif
        int *dbm)
{
    /* Need kernel change to get the link id as power can't be same across link vifs
     * for now it will work on legacy vaps and link vap 0 */
    struct cfg80211_context *cfg_ctx = NULL;
    struct ieee80211com *ic = NULL;
    osif_dev *osifp;
    wlan_if_t vap;
    int fixed = 0;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

#if ENABLE_CFG80211_BACKPORTS_MLO
    qdf_debug("netdev name %s", wdev->netdev->name);
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
#else
    ic = cfg_ctx->ic;
#endif

    if (!ic) {
        qdf_debug("ic NULL");
        return -EINVAL;
    }

    if (ic->recovery_in_progress) {
#if defined(ENABLE_CFG80211_BACKPORTS_MLO) && defined(CFG80211_PER_LINK_TX_POWER)
        qdf_info("Recovery in progress for link id %d psoc id %d", link_id,
                 wlan_psoc_get_id(wlan_pdev_get_psoc(ic->ic_pdev_obj)));
#else
        qdf_info("Recovery in progress for psoc id %d",
                wlan_psoc_get_id(wlan_pdev_get_psoc(ic->ic_pdev_obj)));
#endif
        return -EINVAL;
    }

#ifdef QCA_SUPPORT_WDS_EXTENDED
    if (wlan_psoc_nif_feat_cap_get(wlan_pdev_get_psoc(ic->ic_pdev_obj),
        WLAN_SOC_F_WDS_EXTENDED) && (wdev->iftype == NL80211_IFTYPE_AP_VLAN))
        return 0;
#endif /* QCA_SUPPORT_WDS_EXTENDED */

#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
    if (wdev && wdev->netdev) {
        /* not valid for radio interface */
        if (ic->ic_wdev.netdev == wdev->netdev) {
            return -EINVAL;
        } else {
            osifp = get_vap_device_context(wiphy, wdev->netdev, 0);
            if (!osifp) {
                qdf_err("NULL osifp\n");
                return -EINVAL;
            }
            vap = osifp->os_if;
            if (!vap) {
                qdf_err("%s: VAP is NULL\n", __func__);
                return -EINVAL;
            }

            return ieee80211_ucfg_get_txpow(vap, dbm, &fixed);
        }
    }
#endif
   return 0;
}

/**
 * wlan_cfg80211_set_default_mgmt_key - set_default_mgmt_key
 * @wiphy: pointer to wiphy
 * @netdev: pointer to net_device structure
 * @link_id: link_id of vdev in MLO ctx
 * @key_index: key index
 *
 * Return: 0 on success, error number on failure
 */
#ifdef CFG80211_MLO_SINGLE_NETDEV_API
int wlan_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
        struct net_device *netdev, int link_id,
        u8 key_index)
#else
int wlan_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
        struct net_device *netdev,
        u8 key_index)
#endif
{
    wlan_if_t vap;
#if defined(CFG80211_MLO_SINGLE_NETDEV_API) && defined(ENABLE_CFG80211_BACKPORTS_MLO)
    osif_dev *osifp = get_vap_device_context(wiphy, netdev, link_id);
#else
    osif_dev *osifp = get_vap_device_context(wiphy, netdev, 0);
#endif

    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }

    vap = osifp->os_if;

    if (!vap) {
        qdf_err("%s: VAP is NULL\n", __func__);
        return -EINVAL;
    }

    wlan_set_default_keyid(vap,key_index);

    return 0;
}

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
int wlan_cfg80211_set_default_beacon_key(struct wiphy *wiphy,
        struct net_device *dev, int link_id, u8 key_idx)
#else
int wlan_cfg80211_set_default_beacon_key(struct wiphy *wiphy,
        struct net_device *dev, u8 key_idx)
#endif
{
    struct ieee80211com *ic;
    uint8_t enable_cfg80211_compliance;
#ifdef CFG80211_MLO_SINGLE_NETDEV_API
    ic = wlan_cfg80211_get_ic_ptr(wiphy, dev->ieee80211_ptr, link_id);
#else
    ic = wlan_cfg80211_get_ic_ptr(wiphy, dev->ieee80211_ptr, INVALID_LINK_ID);
#endif

    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    enable_cfg80211_compliance = ic->ic_cfg80211_compliance_mode;

    if (enable_cfg80211_compliance & CFG80211_SUPPORT_DEFAULT_BEACON_KEY) {
        wlan_if_t vap;
#if defined(CFG80211_MLO_SINGLE_NETDEV_API) && defined(ENABLE_CFG80211_BACKPORTS_MLO)
        osif_dev *osifp = get_vap_device_context(wiphy, dev, link_id);
#else
        osif_dev *osifp = get_vap_device_context(wiphy, dev, 0);
#endif

        if (!osifp) {
            qdf_err("NULL osifp\n");
            return -EINVAL;
        }

        vap = osifp->os_if;

        if (!vap) {
            qdf_err("%s: VAP is NULL\n", __func__);
            return -EINVAL;
        }

        wlan_set_default_keyid(vap,key_idx);
    }

    return 0;
}

static void wlan_fill_sta_flags(struct station_info *sinfo,
                                struct ieee80211_node *ni,
                                u_int32_t flag,
                                enum nl80211_sta_flags sta_flag)
{
    sinfo->sta_flags.mask |= BIT(sta_flag);
    if (ni->ni_flags & flag)
        sinfo->sta_flags.set |= BIT(sta_flag);
    else
        sinfo->sta_flags.set &= ~BIT(sta_flag);
}

/**
 * wlan_cfg80211_get_station() - get station statistics
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @mac: Pointer to mac
 * @sinfo: Pointer to station info
 *
 * Return: 0 for success, non-zero for failure
 */
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0))
int wlan_cfg80211_get_station(struct wiphy *wiphy,
        struct net_device *dev, const uint8_t *mac,
        struct station_info *sinfo)
#else
int wlan_cfg80211_get_station(struct wiphy *wiphy,
        struct net_device *dev, uint8_t *mac,
        struct station_info *sinfo)
#endif
{
    struct ieee80211com *ic = NULL;
    struct ieee80211_node *ni = NULL;
    struct ieee80211vap *vap;
    struct ieee80211req_sta_stats *stats_user;
    struct ieee80211_nodestats *pstats;
    struct nl80211_sta_flag_update *sfu;
    qdf_time_t curr_time, dur;
    bool rssi_valid = false;
    int i;
    osif_dev *osifp = NULL;
#ifdef WLAN_FEATURE_11BE_MLO
    struct wlan_mlo_dev_context *mld_dev = NULL;
    struct wlan_mlo_peer_context *ml_peer = NULL;
    struct wlan_objmgr_peer *assoc_peer = NULL;
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    osifp = get_vap_device_context(wiphy, dev, sinfo->assoc_link_id);
#else
    osifp = get_vap_device_context(wiphy, dev, 0);
#endif

    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("vap is null");
        return -EINVAL;
    }

    ic = vap->iv_ic;
    if (!ic) {
        qdf_err("ic is null");
        return -EINVAL;
    }

    ni = ieee80211_vap_find_node(vap, mac, WLAN_MLME_SB_ID);

    if (!ni) {
        qdf_err("ni is null");

#ifdef WLAN_FEATURE_11BE_MLO
        ml_peer = wlan_mlo_get_mlpeer_by_peer_mladdr((struct qdf_mac_addr *)mac, &mld_dev);
        if (!ml_peer || !mld_dev)
            return -ENOENT;

        assoc_peer = wlan_mlo_peer_get_assoc_peer(ml_peer);
        if (!assoc_peer)
            return -ENOENT;

        if (wlan_objmgr_peer_try_get_ref(assoc_peer, WLAN_MLME_SB_ID) == QDF_STATUS_SUCCESS) {
            ni = wlan_peer_get_mlme_ext_obj(assoc_peer);
            if (!ni) {
                qdf_err("ni is null");
                wlan_objmgr_peer_release_ref(assoc_peer, WLAN_MLME_SB_ID);
                return -ENOENT;
            }
        } else{
            qdf_err("Unable to take ref for peer:" QDF_MAC_ADDR_FMT, QDF_MAC_ADDR_REF(mac));
            return -ENOENT;
        }
    }
#else
        return -ENOENT;
    }
#endif

    stats_user = (struct ieee80211req_sta_stats *)qdf_mem_malloc(sizeof(struct ieee80211req_sta_stats));
    if (!stats_user) {
        qdf_err("Failed to allocate memory for sta stats");
        ieee80211_free_node(ni, WLAN_MLME_SB_ID);
        return -EINVAL;
    }

    qdf_mem_zero(stats_user, sizeof(struct ieee80211req_sta_stats));
    qdf_mem_copy(stats_user->is_u.macaddr, mac, QDF_MAC_ADDR_SIZE);
#ifdef QCA_SUPPORT_CP_STATS
    if(wlan_update_peer_cp_stats(ni, &stats_user->is_stats)) {
       ieee80211_free_node(ni, WLAN_MLME_SB_ID);
       qdf_mem_free(stats_user);
       return -EINVAL;
    }
#endif
#ifdef WLAN_FEATURE_11BE_MLO
    if (wlan_peer_is_mlo(ni->peer_obj)) {
        if (wlan_get_peer_dp_stats(ni->ni_ic, ni->peer_obj,
                                   &stats_user->is_stats, mac, true)) {
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);

            qdf_mem_free(stats_user);
            return -EINVAL;
        }
    } else
#endif
    {
        if (wlan_get_peer_dp_stats(ic, ni->peer_obj,
                                   &stats_user->is_stats, NULL, false)) {
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);
            qdf_mem_free(stats_user);
            return -EINVAL;
        }
    }
    pstats = &stats_user->is_stats;

    curr_time = qdf_system_ticks();
    dur = curr_time - ni->ni_assocuptime;
    sinfo->connected_time = qdf_system_ticks_to_msecs(dur) / 1000;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_CONNECTED_TIME);
    if (ni->ni_inact_reload > ni->ni_inact)
        sinfo->inactive_time = (ni->ni_inact_reload - ni->ni_inact) * 1000;
    else
        sinfo->inactive_time = 0;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME);

#if UMAC_SUPPORT_STA_STATS_ENHANCEMENT
    sinfo->rx_bytes = pstats->ns_rx_bytes;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);

    sinfo->tx_bytes = pstats->ns_tx_bytes;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
#endif

    sinfo->assoc_at = __qdf_system_ticks_to_nsecs(ni->ni_assocstarttime);
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ASSOC_AT_BOOTTIME);

    sinfo->signal = pstats->ns_rssi + ic->ic_get_cur_hw_nf(ic);
    sinfo->signal_avg = pstats->ns_avg_rssi + ic->ic_get_cur_hw_nf(ic);
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);
    sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL_AVG);

    for (i = 0; i < MAX_CHAINS; i++) {
        sinfo->chain_signal_avg[i] =  pstats->ns_rssi_chain[i] + ic->ic_get_cur_hw_nf(ic);
        sinfo->chains |= 1 << i;

        if (sinfo->chain_signal_avg[i])
            rssi_valid = true;
    }

    if (rssi_valid)
        sinfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG);

    sinfo->rx_packets = pstats->ns_rx_data;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);

    sinfo->tx_packets = pstats->ns_tx_data;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);

    sinfo->rxrate.legacy = pstats->ns_last_rx_rate;
    sinfo->filled |= BIT(NL80211_STA_INFO_RX_BITRATE);

    sinfo->txrate.legacy = pstats->ns_last_tx_rate;
    sinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);

    sinfo->rx_dropped_misc = pstats->ns_rx_dup;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DROP_MISC);

    sinfo->tx_retries = pstats->ns_retry_count;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);
    sinfo->tx_failed = pstats->ns_failed_retry_count;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);

    sinfo->bss_param.beacon_interval = ni->ni_intval;
    sinfo->bss_param.dtim_period = vap->vdev_mlme->proto.generic.dtim_period;
    if (ieee80211node_has_cap(ni, IEEE80211_CAPINFO_SHORT_PREAMBLE))
        sinfo->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE;
    if (ieee80211node_has_cap(ni, IEEE80211_CAPINFO_SHORT_SLOTTIME))
        sinfo->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME;
    if (ic->ic_protmode != IEEE80211_PROT_NONE)
        sinfo->bss_param.flags |= BSS_PARAM_FLAGS_CTS_PROT;
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_BSS_PARAM);

    wlan_fill_sta_flags(sinfo, ni, IEEE80211_NODE_AUTH, NL80211_STA_FLAG_AUTHORIZED);
    wlan_fill_sta_flags(sinfo, ni, IEEE80211_NODE_QOS, NL80211_STA_FLAG_WME);
    sinfo->sta_flags.mask |= BIT(NL80211_STA_FLAG_SHORT_PREAMBLE);
    if (ieee80211node_has_cap(ni, IEEE80211_CAPINFO_SHORT_PREAMBLE))
        sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_SHORT_PREAMBLE);
    else
        sinfo->sta_flags.set &= ~BIT(NL80211_STA_FLAG_SHORT_PREAMBLE);
    sinfo->filled |= BIT_ULL(NL80211_STA_INFO_STA_FLAGS);

    sfu = &sinfo->sta_flags;
    sfu->mask |= BIT(NL80211_STA_FLAG_AUTHENTICATED) |
                BIT(NL80211_STA_FLAG_ASSOCIATED);
    sfu->set |= BIT(NL80211_STA_FLAG_AUTHENTICATED);
    if (ni->ni_assocstatus == IEEE80211_STATUS_SUCCESS)
        sfu->set |= BIT(NL80211_STA_FLAG_ASSOCIATED);

    ieee80211_free_node(ni, WLAN_MLME_SB_ID);
    qdf_mem_free(stats_user);
    return 0;
}

/**
 * wlan_cfg80211_set_power_mgmt() - set cfg80211 power management config
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @mode: Driver mode
 * @timeout: Timeout value
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_cfg80211_set_power_mgmt(struct wiphy *wiphy,
        struct net_device *dev, bool mode,
        int timeout)
{
    return 0;
}


/**
 * wlan_regulatory_notifier: Regulatory callback
 * @wiphy: Pointer to wiphy
 * @request: Pointer to regulatory_request.
 *
 */
void wlan_regulatory_notifier(struct wiphy *wiphy, struct regulatory_request *request)
{

    struct ieee80211com *ic = NULL;
    struct cfg80211_context *cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
    uint16_t orig_cc;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    int i;
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    for (i = 0; i < NUM_MAX_RADIOS; i++) {
         if ((ic = cfg_ctx->ic_list[i]))
              break;
    }
#else
    if (is_mld_phy(wiphy)) {
        qdf_debug("Skip MLD wiphy");
        return;
    }

    ic = cfg_ctx->ic;
#endif

    if (!ic) {
        qdf_err("No valid IC in wiphy");
        return;
    }

    IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD, IEEE80211_MSG_CFG80211,"country: %c%c, initiator %d, dfs_region: %d",
            request->alpha2[0],
            request->alpha2[1],
            request->initiator,
            request->dfs_region);

    orig_cc = ieee80211_getCurrentCountry(ic);
    wlan_set_countrycode(ic, request->alpha2, orig_cc, CLIST_NEW_COUNTRY);
}

/**
 * wlan_cfg80211_configure_acl: Configure ACL policy and acl table.
 * @ic: pointer to ieee80211com.
 * @vap: pointer to vap.
 * @params: pointer to cfg80211_acl_data
 *
 * Return; 0 on success, error number otherwise
 */

int wlan_cfg80211_configure_acl(struct ieee80211com *ic, wlan_if_t vap,
        const struct cfg80211_acl_data *params)
{
    int i = 0;

    /* clear acl */
    if (params->n_acl_entries == 0) {
        /* disable acl and flush acl table */
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: clearing acl ... \n",
                __func__);
        wlan_set_acl_policy(vap, IEEE80211_MACCMD_POLICY_OPEN, IEEE80211_ACL_FLAG_ACL_LIST_1);
        wlan_set_acl_policy(vap, IEEE80211_MACCMD_FLUSH, IEEE80211_ACL_FLAG_ACL_LIST_1);
        return 0;
    }

    /* Replace existing list with new list */
    wlan_set_acl_policy(vap, IEEE80211_MACCMD_FLUSH, IEEE80211_ACL_FLAG_ACL_LIST_1);
    for (i = 0; i < params->n_acl_entries; i++) {
        wlan_set_acl_add(vap, params->mac_addrs[i].addr, IEEE80211_ACL_FLAG_ACL_LIST_1);
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: adding mac:%s \n",
                __func__, ether_sprintf(params->mac_addrs[i].addr));
    }
    /*
     * @NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED: Deny stations which are
     *      listed in ACL, i.e. allow all the stations which are not listed
     *      in ACL to authenticate.
     * @NL80211_ACL_POLICY_DENY_UNLESS_LISTED: Allow the stations which are listed
     *      in ACL, i.e. deny all the stations which are not listed in ACL.
     */

    /* set acl policy */
    if (params->acl_policy == NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED){
        wlan_set_acl_policy(vap, IEEE80211_MACCMD_POLICY_DENY, IEEE80211_ACL_FLAG_ACL_LIST_1);
    } else if (params->acl_policy == NL80211_ACL_POLICY_DENY_UNLESS_LISTED){
        wlan_set_acl_policy(vap, IEEE80211_MACCMD_POLICY_ALLOW, IEEE80211_ACL_FLAG_ACL_LIST_1);
    }
    return 0;
}

/**
 * wlan_cfg80211_set_mac_acl: apply ACL configuration.
 * @wiphy: pointer to wiphy structure
 * @dev: pointer to net_device
 * @params: pointer to cfg80211_acl_data
 *
 * Return; 0 on success, error number otherwise
 */
int wlan_cfg80211_set_mac_acl(struct wiphy *wiphy,
        struct net_device *dev,
        const struct cfg80211_acl_data *params)
{
    /* Need to get the link id for MLD case. Legacy vaps would work */
#if CONFIGURE_ACL_HOSTAPD
    /* Enable only when hostapd needs to manage ACL.
     * Currently this is in disabled state as ACL is
     * managed in the Driver.
     */
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;

    osifp = get_vap_device_context(wiphy, dev, 0);

    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }
    vap = osifp->os_if;

    if (!vap) {
        qdf_err("%s: VAP is NULL\n", __func__);
        return -EINVAL;
    }
    ic = vap->iv_ic;
    wlan_cfg80211_configure_acl(ic, vap, params);
#endif
    return 0;
}

/* FTM */
/**
 * wlan_cfg80211_testmode()
 * Receives UTF commands from FTM daemon
 * @wiphy: Pointer to wiphy
 * @wdev: Pointer to wireless device
 * @data: Data pointer
 * @len: Data length
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_cfg80211_testmode(struct wiphy *wiphy,
                           struct wireless_dev *wdev,
                           void *data, int len)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, 0);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        scn =  (struct ol_ath_softc_net80211 *)cmd;
    } else {
        QDF_TRACE(QDF_MODULE_ID_CONFIG, QDF_TRACE_LEVEL_ERROR, "Invalid vap Command !");
        return -EINVAL;
    }

    return ic->ic_ucfg_testmode_cmd(scn, ATH_FTM_UTF_CMD, (char*) data, len);
}

#if defined(WLAN_SUPPORT_FILS) && !defined(ATH_SUPPORT_DISABLE_FILSCRYPTO_OFFLOAD)
/*
 * wlan_cfg80211_set_fils_aad: Set FILS AAD data from Hostapd
 * @wiphy: pointer to wiphy structure
 * @dev: pointer to net_device
 * @fils_aad: pointer to cfg80211_fils_aad structure
 *
 * Return: 0 on Success, error number otherwise
 */
int wlan_cfg80211_set_fils_aad(struct wiphy *wiphy, struct net_device *dev,
                               struct cfg80211_fils_aad *fils_aad)
{
    osif_dev  *osifp = get_vap_device_context(wiphy, dev, 0);
    wlan_if_t vap;
    struct ieee80211req_fils_aad filsaad;
    uint8_t peer_mac[QDF_MAC_ADDR_SIZE] = {};

    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap || !fils_aad)
        return -EINVAL;

    if (!wlan_fils_is_enable(vap->vdev_obj)) {
        qdf_print("%s: FILS is Disable; Set FILS AAD failed", __func__);
        return -EINVAL;
    }
    qdf_mem_zero(&filsaad, sizeof(struct ieee80211req_fils_aad));
    qdf_mem_copy(filsaad.SNonce, fils_aad->snonce, IEEE80211_FILS_NONCE_LEN);
    qdf_mem_copy(filsaad.ANonce, fils_aad->anonce, IEEE80211_FILS_NONCE_LEN);
    qdf_mem_copy(filsaad.kek, fils_aad->kek, fils_aad->kek_len);
    filsaad.kek_len = fils_aad->kek_len;
    qdf_mem_copy(peer_mac, fils_aad->macaddr, QDF_MAC_ADDR_SIZE);

    if (QDF_STATUS_SUCCESS !=
        wlan_mlme_auth_fils(vap->vdev_obj, &filsaad, peer_mac)) {
        qdf_print("%s: FILS crypto registration failed", __func__);
    } else {
        qdf_print("%s: FILS crypto registered successfully", __func__);
    }

    /* Zero-out local FILS variable */
    qdf_mem_zero(&filsaad, sizeof(struct ieee80211req_fils_aad));
    return 0;
}
#endif /* defined(WLAN_SUPPORT_FILS) && !defined(ATH_SUPPORT_DISABLE_FILSCRYPTO_OFFLOAD) */

int wlan_cfg80211_remain_on_channel(struct wiphy *wiphy,
                                     struct wireless_dev *wdev,
                                     struct ieee80211_channel *chan,
                                     unsigned int duration,
                                     u64 *cookie)
{
    osif_dev *osifp = get_vap_device_context(wiphy, wdev->netdev, 0);
    struct ieee80211vap *vap;
    struct ieee80211com *ic;
    int ret = 0;
    struct ieee80211_offchan_req offchan_req;

    if(!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL vap\n");
        return -EINVAL;
    }

    ic = vap->iv_ic;

    if (chan->center_freq != 0 && chan->center_freq !=  ieee80211_chan2freq(ic,ic->ic_curchan)) {
        offchan_req.freq = chan->center_freq;
        offchan_req.dwell_time = duration;
        offchan_req.cookie = *cookie;
        offchan_req.request_type = IEEE80211_OFFCHAN_RX;
        ret = wlan_remain_on_channel(vap, &offchan_req, NULL);
    }

    return ret;
}

int wlan_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
                                            struct wireless_dev *wdev,
                                            u64 cookie)
{
    osif_dev *osifp = get_vap_device_context(wiphy, wdev->netdev, 0);
    struct ieee80211vap *vap;

    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }

    vap = osifp->os_if;

    if (!vap) {
        qdf_err("%s: VAP is NULL\n", __func__);
        return -EINVAL;
    }

    if(vap->iv_mgmt_offchan_current_req.cookie &&
        vap->iv_mgmt_offchan_current_req.freq)
        wlan_cancel_remain_on_channel(vap);

    return 0;
}

#if QCA_SUPPORT_SON
static int wlan_offchan_perframe_dwelltime(struct ieee80211_frame *wh,
                                           int dwell_time_req)
{
    int dwell_time = dwell_time_req;
    struct ieee80211_action *ia;
    uint8_t *type;

    ia = (struct ieee80211_action *)&wh[1];
    type = (uint8_t*)ia;
    if ((ia->ia_category == IEEE80211_ACTION_CAT_PUBLIC &&
         ia->ia_action == IEEE80211_ACTION_GAS_INITIAL_REQUEST)) {
        dwell_time = 6000;
    } else if (ia->ia_category == IEEE80211_ACTION_CAT_PUBLIC &&
            (get_dpp_frm_type((uint8_t *)&wh[1])
             == IEEE80211_ACTION_DPP_CONFIGURATION_RESULT)) {
        dwell_time = 50;
    }
    return dwell_time;
}
#endif

#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
static int wlan_cfg80211_trigger_remain_on_channel(struct ieee80211vap *vap,
                                                   uint32_t freq, wbuf_t wbuf)
{
    struct ieee80211_offchan_req offchan_req = {0};

    if (!freq) {
        qdf_err("freq is null");
        return -1;
    }

    offchan_req.freq = freq;
    offchan_req.dwell_time = 2000;
    offchan_req.cookie = 0;
    offchan_req.request_type = IEEE80211_OFFCHAN_RX;

    wifi_pos_debug("Call wlan_remain_on_channel, freq:%d", freq);
    return wlan_remain_on_channel(vap, &offchan_req, wbuf);
}

static int wlan_cfg80211_set_mac_addr_rx_filter(struct ieee80211vap *vap,
                                                uint32_t freq,
                                                uint8_t *filter_macaddr)
{
    struct set_rx_mac_filter rx_mac_filter = {0};
    struct ieee80211com *ic = vap->iv_ic;

    if (!ic->ic_set_mac_addr_rx_filter) {
        qdf_err("ic_set_mac_addr_rx_filter is null");
        return -1;
    }

    rx_mac_filter.vdev_id = wlan_vdev_get_id(vap->vdev_obj);
    /* filter_macaddr for MLO ISTA is MLD macaddr and for non-MLO ISTA is link
     * macaddr.
     */
    qdf_mem_copy(rx_mac_filter.mac, filter_macaddr, QDF_MAC_ADDR_SIZE);
    rx_mac_filter.freq = freq;
    rx_mac_filter.set = true;

    wifi_pos_debug("Call ic_set_mac_addr_rx_filter, freq:%d vdev_id:%d mac: " QDF_MAC_ADDR_FMT,
            rx_mac_filter.freq, rx_mac_filter.vdev_id, QDF_MAC_ADDR_REF(rx_mac_filter.mac));
    return ic->ic_set_mac_addr_rx_filter(ic->ic_pdev_obj, &rx_mac_filter);
}

static int wlan_cfg80211_send_roc_and_rx_filter_cmd(struct ieee80211vap *vap,
                                                    uint8_t *macaddr,
                                                    uint32_t freq,
                                                    uint8_t *filter_macaddr,
                                                    uint8_t *data,
                                                    uint32_t data_len,
                                                    int subtype)
{
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_objmgr_peer *peer = NULL;
    struct ieee80211_node *ni = NULL;
    int ret = -1;
    wbuf_t wbuf;

    psoc = wlan_vdev_get_psoc(vap->vdev_obj);
    if (!psoc) {
        qdf_err("null psoc");
        return ret;
    }

    peer = wlan_objmgr_get_peer_by_mac(psoc, macaddr, WLAN_WIFI_POS_CORE_ID);
    if (!peer) {
        qdf_err("PASN peer is not found");
        return ret;
    }

    /* For secured ranging, regular peer is created at AP responder.
     * Hence, allow to send PASN Auth frame.
     */
    if (wlan_peer_get_peer_type(peer) != WLAN_PEER_RTT_PASN) {
        qdf_debug("Not a PASN peer");
        ret = 0;
        goto exit;
    }

    ni = wlan_peer_get_mlme_ext_obj(peer);
    if (!ni) {
        qdf_err("ni is null");
        goto exit;
    }

    if (!ni->ni_rx_filter_sent) {
        ret = wlan_cfg80211_set_mac_addr_rx_filter(vap, freq, filter_macaddr);
        if (ret) {
            qdf_err("Failed to send rx filter command");
            goto exit;
        }
        ni->ni_rx_filter_sent = true;
    }

    /* For ISTA, send PASN auth frame using offchannel/ROC
     * if ISTA is not in connected state or the requested
     * channel is different from primary channel */
    if ((vap->rtt_enable == RTT_INITIATOR_MODE) ||
        (vap->current_rtt_role == RTT_INITIATOR_MODE)) {

	/*ISTA is in connected state in the same
         *channel as the Requested Channel, Use Regular
         *mgmt TX
         */
        if ((wlan_vdev_mlme_get_state(vap->vdev_obj) == WLAN_VDEV_S_UP) &&
            (freq == ieee80211_chan2freq(vap->iv_ic, vap->iv_ic->ic_curchan)))
            ret = wlan_send_mgmt(vap, macaddr, data, data_len);
        else {
            /* Send ROC and RX filter command only for the initiator */
            wbuf = wlan_setup_mgmt_frame(vap, macaddr, data, data_len, subtype);
            ret = wlan_cfg80211_trigger_remain_on_channel(vap, freq, wbuf);
        }

    } else {
        ret = wlan_send_mgmt(vap, macaddr, data, data_len);
    }

exit:
    wlan_objmgr_peer_release_ref(peer, WLAN_WIFI_POS_CORE_ID);
    return ret;
}
#else
static int wlan_cfg80211_trigger_remain_on_channel(struct ieee80211vap *vap,
                                                   uint32_t freq, wbuf_t wbuf)
{
    return 0;
}

static int wlan_cfg80211_set_mac_addr_rx_filter(struct ieee80211vap *vap,
                                                uint32_t freq,
                                                uint8_t *filter_macaddr)
{
    return 0;
}

static int wlan_cfg80211_send_roc_and_rx_filter_cmd(struct ieee80211vap *vap,
                                                    uint8_t *macaddr,
                                                    uint32_t freq,
                                                    uint8_t *filter_macaddr,
                                                    uint8_t *data,
                                                    uint32_t data_len,
                                                    int subtype)
{
    return 0;
}
#endif

#ifdef WLAN_FEATURE_11BE_MLO
void update_partner_link_assoc_rsp_buf_with_rsn(wlan_if_t vap, struct ieee80211_node *ni, struct ieee80211_app_ie_t optie)
{
   uint8_t *iebuf, *iebuf_end, *pmkid = NULL;
   struct wlan_objmgr_vdev *link_vdev;
   struct wlan_objmgr_peer *link_peer;
   struct wlan_mlo_peer_context *ml_peer = ni->peer_obj->mlo_peer_ctx;
   struct wlan_mlo_link_peer_entry *peer_entry;
   wlan_if_t partner_vap;
   uint8_t i, vdev_link_id, *assocbuf, *partner_rsn,  *frm;
   size_t assocbuf_len;
   wbuf_t wbuf;
   qdf_nbuf_t assocnbuf;
   int ret;

   iebuf = optie.ie;
   iebuf_end = iebuf + optie.length;
   while (iebuf + 1 < iebuf_end) {
       if (iebuf[0] != IEEE80211_ELEMID_RSN){
           iebuf += 2 + iebuf[1];
           continue;
       }

       wlan_get_pmkid_from_rsn(vap, iebuf, &pmkid);
       if (pmkid == NULL) {
           IEEE80211_DPRINTF(vap, IEEE80211_MSG_ASSOC, "No PMKID in RSNIE\n");
           break;
       }

       for (i = 0; i < MAX_MLO_LINK_PEERS; i++) {
            peer_entry = &ml_peer->peer_list[i];
            link_peer = peer_entry->link_peer;
            if (!link_peer) {
                continue;
            }

            if (!mlo_peer_is_assoc_peer(ml_peer, link_peer)) {
                link_vdev = wlan_peer_get_vdev(link_peer);
                if (!link_vdev) {
                    continue;
                }

                vdev_link_id = wlan_vdev_get_link_id(link_vdev);
                partner_vap = wlan_vdev_get_mlme_ext_obj(link_vdev);
                assocnbuf = mlo_peer_get_link_peer_assoc_resp_buf(ml_peer, vdev_link_id);
                if (assocnbuf && partner_vap) {
                    wbuf = wbuf_alloc(partner_vap->iv_ic->ic_osdev, WBUF_TX_MGMT, MAX_TX_RX_PACKET_SIZE);
                    if (!wbuf) {
                        IEEE80211_DPRINTF(vap, IEEE80211_MSG_ASSOC, "wbuf alloc failed");
                        break;
                    }

                    assocbuf = qdf_nbuf_data(assocnbuf);
                    assocbuf_len = qdf_nbuf_len(assocnbuf);

                    partner_rsn = qdf_mem_malloc(255);
                    if (partner_rsn == NULL) {
                        IEEE80211_DPRINTF(vap, IEEE80211_MSG_ASSOC, "Memory Allocation Failed");
                        break;
                    }
                    frm = partner_rsn;
                    ieee80211_add_or_retrieve_ie_from_app_opt_ies(partner_vap,
                            IEEE80211_FRAME_TYPE_PROBERESP, IEEE80211_ELEMID_RSN, -1, &frm,
                            TYPE_ALL_BUF, NULL, true);
                    ret = wlan_insert_pmkid_in_rsnie(partner_vap, &partner_rsn, pmkid);
                    if (ret) {
                        IEEE80211_DPRINTF(vap, IEEE80211_MSG_ASSOC, "Failed to insert PMKID");
                        qdf_mem_free(partner_rsn);
                        break;
                    }

                    frm = wbuf_header(wbuf);
                    qdf_mem_copy(frm, assocbuf, assocbuf_len);
                    qdf_mem_copy(frm+assocbuf_len, partner_rsn, 2 + partner_rsn[1]);
                    wbuf_set_pktlen(wbuf, assocbuf_len + 2 + partner_rsn[1]);

                    if (peer_entry->assoc_rsp_buf){
                        qdf_nbuf_free(peer_entry->assoc_rsp_buf);
                        peer_entry->assoc_rsp_buf = NULL;
                    }
                    peer_entry->assoc_rsp_buf = (qdf_nbuf_t)wbuf;
                    IEEE80211_DPRINTF(vap, IEEE80211_MSG_ASSOC,
                        "Added RSNIE in partner link vdev_id:%d\n", vdev_link_id);
                    qdf_mem_free(partner_rsn);
                }
            }
       }
       qdf_mem_free(pmkid);
       break;
   }
}
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
void ieee80211_mlo_tx_mgmt_translate_addr(struct ieee80211_node *ni, u8 *buf)
{
    struct ieee80211vap *vap;
    struct ieee80211_frame *wh;

    vap = ni->ni_vap;

    if (qdf_is_macaddr_zero(&vap->mld_mac_addr)) {
        qdf_err("mld_mac_addr is null\n");
        return;
    }

    if (!buf)
        return;

    wh = (struct ieee80211_frame *) buf;
    if (vap->iv_opmode == IEEE80211_M_HOSTAP) {

        if (ni == vap->iv_bss) {
            qdf_err("iv_bss is null\n");
            return;
        }

        qdf_mem_copy(wh->i_addr3, vap->iv_myaddr, QDF_MAC_ADDR_SIZE);
        qdf_mem_copy(wh->i_addr2, vap->iv_myaddr, QDF_MAC_ADDR_SIZE);
        qdf_mem_copy(wh->i_addr1, ni->ni_macaddr, QDF_MAC_ADDR_SIZE);
    } else if(vap->iv_opmode == IEEE80211_M_STA) {
        qdf_mem_copy(wh->i_addr3, ni->ni_macaddr, QDF_MAC_ADDR_SIZE);
        qdf_mem_copy(wh->i_addr2, vap->iv_myaddr, QDF_MAC_ADDR_SIZE);
        qdf_mem_copy(wh->i_addr1, ni->ni_macaddr, QDF_MAC_ADDR_SIZE);
    }

    return;
}

void ieee80211_mlo_sta_tx_mgmt_translate_addr(struct ieee80211vap *vap, u8 *buf)
{
    struct ieee80211_frame *wh;
    if (vap->iv_opmode != IEEE80211_M_STA)
        return;

    if (!buf) {
        qdf_err("buf is null");
        return;
    }

    if (!vap->iv_myaddr) {
        qdf_err("iv_myaddr is null\n");
        return;
    }

    if (qdf_is_macaddr_zero(&vap->mld_mac_addr)) {
        qdf_err("mld_mac_addr is null NO Translate Needed \n");
        return;
    }

    wh = (struct ieee80211_frame *) buf;

    if (wlan_vdev_mlme_is_mlo_vdev(vap->vdev_obj)) {
        qdf_mem_copy(wh->i_addr1, vap->sta_mld_assoc_bssid, QDF_MAC_ADDR_SIZE);
        qdf_mem_copy(wh->i_addr2, vap->vdev_obj->vdev_mlme.linkaddr, QDF_MAC_ADDR_SIZE);
        qdf_mem_copy(wh->i_addr3, vap->sta_mld_assoc_bssid, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_mem_copy(wh->i_addr2, vap->vdev_obj->vdev_mlme.linkaddr, QDF_MAC_ADDR_SIZE);
    }

}
#endif /* ENABLE_CFG80211_BACKPORTS_MLO */

/*
 * wlan_cfg80211_mgmt_tx: Transmit mgmt packet from hostapd.
 * @wiphy: pointer to wiphy structure
 * @dev: pointer to net_device
 * @params: pointer to cfg80211_mgmt_tx_params
 * @cookie : cookie information
 *
 * Return; 0 on success, error number otherwise
 */
int wlan_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
        struct cfg80211_mgmt_tx_params *params, u64 *cookie)
{

    osif_dev *osifp;
    wlan_if_t vap;
    u8 *buf;
    int rc = 0;
    const struct ieee80211_mgmt *mgmt;
    struct ieee80211req_mgmtbuf *mgmt_frm;
    int data_len=params->len;
    struct ieee80211_node *ni = NULL;
    int type = -1, subtype;
    bool send_tx_status = true;
#if QCA_SUPPORT_SON
    struct wlan_client_disconnect_ind event_data = {0};
    struct wlan_auth_reject_ind auth_reject_event_data = {0};
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_lmac_if_rx_ops *rx_ops = NULL;
#endif
    struct ieee80211_frame *wh;
#ifdef WLAN_FEATURE_11BE_MLO
    uint8_t *optie_buf;
#endif
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    uint32_t freq;
    struct osif_mldev *osifp_mldev;
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if (params->link_id >= 0 && params->link_id <= IEEE80211_MLD_MAX_NUM_LINKS)
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    else {
        osifp_mldev = osif_mld_get_mldev(wdev->netdev);
        if (osifp_mldev->dev_type == OSIF_NETDEV_TYPE_VAP) {
            /* This is observed when non-MLO vaps are configured with
             * ENABLE_CFG80211_BACKPORTS_MLO flag enabled
             */
            osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        } else if(osifp_mldev->dev_type == OSIF_NETDEV_TYPE_MLO) {
            /* This is observed when a SLO/MLO configured STA tries to
             * associate with a non-MLO AP vap
             */
            if (params->chan)
                freq = params->chan->center_freq;
            else {
                qdf_err("params->chan is null");
                return -EINVAL;
            }
            osifp = get_sta_osif_dev_by_freq(osifp_mldev, freq);
        } else
            return -EINVAL;
    }
#else
    osifp = get_vap_device_context(wiphy, wdev->netdev, 0);
#endif
    if (!osifp) {
        qdf_err("NULL osifp");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL VAP");
        return -EINVAL;
    }

    buf = (u8 *)qdf_mem_malloc(MAX_TX_RX_PACKET_SIZE - sizeof(struct ieee80211_qosframe));
    if(!buf) {
        return -ENOMEM;
    }

    mgmt = (const struct ieee80211_mgmt *) params->buf;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    ni = ieee80211_find_node_by_mld_mac(vap, (u8 *)mgmt->da, WLAN_MLME_SB_ID);
    if (ni && wlan_peer_is_mlo(ni->peer_obj)) {
        ieee80211_mlo_tx_mgmt_translate_addr(ni, params->buf);
        qdf_info("MLO: Translate MLD Addr to Link Addr for Tx-mgmt \n");
        ieee80211_free_node(ni, WLAN_MLME_SB_ID);
    } else if (vap->iv_opmode == IEEE80211_M_STA) {
        qdf_info("MLO: Translate MLD Addr to Link Addr for Tx-mgmt (no-peer) \n");
        ieee80211_mlo_sta_tx_mgmt_translate_addr(vap, params->buf);
        if (ni)
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);
    }
#endif

    /* buffer addr may have been translated, recast */
    mgmt = (const struct ieee80211_mgmt *) params->buf;
    mgmt_frm = (struct ieee80211req_mgmtbuf *) buf;
    memcpy(mgmt_frm->macaddr, (u8 *)mgmt->da, QDF_MAC_ADDR_SIZE);
    mgmt_frm->buflen = params->len;

    wh = (struct ieee80211_frame *)params->buf;
    if (&mgmt_frm->buf[0] + data_len > (buf + (MAX_TX_RX_PACKET_SIZE - sizeof(struct ieee80211_qosframe)))) {
        qdf_print("wlan_send_mgmt: Too long frame for "
                "wlan_send_mgmt (%u)", (unsigned int) params->len);
        qdf_mem_free(buf);
        return -1;
    }

    type = qdf_le16_to_cpu(mgmt->frame_control) & IEEE80211_FC0_TYPE_MASK;
    subtype = qdf_le16_to_cpu(mgmt->frame_control) & IEEE80211_FC0_SUBTYPE_MASK;

    if ((type == IEEE80211_FC0_TYPE_MGT) &&
        (subtype == IEEE80211_FC0_SUBTYPE_DEAUTH) &&
        (mgmt->u.deauth.reason_code == WLAN_REASON_DEAUTH_LEAVING) &&
        (QDF_IS_ADDR_BROADCAST(mgmt->da))) {
        qdf_nofl_info("Skip bcast de-auth reason code %d, handled in VDEV down",
                      mgmt->u.deauth.reason_code);
        qdf_mem_free(buf);
        return 0;
    }

    /*
     * In WPA3 when there is confirm mismatch send the
     * the challenge failure status code (15) to SON
     */

#if QCA_SUPPORT_SON
    if ((type == IEEE80211_FC0_TYPE_MGT) &&
        (subtype == IEEE80211_FC0_SUBTYPE_AUTH) && (mgmt->u.auth.auth_transaction==2 &&
	 mgmt->u.auth.auth_alg == IEEE80211_AUTH_ALG_SAE && mgmt->u.auth.status_code == STATUS_CHALLENGE_FAIL)) {
        if (mgmt_frm->macaddr != NULL) {
            ni = ieee80211_vap_find_node(vap, mgmt_frm->macaddr, WLAN_MLME_SB_ID);
        }
	if (!ni) {
	    qdf_err("ni is NULL");
	    return -EINVAL;
        }
	psoc = wlan_vdev_get_psoc(vap->vdev_obj);
	if (!psoc) {
            qdf_err("psoc is null");
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);
            return -EINVAL;
        }
	rx_ops = wlan_psoc_get_lmac_if_rxops(psoc);
        if (!rx_ops) {
            qdf_err("rx_ops is NULL");
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);
            return -EINVAL;
        }
	if (mgmt->u.auth.status_code != 0) {
	    qdf_mem_copy(auth_reject_event_data.client_addr, ni->ni_macaddr, QDF_MAC_ADDR_SIZE);
            auth_reject_event_data.reason = mgmt->u.auth.status_code;
            if (rx_ops && rx_ops->son_rx_ops.deliver_event) {
                rx_ops->son_rx_ops.deliver_event(vap->vdev_obj, ni->peer_obj, MLME_EVENT_TX_AUTH_FAIL, &auth_reject_event_data);
	    }
        }
	ni->ni_authstatus = mgmt->u.auth.status_code;
	ieee80211_free_node(ni, WLAN_MLME_SB_ID);
    }
#endif
    if ((type == IEEE80211_FC0_TYPE_MGT) &&
        ((subtype == IEEE80211_FC0_SUBTYPE_DISASSOC) ||
         (subtype == IEEE80211_FC0_SUBTYPE_DEAUTH))) {

        if (mgmt_frm->macaddr != NULL) {
            ni = ieee80211_vap_find_node(vap, mgmt_frm->macaddr, WLAN_MLME_SB_ID);
        }

        if (ni) {
#if QCA_SUPPORT_SON
             if (vap->iv_opmode == IEEE80211_M_HOSTAP && ni != vap->iv_bss) {
                    psoc = wlan_vdev_get_psoc(vap->vdev_obj);
                    if (!psoc) {
                        qdf_err("psoc is null");
                        ieee80211_free_node(ni, WLAN_MLME_SB_ID);
                        return -EINVAL;
                    }
                    rx_ops = wlan_psoc_get_lmac_if_rxops(psoc);
                    if (!rx_ops) {
                        qdf_err("rx_ops is NULL");
                        ieee80211_free_node(ni, WLAN_MLME_SB_ID);
                        return -EINVAL;
                    }
                    wlan_node_get_disassoc_stats(vap, ni->peer_obj, &event_data.sta_stats_event_data);
                    qdf_mem_copy(event_data.disconnect_event_data.client_addr, ni->ni_macaddr, QDF_MAC_ADDR_SIZE);
                    event_data.disconnect_event_data.source = BSTEER_SOURCE_LOCAL;
                    if (subtype == IEEE80211_FC0_SUBTYPE_DISASSOC) {
#ifndef QCA_SUPPORT_RDKB
#ifdef WLAN_FEATURE_11BE_MLO
                        IEEE80211_DELIVER_EVENT_MLME_DISASSOC_INDICATION(vap, ni->ni_macaddr,
                                       ni->ni_associd, IEEE80211_REASON_AUTH_EXPIRE | IEEE80211_REASON_NO_DEL_STA,
                                       &ni->peer_obj->mldaddr[0]);
#else
                        IEEE80211_DELIVER_EVENT_MLME_DISASSOC_INDICATION(vap, ni->ni_macaddr,
                                       ni->ni_associd, IEEE80211_REASON_AUTH_EXPIRE | IEEE80211_REASON_NO_DEL_STA, NULL);
#endif /*WLAN_FEATURE_11BE_MLO*/
#endif
                        event_data.disconnect_event_data.type = BSTEER_DISASSOC;
                        event_data.disconnect_event_data.reason = mgmt->u.disassoc.reason_code;
                    } else {
#ifndef QCA_SUPPORT_RDKB
#ifdef WLAN_FEATURE_11BE_MLO
                        IEEE80211_DELIVER_EVENT_MLME_DEAUTH_INDICATION(vap, ni->ni_macaddr,
                                       ni->ni_associd, IEEE80211_REASON_AUTH_LEAVE | IEEE80211_REASON_NO_DEL_STA,
                                       &ni->peer_obj->mldaddr[0]);
#else
                        IEEE80211_DELIVER_EVENT_MLME_DEAUTH_INDICATION(vap, ni->ni_macaddr,
                                       ni->ni_associd, IEEE80211_REASON_AUTH_LEAVE | IEEE80211_REASON_NO_DEL_STA, NULL);
#endif /*WLAN_FEATURE_11BE_MLO*/
#endif
                        event_data.disconnect_event_data.type = BSTEER_DEAUTH;
                        event_data.disconnect_event_data.reason = mgmt->u.deauth.reason_code;
                    }
                    if (rx_ops->son_rx_ops.deliver_event) {
                        rx_ops->son_rx_ops.deliver_event(vap->vdev_obj, ni->peer_obj, MLME_EVENT_CLIENT_DISCONNECTED, &event_data);
                    }
            }
#endif
            ni->ni_reason_code = mgmt->u.deauth.reason_code;
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);
        }
        send_tx_status = false;
    }

    if ((type == IEEE80211_FC0_TYPE_MGT) && ((subtype == IEEE80211_FC0_SUBTYPE_ASSOC_RESP) ||(subtype == IEEE80211_FC0_SUBTYPE_REASSOC_RESP))) {
        uint8_t elem_len, prev_elem_id = 0;
        uint8_t *ptr = (uint8_t *) mgmt->u.assoc_resp.variable ;
        uint16_t pos = 0 ;
        struct ieee80211_app_ie_t optie;
        IEEE80211_REASON_CODE reason;

        send_tx_status = false;
        data_len -= (char *) mgmt->u.assoc_resp.variable - (char *) mgmt;

        while (data_len >= 2) {
            elem_len = ptr[1];
            data_len -= 2;
            if (elem_len > data_len) {
                qdf_print("Invalid IEs elem_len=%d left=%d",
                    elem_len, data_len);
                break;
            }
            if (!is_hostie(ptr, IE_LEN(ptr), &prev_elem_id)) {
#ifdef WLAN_SUPPORT_FILS
                /* After FILS Indication element all IEs has to be encrypted. */
                if ((ptr[0] == WLAN_ELEMID_EXTN_ELEM) && (ptr[2] == WLAN_ELEMID_EXT_FILS_SESSION)) {
                    qdf_mem_copy(&mgmt_frm->buf[pos], ptr, data_len + 2);
                    pos += data_len + 2;
                    break;
                }
#endif /* WLAN_SUPPORT_FILS */
                qdf_mem_copy(&mgmt_frm->buf[pos], ptr, IE_LEN(ptr));
                pos += (elem_len + 2);
            }
            data_len -= elem_len;
            prev_elem_id = ptr[0];
            ptr += (elem_len + 2);
        }
        optie.ie = &mgmt_frm->buf[0];
        optie.length = pos;

        ni = ieee80211_vap_find_node(vap, mgmt_frm->macaddr, WLAN_MLME_SB_ID);

        reason = mgmt->u.assoc_resp.status_code;
        if (ni != NULL) {
            if (ieee80211_is_pmf_enabled(vap, ni)
                    && vap->iv_opmode == IEEE80211_M_HOSTAP
                    && (vap->iv_skip_pmf_reassoc_to_hostap > 0)
                    && ieee80211_node_is_authorized(ni)
                    && reason != IEEE80211_STATUS_REJECT_TEMP) {
                IEEE80211_DPRINTF(vap, IEEE80211_MSG_ASSOC,
                   "[%s] drop assoc resp for pmf client from hostapd\n",
                   __func__);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
                cfg80211_mgmt_tx_status(wdev, *cookie, params->buf, params->len, true, -1, GFP_ATOMIC);
#else
                cfg80211_mgmt_tx_status(wdev, *cookie, params->buf, params->len, true, GFP_ATOMIC);
#endif
            } else {
#ifdef WLAN_FEATURE_11BE_MLO
                if (wlan_peer_is_mlo(ni->peer_obj) && (!ni->peer_obj->mlo_peer_ctx ||
                    wlan_mlo_peer_is_disconnect_progress(ni->peer_obj->mlo_peer_ctx)
                               == QDF_STATUS_SUCCESS)) {
                    rc = -EINVAL;
                }
                else
#endif
                {
                    IEEE80211_NOTE(vap, IEEE80211_MSG_ASSOC, ni,
                        "[%s] (Re)Assoc Resp",__func__);
                   reason = mgmt->u.assoc_resp.status_code;
#ifdef WLAN_FEATURE_11BE_MLO
                   if (wlan_peer_is_mlo(ni->peer_obj) && !(ni->ni_ml_link_peer_created) &&
                       wlan_mlo_peer_is_assoc_done(ni->peer_obj->mlo_peer_ctx) &&
                      ((reason == IEEE80211_STATUS_SUCCESS) ||
                      (reason == IEEE80211_STATUS_ANTI_CLOGGING_TOKEN_REQ) ||
                      (reason == IEEE80211_STATUS_FINITE_CYCLIC_GROUP_NOT_SUPPORTED))) {

                      optie_buf = (u8 *)qdf_mem_malloc(optie.length);
                      if(!optie_buf) {
                          if (wlan_peer_is_mlo(ni->peer_obj)) {
                              wlan_mlo_partner_peer_disconnect_notify(ni->peer_obj);
                          }
                          IEEE80211_NODE_LEAVE(ni);
                          rc = -EINVAL;
                      }
                      else {
                          qdf_mem_copy(optie_buf, optie.ie, optie.length);
                          /* If IE buffer already present, free old one, allocate new one */
                          if (ni->ni_assoc_resp_optie.ie) {
                              qdf_err("freeing old opt IE, allocating new one ");
                              qdf_mem_free(ni->ni_assoc_resp_optie.ie);
                              ni->ni_assoc_resp_optie.ie = NULL;
                              ni->ni_assoc_resp_optie.length = 0;
                          }

                          ni->ni_assoc_resp_optie.length = optie.length;
                          ni->ni_assoc_resp_optie.ie = optie_buf;
                          ni->ni_ml_reassoc = (subtype == IEEE80211_FC0_SUBTYPE_ASSOC_RESP) ? 0:1;
                          ni->ni_ml_assoc_resp_reason = reason;
                          ni->ni_hostapd_asresp_trig = 1;
                      }
                   }
                   else
#endif
                   {
#ifdef WLAN_FEATURE_11BE_MLO
                      if (wlan_peer_is_mlo(ni->peer_obj) && subtype == IEEE80211_FC0_SUBTYPE_REASSOC_RESP &&
                          (ni->ni_authalg == IEEE80211_AUTH_ALG_FT)) {
                          update_partner_link_assoc_rsp_buf_with_rsn(vap, ni, optie);
                      }
#endif
                      rc = wlan_mlme_assoc_resp(vap, mgmt_frm->macaddr, reason,
                              ((subtype == IEEE80211_FC0_SUBTYPE_ASSOC_RESP) ? 0:1),
                              &optie);
                   }
                }
            }
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);
        } else if (wlan_vap_is_pmf_enabled(vap) && vap->iv_opmode == IEEE80211_M_HOSTAP && reason == IEEE80211_STATUS_REJECT_TEMP) {
           rc = wlan_mlme_assoc_resp(vap, mgmt_frm->macaddr, reason,
                           ((subtype == IEEE80211_FC0_SUBTYPE_ASSOC_RESP) ? 0:1),
                            &optie);
        } else {
            qdf_print("%s (Re)Assoc Resp failure, ni is NULL for macaddr:%s ",__func__,ether_sprintf(mgmt_frm->macaddr));
            rc = -EINVAL;
        }
        IEEE80211_NOTE(vap, IEEE80211_MSG_ASSOC_OPT,ni, "Received %sassoc resp from hostapd reason code=%d\n",(subtype == 0x30)? "re" : "",rc);
    } else if (params->offchan &&
              (type == IEEE80211_FC0_TYPE_MGT) &&
              (subtype == IEEE80211_FC0_SUBTYPE_ACTION)) {

        struct ieee80211_offchan_req offchan_req;

        offchan_req.freq       = params->chan->center_freq;
        offchan_req.dwell_time = params->wait;
        /* when large number of channels are provided, the completions are
           issued at end of the scan, there is a remote chance that the scan
           requester would timeout. Fixing the max dwell time 1.5 seconds */
        if (offchan_req.dwell_time >= vap->iv_ic->ic_offchan_dwell_time)
            offchan_req.dwell_time = vap->iv_ic->ic_offchan_dwell_time;

#if QCA_SUPPORT_SON
		if ((vap->iv_opmode == IEEE80211_M_STA) &&
		    (vap->iv_map_version >= 3))
		    offchan_req.dwell_time =
			wlan_offchan_perframe_dwelltime(wh, offchan_req.dwell_time);

        if ((offchan_req.dwell_time == 0) &&
                (isdppoui((uint8_t *)&wh[1])))
            offchan_req.dwell_time =
                wlan_offchan_perframe_dwelltime(wh, offchan_req.dwell_time);
#endif

        qdf_mem_copy(&offchan_req.cookie, cookie, sizeof(u64));
        offchan_req.request_type = IEEE80211_OFFCHAN_TX;

        /* if frame is added in offchan queue sucessfully, then don't send tx status in this function */
        if(wlan_offchan_mgmt_tx_start(vap, mgmt->da, mgmt->sa,
                                      mgmt->bssid, (params->buf+24),
                                      (params->len- 24), &offchan_req,
                                      type | subtype) == 0) {
            send_tx_status = false;
        }
    } else {
        memcpy(&mgmt_frm->buf[0],params->buf, params->len);

        if (IEEE80211_IS_PASN_AUTH(wh)) {
            rc = wlan_cfg80211_send_roc_and_rx_filter_cmd(vap,
                    mgmt_frm->macaddr, params->chan->center_freq,
                    wh->i_addr2, mgmt_frm->buf, mgmt_frm->buflen, IEEE80211_FC0_SUBTYPE_AUTH);
            if (rc) {
                qdf_mem_free(buf);
                return rc;
            }
        } else {
            rc = wlan_send_mgmt(vap, mgmt_frm->macaddr, mgmt_frm->buf, mgmt_frm->buflen);
        }
    }

    if(send_tx_status) {
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
        cfg80211_mgmt_tx_status(wdev, *cookie, params->buf, params->len, ((rc == QDF_STATUS_SUCCESS) ? true : false), -1, GFP_ATOMIC);
#else
        cfg80211_mgmt_tx_status(wdev, *cookie, params->buf, params->len, ((rc == QDF_STATUS_SUCCESS) ? true : false), GFP_ATOMIC);
#endif
    } else if(rc != QDF_STATUS_SUCCESS) {
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
        cfg80211_mgmt_tx_status(wdev, *cookie, params->buf, params->len, false, -1, GFP_ATOMIC);
#else
        cfg80211_mgmt_tx_status(wdev, *cookie, params->buf, params->len, false, GFP_ATOMIC);
#endif
    }
    qdf_mem_free(buf);
    return rc;
}

#define EASYMESH_VERSION_TWO 2
static void add_vlan_hdr(struct sk_buff *skb, struct ieee80211vap *vap)
{
    struct ieee80211_node *ni;
    struct ether_header *eh;

    if (!skb || !vap) {
        qdf_err("Invalid input. Unable to add VLAN hdr");
        return;
    }

    eh = (struct ether_header *)(skb->data);

    ni = ieee80211_find_node(vap->iv_ic, eh->ether_dhost, WLAN_MLME_SB_ID);
#define ETHERTYPE_VLAN_LEN 4
    if (ni && (ni->vlan_id > 0) && (htons(eh->ether_type) != ETH_P_8021Q)) {
        struct vlan_ethhdr *veh;
        veh = (struct vlan_ethhdr *)qdf_nbuf_push_head(skb, ETHERTYPE_VLAN_LEN);
        qdf_mem_move(skb->data, skb->data + ETHERTYPE_VLAN_LEN, 2 * QDF_MAC_ADDR_SIZE);
        skb->mac_header -= ETHERTYPE_VLAN_LEN;
        veh->h_vlan_proto = htons(ETH_P_8021Q);
        veh->h_vlan_TCI = htons(ni->vlan_id);
    }
    if (ni) {
        ieee80211_free_node(ni, WLAN_MLME_SB_ID);
    }
}

#ifdef QCA_SUPPORT_EAPOL_OVER_CONTROL_PORT
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
int wlan_cfg80211_tx_control_port(struct wiphy *wiphy, struct net_device *dev,
                            const u8 *buf, size_t len, const u8 *dest, const __be16 proto, const bool noencrypt, int link_id, u64 *cookie)
#else
int wlan_cfg80211_tx_control_port(struct wiphy *wiphy, struct net_device *dev,
                            const u8 *buf, size_t len, const u8 *dest, const __be16 proto, const bool noencrypt, u64 *cookie)
#endif
{
    osif_dev *osifp;
    wlan_if_t vap;
    struct ieee80211_node *ni;
    wbuf_t skb;
    qdf_nbuf_t nbuf_new = NULL;
    uint8_t eapol_type;
    uint32_t hdr_size = 0;
    int ret;
    const uint8_t *msdu_dst_addr, *msdu_src_addr;
    struct wlan_objmgr_vdev *primary_vdev = NULL;
    struct net_device *primary_net_dev;
    wlan_if_t primary_vap;
#ifdef WLAN_FEATURE_11BE_MLO
    osif_dev  *osifp_primary;
    struct wlan_mlo_dev_context *mlo_dev_ctx = NULL;
    bool is_force_central_pri = false;
    struct wlan_mlo_peer_context *ml_peer;
    uint8_t primary_link_id;
#endif
    struct ol_ath_softc_net80211 *scn = NULL;
#ifdef QCA_NSS_WIFI_OFFLOAD_SUPPORT
    uint32_t nss_soc_cfg;
#endif
    struct wireless_dev *wdev;
    bool pairwise;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(ENABLE_CFG80211_BACKPORTS)
    if (link_id >= 0 && link_id <= IEEE80211_MLD_MAX_NUM_LINKS)
        osifp = get_vap_device_context(wiphy, dev, link_id);
    else
        osifp = get_vap_device_context_no_linkid(wiphy, dev, dest);
#else
    osifp = get_vap_device_context(wiphy, dev, 0);
#endif

    if (!osifp) {
        qdf_err("Invalid osifp");
        return -EINVAL;
    }

    wdev = get_cfg80211_notification_wdev(osifp);

    if (!wdev) {
        qdf_err("Invalid wdev");
        return -EINVAL;
    }

    vap = osifp->os_if;

    if (!vap || !dev) {
        qdf_err("Invalid input");
        return -EINVAL;
    }

    if (vap->iv_ic->recovery_in_progress) {
	qdf_err("Firmware recovery in progress");
	return -EINVAL;
    }

    scn = OL_ATH_SOFTC_NET80211(vap->iv_ic);
    if (scn == NULL) {
        qdf_err("scn is NULL");
        return -EINVAL;
    }
    ni = ieee80211_find_node(vap->iv_ic, dest, WLAN_MLME_SB_ID);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(ENABLE_CFG80211_BACKPORTS)
    if (!ni) {
        ni = ieee80211_find_node_by_mld_mac(vap, dest, WLAN_MLME_SB_ID);
    }
#endif

    /*
       Reserving 16 bytes for cookie in headroom. In that initial 8 bytes used by NSS and
       last 8 bytes used to cookie updation for EAPL TX STATUS completion.
       Length of SKB DATA = DA length(6) + SA length(6) + [VLAN TAG Len(4)] + Ether Type(2)
                            + EAPOL DATA(len)
     */
    hdr_size = (ni && (ni->vlan_id > 0)) ?
               sizeof(struct ethhdr) + ETHERTYPE_VLAN_LEN :
               sizeof(struct ethhdr);
    skb = qdf_nbuf_alloc(NULL, len + hdr_size + COOKIE_LEN,
                         COOKIE_LEN + hdr_size, 4, FALSE);
    if (!skb) {
        qdf_info(" Insufficient memory to allocate buffer for SKB %s",__func__);
        if (ni)
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);
        return -EINVAL;
    }

    qdf_nbuf_set_pktlen(skb, len);
    OS_MEMCPY(qdf_nbuf_data(skb), buf, len);

    if (!qdf_nbuf_push_head(skb, sizeof(struct ethhdr))) {
        qdf_info(" Insufficient room in this buffer %s",__func__);
        qdf_nbuf_free(skb);
        if (ni)
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);
        return -ENOMEM;
    }

    /* Set default addresses and VAP for Tx */
    msdu_dst_addr = dest;
    msdu_src_addr = vap->iv_myaddr;

    primary_vap = vap;
    primary_net_dev = dev;

#ifdef WLAN_FEATURE_11BE_MLO
    /* Eapol handling for mlo sta */
    if (mlo_is_mld_sta(vap->vdev_obj)) {
        mlo_dev_ctx = vap->vdev_obj->mlo_dev_ctx;

        if (!mlo_dev_ctx || !(mlo_dev_ctx->bridge_sta_ctx)){
            qdf_err("mlo_dev_ctx or bridge_sta_ctx is null !!");
            if (ni)
                ieee80211_free_node(ni, WLAN_MLME_SB_ID);
            return -EINVAL;
        }
        /* Check if force_central_primary is set which indicates that we have
           a sta topology where assoc and primary umac are different and primary
           umac should be central and need EAPOL routing accordingly */
        is_force_central_pri = mlo_dev_ctx->bridge_sta_ctx->is_force_central_primary;
        if (is_force_central_pri) {
            /* Use the bridge link id for finding the primary vdev */
            primary_link_id = mlo_dev_ctx->bridge_sta_ctx->bridge_link_id;
            if (primary_link_id != WLAN_LINK_ID_INVALID) {
                    primary_vdev = mlo_get_vdev_by_link_id(vap->vdev_obj, primary_link_id,
                                                           WLAN_MLO_MGR_ID);
                    primary_vap = wlan_vdev_get_mlme_ext_obj(primary_vdev);
                    if (!primary_vdev || !primary_vap) {
                        /* Failed to get primary VAP, use original VAP */
                        primary_vap = vap;
                    }
                    else {
                        primary_net_dev = OSIF_TO_NETDEV(primary_vap->iv_ifp);
                        if (!primary_net_dev || !IS_UP(primary_net_dev)) {
                            /* Failed to get primary netdev, use original VAP and netdev */
                            primary_vap = vap;
                            primary_net_dev = dev;
                        }
                    }
            }
            msdu_dst_addr = dest;
            msdu_src_addr = primary_vap->iv_myaddr;
        } else if (ni) {
            primary_link_id = wlan_mlo_peer_get_primary_peer_link_id(ni->peer_obj);
            if (primary_link_id != WLAN_LINK_ID_INVALID) {
                primary_vdev = wlan_mlo_peer_get_primary_link_vdev(ni->peer_obj->mlo_peer_ctx);
                primary_vap = wlan_vdev_get_mlme_ext_obj(primary_vdev);
                if (!primary_vdev || !primary_vap) {
                    /* Failed to get primary VAP, use original VAP */
                    primary_vap = vap;
                } else {
                    primary_net_dev = OSIF_TO_NETDEV(primary_vap->iv_ifp);
                    if (!primary_net_dev || !IS_UP(primary_net_dev)) {
                        /* Failed to get primary netdev, use original VAP and netdev */
                        primary_vap = vap;
                        primary_net_dev = dev;
                    }
                }
            }
            msdu_dst_addr = dest;
            msdu_src_addr = primary_vap->iv_myaddr;
        } else {
            ml_peer = wlan_mlo_get_mlpeer(mlo_dev_ctx, (struct qdf_mac_addr *)dest);
            if (ml_peer) {
                primary_link_id = wlan_mlo_peer_get_primary_peer_link_id_by_ml_peer(ml_peer);
                if (primary_link_id != WLAN_LINK_ID_INVALID) {
                    primary_vdev = wlan_mlo_peer_get_primary_link_vdev(ml_peer);
                    primary_vap = wlan_vdev_get_mlme_ext_obj(primary_vdev);
                    if (!primary_vdev || !primary_vap) {
                        /* Failed to get primary VAP, use original VAP */
                        primary_vap = vap;
                    } else {
                        primary_net_dev = OSIF_TO_NETDEV(primary_vap->iv_ifp);
                        if (!primary_net_dev || !IS_UP(primary_net_dev)) {
                            /* Failed to get primary netdev, use original VAP and netdev */
                            primary_vap = vap;
                            primary_net_dev = dev;
                        }
                    }
                }
                msdu_dst_addr = dest;
                msdu_src_addr = primary_vap->iv_myaddr;
            }
        }

    }
    if (ieee80211_mlo_is_mld_ap(vap->vdev_obj) && ni &&
        wlan_peer_is_mlo(ni->peer_obj)) {
        primary_link_id = wlan_mlo_peer_get_primary_peer_link_id(ni->peer_obj);
        if (primary_link_id != WLAN_LINK_ID_INVALID) {
            primary_vdev = wlan_mlo_peer_get_primary_link_vdev(ni->peer_obj->mlo_peer_ctx);
            primary_vap = wlan_vdev_get_mlme_ext_obj(primary_vdev);
            if (!primary_vdev || !primary_vap
                || wlan_vdev_mlme_op_flags_get(primary_vdev, WLAN_VDEV_OP_MLO_LINK_REMOVAL_IN_PROGRESS)) {
                /* Failed to get primary VAP, use original VAP */
                primary_vap = vap;
            } else if (primary_vap && primary_vap->iv_ifp) {
                primary_net_dev = OSIF_TO_NETDEV(primary_vap->iv_ifp);
                if (IEEE80211_IS_MLO_BRIDGE_VAP(primary_vap)) {
                    osifp_primary = (osif_dev *)primary_vap->iv_ifp;
                    if (osifp_primary && osifp_primary->netdev) {
                        primary_net_dev = osifp_primary->netdev;
                    } else if (osifp_primary && osifp_primary->mldev &&
                        osifp_primary->mldev->mld_dev) {
                        primary_net_dev = osifp_primary->mldev->mld_dev;
                    }
                }

                if (!primary_net_dev || !IS_UP(primary_net_dev)) {
                    /* Failed to get primary netdev, use original VAP and netdev */
                    primary_vap = vap;
                    primary_net_dev = dev;
                }
            }
        }
        msdu_dst_addr = ni->peer_obj->mldaddr;
        msdu_src_addr = wlan_vdev_mlme_get_mldaddr(vap->vdev_obj);
    }
#endif

    OS_MEMCPY(qdf_nbuf_data(skb) + QDF_MAC_ADDR_SIZE, msdu_src_addr, QDF_MAC_ADDR_SIZE);
    OS_MEMCPY(qdf_nbuf_data(skb), msdu_dst_addr, QDF_MAC_ADDR_SIZE);
    OS_MEMCPY(qdf_nbuf_data(skb) + (QDF_MAC_ADDR_SIZE * 2), &proto, 2);

    *cookie = ++vap->iv_eapol_cookie;
    OS_MEMCPY(qdf_nbuf_head(skb) + 8, cookie, 8);

    eapol_type = qdf_nbuf_get_eapol_subtype(skb);

    if (eapol_type == QDF_PROTO_EAPOL_M1)
        vap->iv_m1_packet_cnt++;
    else if (eapol_type == QDF_PROTO_EAPOL_M2)
        vap->iv_m2_packet_cnt++;
    else if (eapol_type == QDF_PROTO_EAPOL_M3)
        vap->iv_m3_packet_cnt++;
    else if (eapol_type == QDF_PROTO_EAPOL_M4)
        vap->iv_m4_packet_cnt++;
    else if (eapol_type == QDF_PROTO_EAPOL_G1)
        vap->iv_g1_packet_cnt++;
    else if (eapol_type == QDF_PROTO_EAPOL_G2)
        vap->iv_g2_packet_cnt++;

    pairwise = (eapol_type == QDF_PROTO_EAPOL_G1 || eapol_type == QDF_PROTO_EAPOL_G2)? 0:1;
    if (primary_vap->iv_map_version >= EASYMESH_VERSION_TWO)
        add_vlan_hdr(skb, primary_vap);

    nbuf_new = qdf_nbuf_copy(skb);

    if (!nbuf_new) {
        qdf_info(" Insufficient memory to create private copy of nbuf %s",__func__);
        qdf_nbuf_free(skb);
        if (ni)
            ieee80211_free_node(ni, WLAN_MLME_SB_ID);

        if (primary_vdev)
            wlan_objmgr_vdev_release_ref(primary_vdev, WLAN_MLO_MGR_ID);

        return -ENOMEM;
    }
    nbuf_debug_del_record(skb);
    skb->dev = primary_net_dev;
    skb->protocol = QDF_NBUF_TRAC_EAPOL_ETH_TYPE;

    if (primary_vap->select_tx_queue)
        ret = dev_direct_xmit(skb,
                              primary_vap->select_tx_queue(primary_net_dev,
                                                           skb, NULL));
    else {
        qdf_info("%s TX queue unregistered",__func__);
        ret = dev_queue_xmit(skb);
    }

#ifdef QCA_NSS_WIFI_OFFLOAD_SUPPORT
    nss_soc_cfg = cfg_get(scn->soc->psoc_obj, CFG_NSS_WIFI_OL);
    if (nss_soc_cfg) {
        cfg80211_control_port_tx_status(wdev, *cookie,
                                        qdf_nbuf_data(nbuf_new), nbuf_new->len,
                                        (ret == 0)? true:false, GFP_ATOMIC);
    }
#endif /* QCA_NSS_WIFI_OFFLOAD_SUPPORT */
    qdf_nbuf_free(nbuf_new);

    if (ni)
        ieee80211_free_node(ni, WLAN_MLME_SB_ID);

    if (primary_vdev)
        wlan_objmgr_vdev_release_ref(primary_vdev, WLAN_MLO_MGR_ID);

    eapol_type = (eapol_type == QDF_PROTO_EAPOL_G1) ?
                 1 : ((eapol_type == QDF_PROTO_EAPOL_G2) ? 2 : eapol_type);

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s EAPOL %s%d to :%s %s\n", __func__,
                     pairwise ? "M":"G", eapol_type, ether_sprintf(dest), ret ? "Failed":"");
    return 0;
}
#endif

/*
 * wlan_cfg80211_set_antenna: Set tx and rx chainmask
 * @wiphy: pointer to wiphy structure
 * @tx_ant: tx chainmask value
 * @rx_ant: rx chainmask value
 *
 * Return; 0 on success, error number otherwise
 */
int wlan_cfg80211_set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
{
    struct cfg80211_context *cfg_ctx = NULL;
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;

    int retval = 0,txparam = 0,rxparam = 0;
    bool fail_status = false;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    int i;
#endif

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    for (i = 0; i < NUM_MAX_RADIOS; i++) {
         ic = cfg_ctx->ic_list[i];
         if (!ic)
             continue;
#else
         ic = cfg_ctx->ic;
         if (!ic)
             return -1;
#endif

         txparam = (OL_ATH_PARAM_SHIFT | OL_ATH_PARAM_TXCHAINMASK);
         rxparam = (OL_ATH_PARAM_SHIFT | OL_ATH_PARAM_RXCHAINMASK);

         scn = OL_ATH_SOFTC_NET80211(ic);

         retval =  ic->ic_cfg80211_radio_handler.setparam((void*)scn, txparam, tx_ant, NULL);
         if (retval) {
             qdf_info("Failed to set tx antenna");
             fail_status = true;
         }

         retval =  ic->ic_cfg80211_radio_handler.setparam((void*)scn, rxparam, rx_ant, NULL);
         if (retval) {
             qdf_info("Failed to set rx antenna");
             fail_status = true;
         }
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    }
#endif

    return (fail_status)? 1: 0;
}

/*
 * wlan_cfg80211_get_antenna: Get tx and rx chainmask
 * @wiphy: pointer to wiphy structure
 * @tx_ant: tx chainmask value
 * @rx_ant: rx chainmask value
 *
 * Return; 0 on success, error number otherwise
 */
int wlan_cfg80211_get_antenna(struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant)
{
    struct cfg80211_context *cfg_ctx = NULL;
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int retval = 0, txparam = 0, rxparam = 0;
    bool fail_status = false;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    int i;
#endif

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    for (i = 0; i < NUM_MAX_RADIOS; i++) {
         ic = cfg_ctx->ic_list[i];
         if (!ic)
             continue;
#else
         ic = cfg_ctx->ic;
         if (!ic)
             return -1;
#endif

         txparam = (OL_ATH_PARAM_SHIFT | OL_ATH_PARAM_TXCHAINMASK);
         rxparam = (OL_ATH_PARAM_SHIFT | OL_ATH_PARAM_RXCHAINMASK);

         scn = OL_ATH_SOFTC_NET80211(ic);

         retval =  ic->ic_cfg80211_radio_handler.getparam((void*)scn, txparam, tx_ant);
         if (retval) {
             qdf_info("Failed to get tx antenna");
             fail_status = true;
         }

         retval =  ic->ic_cfg80211_radio_handler.getparam((void*)scn, rxparam, rx_ant);
         if (retval) {
             qdf_info("Failed to get rx antenna");
             fail_status = true;
         }
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    }
#endif

    return (fail_status)? 1 : 0;
}

/**
 * wlan_cfg80211_mgmt_tx_cancel_wait: Transmit mgmt packet from hostapd.
 * @wiphy: pointer to wiphy structure
 * @dev: pointer to net_device
 * @cookie : cookie information
 *
 * Return; 0 on success, error number otherwise
 */
int wlan_cfg80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,
        struct wireless_dev *wdev, u64 cookie)
{
    struct ieee80211com *ic;
    struct ieee80211vap *vap;
    uint8_t enable_cfg80211_compliance;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, INVALID_LINK_ID);

    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    enable_cfg80211_compliance = ic->ic_cfg80211_compliance_mode;

    if (enable_cfg80211_compliance & CFG80211_SUPPORT_MGMT_TX_CANCEL_WAIT) {
        osif_dev *osifp = get_vap_device_context(wiphy, wdev->netdev, INVALID_LINK_ID);

        if (!osifp) {
            qdf_err("NULL osifp\n");
            return -EINVAL;
        }

        vap = osifp->os_if;

        if (!vap) {
            qdf_err("VAP is NULL\n");
            return -EINVAL;
        }

       if(vap->iv_mgmt_offchan_current_req.cookie &&
          vap->iv_mgmt_offchan_current_req.freq &&
          vap->iv_mgmt_offchan_current_req.cookie == cookie)
           wlan_cancel_remain_on_channel(vap);
    }

    return 0;
}

/**
 * cfg80211_get_ac_internal: convert nl80211 AC to internal AC
 * @ac: Access category
 *
 * Return; 0 on success, error number otherwise
 */
int cfg80211_get_ac_internal(enum nl80211_ac ac)
{
    int ac_internal = WME_AC_BE;
    switch(ac)
    {
        case NL80211_AC_BK:
            ac_internal = WME_AC_BK;
            break;
        case NL80211_AC_BE:
            ac_internal = WME_AC_BE;
            break;
        case NL80211_AC_VI:
            ac_internal = WME_AC_VI;
            break;
        case NL80211_AC_VO:
            ac_internal = WME_AC_VO;
            break;
        default:
            ac_internal = WME_AC_BE;
            break;
    }
    return ac_internal;
}

/**
 * wlan_configure_all_wmm_params: configure all WMM params
 * @vaphandle: pointer to VAP.
 * @mode: Phymode.
 * @param: WME param type.
 * @ac: access category.
 * @val: WME param value.
 * Return; 0 on success, error number otherwise
 */
int wlan_configure_all_wmm_params(wlan_if_t vaphandle,
                                  enum ieee80211_phymode mode,
                                  enum nl80211_ac ac,
                                  struct ieee80211_txq_params *param)
{
    struct ieee80211vap *vap = vaphandle;
    struct ieee80211com *ic = vap->iv_ic;
    struct ieee80211_wme_state *ic_wme = &ic->ic_wme;
    struct ieee80211_wme_state *wme = &vap->iv_wmestate;

    wme->wme_chanParams.cap_wmeParams[ac].wmep_acm
        = ic_wme->wme_wmeChanParams.cap_wmeParams[ac].wmep_acm;
    wme->wme_chanParams.cap_wmeParams[ac].wmep_aifsn
        = param->aifs;
    wme->wme_chanParams.cap_wmeParams[ac].wmep_logcwmin
        = ilog2(param->cwmin + 1);
    wme->wme_chanParams.cap_wmeParams[ac].wmep_logcwmax
        = ilog2(param->cwmax + 1);
    wme->wme_chanParams.cap_wmeParams[ac].wmep_txopLimit
        = param->txop;
    wme->wme_bssChanParams.cap_wmeParams[ac].wmep_acm
        = ic_wme->wme_wmeBssChanParams.cap_wmeParams[ac].wmep_acm;
    wme->wme_bssChanParams.cap_wmeParams[ac].wmep_aifsn
        = param->aifs;
    wme->wme_bssChanParams.cap_wmeParams[ac].wmep_logcwmin
        = ilog2(param->cwmin + 1);
    wme->wme_bssChanParams.cap_wmeParams[ac].wmep_logcwmax
        = ilog2(param->cwmax + 1);
    wme->wme_bssChanParams.cap_wmeParams[ac].wmep_txopLimit
        = param->txop;

    ieee80211_vap_wme_param_update(ic, vap);
    ic_wme->wme_flags |= WME_F_BSSPARAM_UPDATED;
    if (wlan_vdev_mlme_is_mlo_ap(vap->vdev_obj)) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_CU,
                "%s: set cu cat2 flag for vdev id:%d "
                "change in param:%d ac:%d",
                __func__, vap->iv_unit, param, ac);
        wlan_vdev_mlme_op_flags_set(vap->vdev_obj, WLAN_VDEV_OP_CU_CAT2);
    }

    QDF_TRACE(QDF_MODULE_ID_WME, QDF_TRACE_LEVEL_DEBUG,
              "received params: ac [%u], txop [%hu], cwmin [%hu], cwmax [%hu], aifs [%hu]",
               param->ac, param->txop, param->cwmin, param->cwmax, param->aifs);

    return 0;
}


/**
 * wlan_configure_wmm_params: configure WMM params
 * @vaphandle: pointer to VAP.
 * @mode: Phymode.
 * @param: WME param type.
 * @ac: access category.
 * @val: WME param value.
 * Return; 0 on success, error number otherwise
 */
int wlan_configure_wmm_params(wlan_if_t vaphandle, enum ieee80211_phymode mode,
        wlan_wme_param param, u_int8_t ac, u_int32_t val)
{
    struct ieee80211vap *vap = vaphandle;
    struct ieee80211com *ic = vap->iv_ic;
    struct ieee80211_wme_state *wme = &ic->ic_wme;

    switch (param)
    {
        case WLAN_WME_CWMIN:
            wme->wme_wmeChanParams.cap_wmeParams[ac].wmep_logcwmin = val;
            wme->wme_chanParams.cap_wmeParams[ac].wmep_logcwmin = val;
            ic->phyParamForAC[ac][mode].logcwmin = val;
            break;
        case WLAN_WME_CWMAX:
            wme->wme_wmeChanParams.cap_wmeParams[ac].wmep_logcwmax = val;
            wme->wme_chanParams.cap_wmeParams[ac].wmep_logcwmax = val;
            ic->phyParamForAC[ac][mode].logcwmax = val;
            break;
        case WLAN_WME_AIFS:
            wme->wme_wmeChanParams.cap_wmeParams[ac].wmep_aifsn = val;
            wme->wme_chanParams.cap_wmeParams[ac].wmep_aifsn = val;
            ic->phyParamForAC[ac][mode].aifsn = val;
            break;
        case WLAN_WME_TXOPLIMIT:
            wme->wme_wmeChanParams.cap_wmeParams[ac].wmep_txopLimit = val;
            wme->wme_chanParams.cap_wmeParams[ac].wmep_txopLimit = val;
            ic->phyParamForAC[ac][mode].txopLimit = val;
            break;
        default:
            break;
    }

    return 0;
}

/**
 * wlan_cfg80211_set_txq_params: set txq params.
 * @wiphy: pointer to wiphy structure
 * @dev: pointer to net_device
 * @params: pointer to ieee80211_txq_params
 *
 * Return; 0 on success, error number otherwise
 */
int wlan_cfg80211_set_txq_params(struct wiphy *wiphy,
        struct net_device *dev,
        struct ieee80211_txq_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int ac_internal = 0;
    enum ieee80211_phymode mode;

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    osifp = get_vap_device_context(wiphy, dev, params->link_id);
#else
    osifp = get_vap_device_context(wiphy, dev, 0);
#endif

    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }
    vap = osifp->os_if;

    if (!vap || !vap->iv_ic) {
        qdf_err("NULL vap/ic\n");
        return -EINVAL;
    }

    ic = vap->iv_ic;

    if (!(ic->ic_cfg80211_compliance_mode &
        CFG80211_SUPPORT_TXQ_PARAM))
        return 0;

    if (IEEE80211_IS_CHAN_VALID(vap->iv_bsschan)) {
        mode = ieee80211_chan2mode(vap->iv_bsschan);
    } else {
        mode = IEEE80211_MODE_AUTO;
    }
    ac_internal = cfg80211_get_ac_internal(params->ac);
    wlan_configure_all_wmm_params(vap, mode, ac_internal, params);
    if (IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap)) {
        vap->iv_mbss.non_tx_profile_change = true;
        vap->iv_mbss.mbssid_update_ie = true;
    }
    wlan_vdev_beacon_update(vap);

    return 0;
}

/**
 *   ieee80211_cfg80211_send_connect_result: send connect result to cfg80211
 *   This function send connection result to cfg80211 kernel module.
 *   @osdev : pointer to osdev.
 *   @bssid : bssid of connected AP.
 *
 *   returns NONE.
 */
void ieee80211_cfg80211_send_connect_result(osif_dev  *osdev, u_int8_t bssid[QDF_MAC_ADDR_SIZE], uint8_t status)
{
    wlan_if_t vap = osdev->os_if;
    struct net_device *dev = get_cfg80211_notification_ndev(osdev);
    struct wireless_dev *wdev = get_cfg80211_notification_wdev(osdev);
    uint8_t *resp_ie = NULL;
    uint16_t resp_ie_len = 0;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
    struct cfg80211_roam_info info;
#endif

#ifdef CFG80211_MLO_SINGLE_NETDEV_API
    wdev->u.client.ssid_len =  vap->iv_des_ssid[0].len;
    qdf_mem_copy(wdev->u.client.ssid, vap->iv_des_ssid[0].ssid, wdev->u.client.ssid_len);
    qdf_nofl_info("ssid: %s len: %d bssid:%s ",wdev->u.client.ssid, wdev->u.client.ssid_len,ether_sprintf(bssid));
#else
    if (!wdev->ssid_len) {
        wdev->ssid_len =  vap->iv_des_ssid[0].len;
        qdf_mem_copy(wdev->ssid, vap->iv_des_ssid[0].ssid, wdev->ssid_len);
    }
    qdf_nofl_info("ssid: %s len: %d bssid:%s ",wdev->ssid, wdev->ssid_len,ether_sprintf(bssid));
#endif

    if (vap->iv_roam.iv_roaming) {
        if (vap->iv_sta_assoc_resp_ie &&
            vap->iv_sta_assoc_resp_len >= WLAN_ASSOC_RSP_IES_OFFSET) {
            resp_ie = vap->iv_sta_assoc_resp_ie + WLAN_ASSOC_RSP_IES_OFFSET;
            resp_ie_len = vap->iv_sta_assoc_resp_len - WLAN_ASSOC_RSP_IES_OFFSET;
        }
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
        qdf_mem_set(&info, sizeof(info), 0);
#ifdef CFG80211_MLO_SINGLE_NETDEV_API
        info.links[0].bssid = bssid;
        info.links[0].bss = NULL;
#else
        info.bssid = bssid;
        info.bss = NULL;
#endif
        info.resp_ie = resp_ie;
        info.resp_ie_len = resp_ie_len;
        cfg80211_roamed(dev, &info, GFP_ATOMIC);
#else
        cfg80211_roamed(dev,
                NULL,
                bssid,
                NULL, 0, resp_ie, resp_ie_len,
                GFP_ATOMIC);
#endif
    }
    qdf_mem_free(vap->iv_sta_assoc_resp_ie);
    vap->iv_sta_assoc_resp_ie = NULL;
    vap->iv_sta_assoc_resp_len = 0;
}

/**
 * ieee80211_cfg80211_disconnected: Clear roam params.
 *   This function resets roam params on disconnect completion.
 *   @dev : pointer to netdevice.
 *   @resoncode : disconnect reasoncode.
 *
 *   returns NONE.
 */
void ieee80211_cfg80211_disconnected(wlan_if_t vap, struct net_device *dev,
                                     u_int8_t reasoncode)
{
    clear_roam_params(vap);
}

#ifdef WLAN_FEATURE_11BE_MLO
/* MLD Changes */
struct wireless_dev *wlan_cfg80211_mld_add_virtual_intf(struct wiphy *wiphy,
        const char *name,
        unsigned char name_assign_type,
        enum nl80211_iftype type,
        struct vif_params *params)
{
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
   struct cfg80211_context *cfg_ctx = NULL;
#else
    struct cfg80211_mld_wiphy_priv *cfg_ctx = NULL;
#endif
    struct net_device *ndev= NULL;
    struct ieee80211_mld_create_params mld_params = {0};
    struct wireless_dev *priv;
    struct osif_mldev *osifp_mld;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
#else
    cfg_ctx = (struct cfg80211_mld_wiphy_priv*)wiphy_priv(wiphy);
#endif

    if (IEEE80211_ADDR_IS_VALID(params->mld_macaddr)) {
        IEEE80211_ADDR_COPY(&mld_params.mld_macaddr, params->mld_macaddr);
    } else {
        qdf_debug("MLD mac_addr not set");
    }

    if (qdf_atomic_read(&cfg_ctx->mld_count) == MAX_OSIF_MLDEV) {
        qdf_err("Max MLD creation limit reached");
        return ERR_PTR(-EINVAL);
    }

    ndev = osif_mld_create(cfg_ctx->mld_wiphy, &mld_params, name, type);
    if (ndev == NULL) {
        qdf_debug("Failed to create MLD ndev");
        return ERR_PTR(-EINVAL);
    }
    qdf_atomic_inc(&cfg_ctx->mld_count);
    osifp_mld = osif_mld_get_mldev(ndev);
    if (osifp_mld) {
        /**
         * Over-write auto generated mld mac address to update on link vap creation.
         */
        if (!IEEE80211_ADDR_IS_VALID(params->mld_macaddr)) {
            osifp_mld->derived_mld_addr = 1;
            qdf_debug("Setting invalid mac address as user passed if name");
        }

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    osifp_mld->mld_proc = proc_mkdir(ndev->name, NULL);
    if (!osifp_mld->mld_proc)
        qdf_info("Failed to create mld proc entry");
#endif

        qdf_debug("osifp_mld:%p, cfg_ctx:%p, grp_id:%d\n", osifp_mld, cfg_ctx, cfg_ctx->ml_grp_id);
    } else {
        qdf_debug("osifp returned NULL!");
    }

    priv = ndev->ieee80211_ptr;
    return priv;
}

int wlan_cfg80211_mld_del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
{
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct cfg80211_context *cfg_ctx = NULL;
#else
    struct cfg80211_mld_wiphy_priv *cfg_ctx = NULL;
#endif
    struct net_device *mldev = wdev->netdev;
    int ret = 0;
    uint32_t mld_count;

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    cfg_ctx = (struct cfg80211_context*)wiphy_priv(wiphy);
#else
    cfg_ctx = (struct cfg80211_mld_wiphy_priv*)wiphy_priv(wiphy);
#endif
    /*
     * can not delete mld-wifiX interface
     */
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    if (cfg_ctx->mld_netdev == mldev) {
        qdf_debug("On Radio Interface\n");
        return -1;
    }
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct osif_mldev *osifp_mld = osif_mld_get_mldev(mldev);
    if(osifp_mld->mld_proc) {
        proc_remove(osifp_mld->mld_proc);
        osifp_mld->mld_proc = NULL;
    }
#endif

    ret = osif_mld_destroy(mldev);
    if (ret != 0) {
        qdf_debug("Failed to delete interface\n");
    }

    mld_count = qdf_atomic_read(&cfg_ctx->mld_count);
    if (mld_count != 0 && ret == 0) {
        qdf_atomic_dec(&cfg_ctx->mld_count);
        qdf_debug("mld_count:%d\n", mld_count);
    }

    return 0;
}
#endif

/* wlan_cfg80211_set_monitor_channel() - Set requested monitor channel
 * @wiphy: wiphy handle
 * @chandef: channel defination
 *
 * This function set required monitor channel to the radio
 * it will get call only if
 * (num_of_running_ifaces == num_running_monitor_ifaces)&& (num_running_ifaces>0)
 *
 * Return: 0 on success, -EINVAL on failure
 *
 */
int wlan_cfg80211_set_monitor_channel(struct wiphy *wiphy,
                                      struct cfg80211_chan_def *chandef)
{
    struct ieee80211com *ic;
    struct ieee80211vap *tmpvap = NULL;
    struct chan_params chan_p = {0};
    struct cfg80211_context *cfg_ctx;

    if (wiphy == NULL || chandef == NULL)
        return -EINVAL;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if (cfg_ctx->is_mld_phy) {
        qdf_err("Handle this for single wiphy for appropriate radio based on the chandef values");
        return -EINVAL;
    }
    ic = cfg_ctx->ic_list[0];
#else
    ic = cfg_ctx->ic;
#endif

    TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next) {
        if (tmpvap->iv_opmode == IEEE80211_M_MONITOR)
            break;
    }

    if (!tmpvap) {
        qdf_err("Monitor vap not found");
        return -EINVAL;
    }

    chan_p.freq = chandef->chan->center_freq;
    chan_p.cfreq2 = chandef->center_freq1;
    chan_p.input_6g_pwr_mode = REG_BEST_PWR_MODE;

    if (ieee80211_ucfg_set_freq(tmpvap, &chan_p) < 0) {
        qdf_err("Could not set channel frequency %u", chan_p.freq);
        return -EINVAL;
    }

    return 0;
}

/* wlan_cfg80211_set_multicast_to_unicast - Configure multicast to unicast
 *                                          conversion for BSS
 * @wiphy: wiphy handle
 * @dev:   net_device handle
 * @enabled: enabled(True)/disabled(false)
 *
 * Return: 0 on success, -EINVAL on failure
 *
*/
int wlan_cfg80211_set_multicast_to_unicast(struct wiphy *wiphy,
                                           struct net_device *dev,
                                           const bool enabled)
{
    struct ieee80211vap *vap;
    int mode;
    struct cfg80211_context *cfg_ctx = NULL;
    osif_dev *osifp = NULL;

    if (wiphy == NULL || dev == NULL)
        return -EINVAL;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    /* No link id passed here for mld link vap scenario, in that case return error */
    if (cfg_ctx->is_mld_phy && is_mld_netdev(dev)) {
        qdf_err("need link id here ..... investigate");
        return -EINVAL;
    }

    //legacy netdev
    osifp = get_vap_device_context(wiphy, dev, 0);
    if (!osifp) {
        qdf_err("NULL osifp..");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL VAP");
        return -EINVAL;
    }
#else
    osifp = get_vap_device_context(wiphy, dev, 0);
    if (!osifp) {
        qdf_err("NULL osifp..");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL VAP");
        return -EINVAL;
    }
#endif
    /*enabling in mode 5 or disabling with mode 0*/
    mode = (enabled) ? ENABLE_MC_TO_UC : DISABLE_MC_TO_UC;

    /*save config and trigger it once vap is up*/
    vap->iv_mcast_to_ucast_mode = mode;
    if (wlan_vdev_is_up(vap->vdev_obj) != QDF_STATUS_SUCCESS)
        return 0;

    if (mode) {
        ieee80211_ucfg_setparam_on_partner_vap(vap, IEEE80211_PARAM_ME,
                                               mode, NULL);
        return ieee80211_ucfg_setparam(vap, IEEE80211_PARAM_ME, mode, NULL);
    }

    return 0;
}

/* wlan_cfg80211_get_txq_stats - Get TXQ stats for interface or phy
 *                               if wdev is %NULL, this function
 *                               should return phy stats, and interface
 *                               stats otherwise
 *
 * @wiphy: wiphy handle
 * @wdev: wireless_device handle
 * @txqstats: TXQ statistic
 *
 * Return: 0 on success, -EINVAL on failure
 *
 */
 int wlan_cfg80211_get_txq_stats(struct wiphy *wiphy,
                                struct wireless_dev *wdev,
                                struct cfg80211_txq_stats *txqstats)
{
    struct net_device *dev;
    struct wlan_objmgr_vdev *vdev;
    struct wlan_objmgr_pdev *pdev;
    struct ieee80211com *ic;
    osif_dev *osifp = NULL;
    uint8_t id;
    struct cfg80211_context *cfg_ctx = NULL;
    enum cdp_stat_update_type type;
    struct cdp_dev_stats stats;
    ol_txrx_soc_handle soc_txrx_handle;
    struct wlan_objmgr_psoc *psoc = NULL;
    QDF_STATUS status;

    if (!wiphy || !txqstats)
        return -EINVAL;

    /* for wdev == NULL as per defination phystat needs to be return.
     * currently required phystast are not supported so returing 0
     */
    if (!wdev)
        return 0;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
    if (!cfg_ctx) {
        qdf_debug("NULL cfg_ctx");
        return -EINVAL;
    }
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if (cfg_ctx->is_mld_phy &&
        is_mld_phy_radio_command(wiphy, wdev->netdev)) {
        /* mld phy, radio command */
        ic = wlan_cfg80211_find_ic_by_netdev_name(wiphy, wdev->netdev->name);
        if (!ic) {
            qdf_debug("NULL IC");
            return -EINVAL;
        }
    } else if ((cfg_ctx->is_mld_phy) && is_mld_netdev(wdev->netdev)) {
        qdf_debug("find a way to get link_id here for link vaps");
        return -EINVAL;
    } else {
        /* Legacy netdev */
        ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
        if (!ic) {
            qdf_debug("NULL IC investigate");
            return -EINVAL;
        }
    }
#else
    ic = cfg_ctx->ic;
    if (!ic) {
        qdf_debug("NULL IC");
        return -EINVAL;
    }
#endif

    pdev = ic->ic_pdev_obj;
    if (!pdev) {
        qdf_debug("NULL pdev");
        return -EINVAL;
    }

    psoc = wlan_pdev_get_psoc(pdev);
    if (!psoc) {
        qdf_debug("NULL psoc");
        return -EINVAL;
    }

#ifdef QCA_SUPPORT_WDS_EXTENDED
    if (wlan_psoc_nif_feat_cap_get(psoc, WLAN_SOC_F_WDS_EXTENDED) &&
        (wdev->iftype == NL80211_IFTYPE_AP_VLAN))
        return 0;
#endif /* QCA_SUPPORT_WDS_EXTENDED */

    if (ic->ic_wdev.netdev != wdev->netdev) {
        /*vdev level stats*/
        dev = wdev->netdev;
        osifp = get_vap_device_context(wiphy, dev, 0); //link id to be updated later
        if (!osifp) {
            qdf_debug("NULL osifp");
            return -EINVAL;
        }

        vdev = osifp->ctrl_vdev;
        if (!vdev) {
            qdf_debug("NULL vdev");
            return -EINVAL;
        }

        if (wlan_vdev_is_up(vdev) != QDF_STATUS_SUCCESS)
            return 0;

        id = wlan_vdev_get_id(vdev);
        type = UPDATE_VDEV_STATS;
    } else {
        return 0;
    }

    soc_txrx_handle = wlan_psoc_get_dp_handle(psoc);
    if (!soc_txrx_handle) {
        qdf_debug("NULL soc_txrx_handle");
        return -EINVAL;
    }

    status = cdp_ath_getstats(soc_txrx_handle, id, &stats, type);
    if (QDF_IS_STATUS_ERROR(status)) {
        qdf_debug("failed to get TXQ stats for vdev_id : %d",id);
        return qdf_status_to_os_return(status);
    }

    txqstats->filled |= BIT(NL80211_TXQ_STATS_DROPS) |
                        BIT(NL80211_TXQ_STATS_TX_BYTES) |
                        BIT(NL80211_TXQ_STATS_TX_PACKETS);

    txqstats->drops = stats.tx_dropped;
    txqstats->tx_bytes = (u32)stats.tx_bytes;
    txqstats->tx_packets = stats.tx_packets;
    return 0;
}

/* peer_set_noack_map - Set the NoAck Map for the peer
 *
 * @arg:  void pointer holds vap & noack_map info
 * @node: ieee80211_node handle
 *
 */

void peer_set_noack_config(void *arg, wlan_node_t node)
{
    struct tid_config *config = (struct tid_config *)arg;
    wlan_if_t vap = config->vap;
    uint16_t noack_map = config->noack_map;
    uint32_t vdev_id = wlan_vdev_get_id(vap->vdev_obj);
    uint8_t *macaddr = wlan_node_getmacaddr(node);
    struct wlan_objmgr_pdev *pdev = (vap->iv_ic->ic_pdev_obj);
    int ret;

    ret = ieee80211_ucfg_set_peer_tid_noack_config(node->ni_ic, pdev, vdev_id,
                                                   macaddr, noack_map);
    if (ret < 0)
        qdf_err("Could not set the required noack policy");

    return;

}

/* wlan_cfg80211_set_noack_map - Set the NoAck Map for the TID
 *
 * @wiphy: wiphy handle
 * @dev: net_device handle
 * @noack_map: bitmap for TID
 *
 * Return: 0 on success, -EINVAL on failure
 *
 */
int wlan_cfg80211_set_noack_map(struct wiphy *wiphy,
                                struct net_device *dev,
                                uint16_t noack_map)
{
    struct ieee80211vap *vap;
    struct tid_config config;
    int32_t ret = 0;
    struct cfg80211_context *cfg_ctx = NULL;
    osif_dev *osifp = NULL;

    if (wiphy == NULL || dev == NULL)
        return -EINVAL;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    /* No link id passed here for mld link vap scenario, in that case return error */
    if (cfg_ctx->is_mld_phy && is_mld_netdev(dev)) {
        qdf_err("need link id here ..... investigate");
        return -EINVAL;
    }

    //legacy netdev
    osifp = get_vap_device_context(wiphy, dev, 0);
    if (!osifp) {
        qdf_err("NULL osifp..");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL VAP");
        return -EINVAL;
    }
#else
    osifp = get_vap_device_context(wiphy, dev, 0);
    if (!osifp) {
        qdf_err("NULL osifp..");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL VAP");
        return -EINVAL;
    }
#endif
    /*save config for new assoc peer*/
    if (noack_map) {
        vap->iv_is_noack_policy_set = true;
    } else {
        vap->iv_is_noack_policy_set = false;
    }

    vap->noack_map = noack_map;
    config.vap = vap;
    config.noack_map = noack_map;

    ret = wlan_iterate_station_list(vap, peer_set_noack_config, &config);
    if (ret < 0) {
        qdf_err("failed to iterate the station list");
        return ret;
    } else {
        return 0;
    }
}

/**
 * struct cfg80211_ops - cfg80211_ops
 *
 * @add_virtual_intf: Add virtual interface
 * @del_virtual_intf: Delete virtual interface
 * @change_virtual_intf: Change virtual interface
 * @change_station: Change station
 * @add_beacon: Add beacon in sap mode
 * @del_beacon: Delete beacon in sap mode
 * @set_beacon: Set beacon in sap mode
 * @start_ap: Start ap
 * @change_beacon: Change beacon
 * @stop_ap: Stop ap
 * @change_bss: Change bss
 * @add_key: Add key
 * @get_key: Get key
 * @del_key: Delete key
 * @set_default_key: Set default key
 * @set_channel: Set channel
 * @scan: Scan
 * @connect: Connect
 * @disconnect: Disconnect
 * @join_ibss = Join ibss
 * @leave_ibss = Leave ibss
 * @set_wiphy_params = Set wiphy params
 * @set_tx_power = Set tx power
 * @get_tx_power = get tx power
 * @remain_on_channel = Remain on channel
 * @cancel_remain_on_channel = Cancel remain on channel
 * @mgmt_tx = Tx management frame
 * @mgmt_tx_cancel_wait = Cancel management tx wait
 * @set_default_mgmt_key = Set default management key
 * @set_txq_params = Set tx queue parameters
 * @get_station = Get station
 * @set_power_mgmt = Set power management
 * @del_station = Delete station
 * @add_station = Add station
 * @set_pmksa = Set pmksa
 * @del_pmksa = Delete pmksa
 * @flush_pmksa = Flush pmksa
 * @update_ft_ies = Update FT IEs
 * @tdls_mgmt = Tdls management
 * @tdls_oper = Tdls operation
 * @set_rekey_data = Set rekey data
 * @sched_scan_start = Scheduled scan start
 * @sched_scan_stop = Scheduled scan stop
 * @resume = Resume wlan
 * @suspend = Suspend wlan
 * @set_mac_acl = Set mac acl
 * @testmode_cmd = Test mode command
 * @set_ap_chanwidth = Set AP channel bandwidth
 * @dump_survey = Dump survey
 * @key_mgmt_set_pmk = Set pmk key management
 * @get_channel = get Channel info
 */
static struct cfg80211_ops wlan_cfg80211_ops = {
    .add_virtual_intf = wlan_cfg80211_add_virtual_intf,
    .del_virtual_intf = wlan_cfg80211_del_virtual_intf,
#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
    .set_beacon = NULL,
#else
    .start_ap = wlan_cfg80211_start_ap,
    .change_beacon = wlan_cfg80211_change_beacon,
    .stop_ap = wlan_cfg80211_stop_ap,
#endif
    .change_bss = wlan_cfg80211_change_bss,
    .add_key = wlan_cfg80211_add_key,
    .get_key = wlan_cfg80211_get_key,
    .del_key = wlan_cfg80211_del_key,
    .set_default_key = wlan_cfg80211_set_default_key,
    .scan = wlan_cfg80211_scan_start,
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
    .abort_scan = wlan_cfg80211_scan_abort,
#endif
    .connect = wlan_cfg80211_connect,
    .disconnect = wlan_cfg80211_disconnect,
    .join_ibss = NULL,
    .leave_ibss = NULL,
    .set_wiphy_params = wlan_cfg80211_set_wiphy_params,
    .set_tx_power = wlan_cfg80211_set_txpower,
    .get_tx_power = wlan_cfg80211_get_txpower,
    .set_default_mgmt_key = wlan_cfg80211_set_default_mgmt_key,
    .set_default_beacon_key = wlan_cfg80211_set_default_beacon_key,
    .get_station = wlan_cfg80211_get_station,
    .set_power_mgmt = wlan_cfg80211_set_power_mgmt,
    .set_pmksa = NULL,
    .del_pmksa = NULL,
    .flush_pmksa = NULL,
    .update_ft_ies = wlan_cfg80211_update_ft_ies,
    .change_virtual_intf = wlan_cfg80211_change_virtual_intf,
    .probe_client = wlan_cfg80211_probe_client,
    .add_station = wlan_cfg80211_add_station,
    .del_station = wlan_cfg80211_del_station,
    .change_station = wlan_cfg80211_change_station,
    .add_link_station = wlan_cfg80211_add_link_station,
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    .mod_link_station = wlan_cfg80211_mod_link_station,
    .del_link_station = wlan_cfg80211_del_link_station,
#endif
    .set_rekey_data = wlan_cfg80211_set_rekey_dataata,
    .sched_scan_start = wlan_cfg80211_sched_scan_start,
    .sched_scan_stop = wlan_cfg80211_sched_scan_stop,
    .set_mac_acl = wlan_cfg80211_set_mac_acl,
    .set_monitor_channel = wlan_cfg80211_set_monitor_channel,
    .set_multicast_to_unicast = wlan_cfg80211_set_multicast_to_unicast,
    .get_txq_stats = wlan_cfg80211_get_txq_stats,
    .set_noack_map = wlan_cfg80211_set_noack_map,
#ifdef CONFIG_NL80211_TESTMODE
    /* Callback funtion to receive UTF commands from FTM daemon */
    .testmode_cmd = wlan_cfg80211_testmode,
#endif
    .set_antenna = wlan_cfg80211_set_antenna,
    .get_antenna = wlan_cfg80211_get_antenna,
    .mgmt_tx_cancel_wait = wlan_cfg80211_mgmt_tx_cancel_wait,
    .mgmt_tx = wlan_cfg80211_mgmt_tx,
#ifdef QCA_SUPPORT_EAPOL_OVER_CONTROL_PORT
    .tx_control_port = wlan_cfg80211_tx_control_port,
#endif
    .set_txq_params = wlan_cfg80211_set_txq_params,
    .tdls_mgmt = NULL,
    .remain_on_channel = wlan_cfg80211_remain_on_channel,
    .tdls_oper = NULL,
    .cancel_remain_on_channel = wlan_cfg80211_cancel_remain_on_channel,
    .dump_survey = wlan_hdd_cfg80211_dump_survey,
    .channel_switch = wlan_cfg80211_channel_switch,
    .set_ap_chanwidth = wlan_cfg80211_set_ap_chanwidth,
    .get_channel = wlan_cfg80211_get_channel,
#if ATH_SUPPORT_HS20
    .set_qos_map = wlan_cfg80211_set_qos_map,
#endif
    .external_auth = wlan_cfg80211_external_auth,
#if defined(WLAN_SUPPORT_FILS) && !defined(ATH_SUPPORT_DISABLE_FILSCRYPTO_OFFLOAD)
    .set_fils_aad = wlan_cfg80211_set_fils_aad,
#endif /* defined(WLAN_SUPPORT_FILS) && !defined(ATH_SUPPORT_DISABLE_FILSCRYPTO_OFFLOAD) */
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    .add_intf_link = wlan_cfg80211_add_intf_link,
    .del_intf_link = wlan_cfg80211_del_intf_link,
#endif
};

#ifndef ENABLE_CFG80211_BACKPORTS_MLO
#ifdef WLAN_FEATURE_11BE_MLO
static struct cfg80211_ops wlan_mld_cfg80211_ops = {
    .add_virtual_intf = wlan_cfg80211_mld_add_virtual_intf,
    .del_virtual_intf = wlan_cfg80211_mld_del_virtual_intf,
#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
    .set_beacon = NULL,
#else
    .start_ap = NULL,
    .change_beacon = NULL,
    .stop_ap = NULL,
#endif
};
#endif
#endif

#ifndef ENABLE_CFG80211_BACKPORTS_MLO
#ifdef WLAN_FEATURE_11BE_MLO
static int mld_wiphy_hardstart(struct sk_buff *skb, struct net_device *dev)
{
    nbuf_debug_add_record(skb);
    qdf_nbuf_free(skb);
    return 0;
}

static struct net_device_ops singlewiphy_netdev = {
    .ndo_start_xmit =  mld_wiphy_hardstart,
};
#endif
#endif

/* This structure contain information what kind of frame are expected in
   TX/RX direction for each kind of interface */
static const struct ieee80211_txrx_stypes
wlan_cfg80211_txrx_stypes[NUM_NL80211_IFTYPES] = {
    [NL80211_IFTYPE_STATION] = {
        .tx = 0xffff,
        .rx = 0xffff,
    },
    [NL80211_IFTYPE_AP] = {
        .tx = 0xffff,
        .rx = 0xffff,
    },
    [NL80211_IFTYPE_MONITOR] = {
        .tx = 0xffff,
        .rx = 0xffff,
    },
};

static const struct ieee80211_iface_limit wlan_cfg80211_if_limits[] = {
    {
        .max    = 17,
        .types  = BIT(NL80211_IFTYPE_AP)
    },
    {
        .max    = 30, /*  30 sta vaps is needed in max client setup
                          in qwrap mode */
        .types  = BIT(NL80211_IFTYPE_STATION)
    },
    {
        .max    = 1,
        .types  = BIT(NL80211_IFTYPE_MONITOR)
    },
};

static const struct ieee80211_iface_combination wlan_cfg80211_iface_combination[] = {
    {
        .limits = wlan_cfg80211_if_limits,
        .n_limits = ARRAY_SIZE(wlan_cfg80211_if_limits),
        .max_interfaces = 17,
        .num_different_channels = 1,
        .beacon_int_infra_match = true,
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
        .radar_detect_widths =  BIT(NL80211_CHAN_WIDTH_20_NOHT) |
            BIT(NL80211_CHAN_WIDTH_20) |
            BIT(NL80211_CHAN_WIDTH_40) |
            BIT(NL80211_CHAN_WIDTH_80),
#endif
    },
};

/*
 * cipher suite selectors
 * include/linux/ieee80211.h
 */
static const u32 wlan_cfg80211_cipher_suites[] = {
    WLAN_CIPHER_SUITE_USE_GROUP,
    WLAN_CIPHER_SUITE_WEP40,
    WLAN_CIPHER_SUITE_TKIP,
    WLAN_CIPHER_SUITE_CCMP,
    WLAN_CIPHER_SUITE_WEP104,
    WLAN_CIPHER_SUITE_AES_CMAC,
    WLAN_CIPHER_SUITE_GCMP,
    WLAN_CIPHER_SUITE_GCMP_256,
    WLAN_CIPHER_SUITE_CCMP_256,
    WLAN_CIPHER_SUITE_BIP_GMAC_128,
    WLAN_CIPHER_SUITE_BIP_GMAC_256,
    WLAN_CIPHER_SUITE_BIP_CMAC_256,
    WLAN_CIPHER_SUITE_SMS4,
};

static inline
int validate_dbgreq_data_len(struct ieee80211com *ic, int data_len)
{
    if (sizeof(struct ieee80211req_athdbg) > data_len) {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_NORMAL, IEEE80211_MSG_IOCTL,
                                 "%s: Insufficient buffer size\n", __func__);
        return -EINVAL;
    }

    IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_NORMAL, IEEE80211_MSG_IOCTL,
                         "%s: VAP Command\n", __func__);
    return 0;
}
/* wlan_cfg80211_dbgreq - cfg80211 dbgreq handler
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed 1895
 *
 * Return: 0 on success, negative errno on failure
 */

static int
wlan_cfg80211_dbgreq(struct wiphy *wiphy, struct wireless_dev *wdev, struct wlan_cfg8011_genric_params *params)
{
    osif_dev *osifp = NULL;
    struct ieee80211com *ic = NULL;
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    struct net_device *dev = NULL;
#endif
    int err = 0;
    struct ieee80211req_athdbg *req = (struct ieee80211req_athdbg *)params->data;
    struct cfg80211_context *cfg_ctx = NULL;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

    if (!wdev->netdev) {
        qdf_err("null netdev");
        return -EINVAL;
    }

    osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if (is_mld_phy_radio_command(wiphy, wdev->netdev)) {
        /* mld phy, radio command */
        ic = wlan_cfg80211_find_ic_by_netdev_name(wiphy, wdev->netdev->name);
        if (!ic) {
            qdf_err("NULL IC");
            return -EINVAL;
        }

        if (validate_dbgreq_data_len(ic, params->data_len))
            return -EINVAL;

        if (req != NULL) {
           /* Handle requested commands at radio level */
           err = ieee80211_ucfg_radio_level_handle_dbgreq (wdev->netdev, req);
        }
    } else {
        ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
        if (!ic) {
            qdf_err("NULL IC");
            return -EINVAL;
        }
        /* legacy vap command on mld phy */
        if (validate_dbgreq_data_len(ic, params->data_len))
            return -EINVAL;

        err = ieee80211_ucfg_handle_dbgreq(wdev->netdev, osifp, req, NULL, params->data_len);

        if (!err && req->needs_reply) {
            err = cfg80211_reply_command(wiphy, params->data_len, req, 0);
        }
    }
#else
    ic = cfg_ctx->ic;

    if (validate_dbgreq_data_len(ic, params->data_len))
        return -EINVAL;

    dev = wdev->netdev;
    if ((dev != NULL) && (req != NULL)) {
        if (ic->ic_wdev.netdev == wdev->netdev) {
            /* Handle requested commands at radio level */
            err = ieee80211_ucfg_radio_level_handle_dbgreq (dev, req);
        } else {
            err = ieee80211_ucfg_handle_dbgreq(dev, osifp, req, NULL, params->data_len);

            if (!err && req->needs_reply) {
                err = cfg80211_reply_command(wiphy, params->data_len, req, 0);
            }
        }
    }
#endif
    return err;
}

#ifdef CONFIG_AFC_SUPPORT
static const struct nla_policy
wlan_cfg80211_afc_event_policy[QCA_WLAN_VENDOR_ATTR_AFC_EVENT_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_TYPE] = { .type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_AP_DEPLOYMENT] = { .type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_REQ_ID] = { .type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_AFC_WFA_VERSION] = { .type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_MIN_DES_POWER] = { .type = NLA_U16 },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_STATUS_CODE] = { .type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_SERVER_RESP_CODE] = { .type = NLA_S32 },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_EXP_DATE] = { .type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_EXP_TIME] = { .type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_FREQ_RANGE_LIST] = { .type = NLA_NESTED },
    [QCA_WLAN_VENDOR_ATTR_AFC_EVENT_OPCLASS_CHAN_LIST] = { .type = NLA_NESTED },
};

static const struct nla_policy
wlan_cfg80211_afc_reg_eirp_policy[QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_POWER_TYPE] = { .type = NLA_U8 },
    [QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_CLIENT_TYPE] = { .type = NLA_U8 },
};
#endif /* CONFIG_AFC_SUPPORT */

/**
 * wlan_cfg80211_acs_report_channel - send selected channel to hostapd
 *                                      through vendor event.
 * @vap                 : pointer to vap
 * @channel             : pointer to channel
 *
 */
void wlan_cfg80211_generic_event(struct ieee80211com *ic, int cmdid,
        void *buffer, uint32_t buffer_len,
        struct net_device *vap_dev, gfp_t gfp)
{
    struct sk_buff *vendor_event;
    struct net_device *dev;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    int ret_val;
    struct nlattr *nla;
#endif
    uint32_t tlv_buffer_length;

    if (ic  == NULL) {
        qdf_nofl_info("%s: Invalid param: ic is null.\n",__func__);
        return;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    dev = ic->ic_netdev;
#else
    dev = vap_dev;
#endif

    tlv_buffer_length =
        NLA_HDRLEN + sizeof(uint32_t) + /* IF-Index */
        NLA_HDRLEN + /* NEST-Start TLV */
            NLA_HDRLEN + sizeof(uint32_t) + /* sub-Command-ID */
            NLA_HDRLEN + buffer_len + 4; /* Command data + 4 byte align */

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    vendor_event = wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, dev->ieee80211_ptr,
                         NLMSG_HDRLEN + tlv_buffer_length,
                         QCA_NL80211_VENDOR_SUBCMD_GET_WIFI_CONFIGURATION_INDEX,
                         gfp);
    if (!vendor_event) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "cfg80211_vendor_event_alloc failed\n");
        return;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);
    ret_val = nla_put_u32(vendor_event,
            NL80211_ATTR_IFINDEX,
            vap_dev->ifindex);
    if (ret_val) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "NL80211_ATTR_IFINDEX put fail\n");
        goto error_cleanup;
    }

    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);

    if(nla == NULL){
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "nla_nest_start fail nla is NULL \n");
        goto error_cleanup;
    }

    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);
#endif

    if (nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_COMMAND,
                cmdid)) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "%s:%d nla put fail", __func__, __LINE__);
        goto error_cleanup;
    }

    if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_DATA,
                buffer_len, buffer)) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "%s:%d nla put fail", __func__, __LINE__);
        goto error_cleanup;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(vendor_event, nla);
#endif

    wlan_cfg80211_vendor_event(vendor_event, gfp);
    return;
error_cleanup:
    wlan_cfg80211_vendor_free_skb(vendor_event);
}
qdf_export_symbol(wlan_cfg80211_generic_event);

static int get_acs_evt_data_len(void)
{
    uint32_t len = NLMSG_HDRLEN;

    /* QCA_WLAN_VENDOR_ATTR_ACS_PRIMARY_CHANNEL */
    len += nla_total_size(sizeof(u8));

    /* QCA_WLAN_VENDOR_ATTR_ACS_SECONDARY_CHANNEL */
    len += nla_total_size(sizeof(u8));

    /* QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG0_CENTER_CHANNEL */
    len += nla_total_size(sizeof(u8));

    /* QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG1_CENTER_CHANNEL */
    len += nla_total_size(sizeof(u8));

    /* QCA_WLAN_VENDOR_ATTR_ACS_PRIMARY_FREQUENCY */
    len += nla_total_size(sizeof(u32));

    /* QCA_WLAN_VENDOR_ATTR_ACS_SECONDARY_FREQUENCY */
    len += nla_total_size(sizeof(u32));

    /* QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG0_CENTER_FREQUENCY */
    len += nla_total_size(sizeof(u32));

    /* QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG1_CENTER_FREQUENCY */
    len += nla_total_size(sizeof(u32));

    /* QCA_WLAN_VENDOR_ATTR_ACS_CHWIDTH */
    len += nla_total_size(sizeof(u16));

    /* QCA_WLAN_VENDOR_ATTR_ACS_HW_MODE */
    len += nla_total_size(sizeof(u8));

    /* QCA_WLAN_VENDOR_ATTR_ACS_PUNCTURE_BITMAP */
    len += nla_total_size(sizeof(u16));
    
    /* QCA_WLAN_VENDOR_ATTR_ACS_LINK_ID */
    len += nla_total_size(sizeof(u8));

    return len;
}

void wlan_cfg80211_acs_report_channel(wlan_if_t vap,
                                  struct ieee80211_ath_channel *channel)
{
    struct sk_buff *vendor_event;
    int ret_val;
    u_int8_t hw_mode = 0;
    u_int16_t chwidth = 0;
    struct ieee80211com *ic = vap->iv_ic;
    osif_dev *osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    struct net_device *dev = NULL;
    u_int8_t channel_ieee_se = 0;
    u_int8_t sec_channel = 0;
    u_int8_t primary_channel = 0;
    uint32_t primary_freq = 0;
    uint32_t sec_freq = 0;
    int8_t pri_center_ch_diff = 0;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
#endif
    int mode = 0;
    u_int8_t vht_seg1 = 0, vht_seg0 = 0;
    uint32_t vht_seg1_freq = 0, vht_seg0_freq = 0;
    uint32_t len = get_acs_evt_data_len();
#ifdef WLAN_FEATURE_11BE
    uint16_t puncture_bitmap;
#endif /* WLAN_FEATURE_11BE */

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    dev = get_cfg80211_notification_ndev(osif);
    if (!dev) {
        qdf_err("notification netdev is NULL");
        return;
    }

#ifdef WLAN_FEATURE_11BE
    *channel = ieee80211_find_std_channel(ic, channel);
#endif
    channel_ieee_se = ieee80211_chan2ieee(ic, channel);

    if (!osif_vap_event_filter_status_to_app(vap, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_DO_ACS_INDEX)) {
        return;
    }
    vendor_event =
        wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, dev->ieee80211_ptr,
                len,
                QCA_NL80211_VENDOR_SUBCMD_DO_ACS_INDEX,
                GFP_ATOMIC);
    if (!vendor_event) {
        qdf_err("cfg80211_vendor_event_alloc failed: vdev:id :%d, chan: %d",
                vap->iv_unit, channel->ic_freq);
        return;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);
    /* Send the IF INDEX to differentiate the ACS event for each interface
     * TODO: To be update once cfg80211 APIs are updated to accept if_index
     */
    ret_val = nla_put_u32(vendor_event,
            NL80211_ATTR_IFINDEX,
            dev->ifindex);
    if (ret_val) {
        qdf_err("NL80211_ATTR_IFINDEX put fail");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }
    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);
    if(nla == NULL){
        qdf_err("nla_nest_start fail nla is NULL ");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }
    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);
#endif

    if (IEEE80211_IS_CHAN_VALID(channel)) {
        primary_channel = channel->ic_ieee;
        primary_freq = channel->ic_freq;
#ifdef WLAN_FEATURE_11BE
        puncture_bitmap = channel->op_puncture_bitmap;
        /* correct puncture_bitmap to 0x0 for Kernel 6.6
          and latest Hostapd */
        if (vap->vif_type == VIF_TYPE_MLD_LINK_VAP) {
            if (puncture_bitmap == PUNCTURE_INVALID)
                puncture_bitmap = PUNCTURE_NONE;
        }
#endif /* WLAN_FEATURE_11BE */
    }
    ret_val = nla_put_u8(vendor_event,
            QCA_WLAN_VENDOR_ATTR_ACS_PRIMARY_CHANNEL,
            primary_channel);

    if (ret_val) {
        qdf_err("QCA_WLAN_VENDOR_ATTR_ACS_PRIMARY_CHANNEL put fail");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    ret_val = nla_put_u32(vendor_event,
            QCA_WLAN_VENDOR_ATTR_ACS_PRIMARY_FREQUENCY,
            primary_freq);

    if (ret_val) {
        qdf_err("QCA_WLAN_VENDOR_ATTR_ACS_PRIMARY_FREQUENCY put fail");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    if (primary_channel) {
        /* Parameters to derive secondary channels */
#define SEC_40_LOWER -6
#define SEC_40_UPPER -2
#define SEC_80_1 2
#define SEC_80_4 14

        switch (channel->ic_flags & IEEE80211_CHAN_WIDTH_MASK) {
            /*secondary channel for VHT40MINUS and NAHT40MINUS is same */
            case IEEE80211_CHAN_40PLUS:
                sec_channel = channel_ieee_se + 4;
                sec_freq = primary_freq + 20;;
                break;
            case IEEE80211_CHAN_40MINUS:
                sec_channel = channel_ieee_se - 4;
                sec_freq = primary_freq - 20;;
                break;
            case IEEE80211_CHAN_80MHZ:
            case IEEE80211_CHAN_80_80MHZ:
                pri_center_ch_diff = channel_ieee_se - channel->ic_vhtop_ch_num_seg1;

                if(pri_center_ch_diff > 0) {
                    sec_channel = channel->ic_vhtop_ch_num_seg1 + SEC_40_LOWER;
                    sec_freq = channel->ic_vhtop_freq_seg1 + (5 * SEC_40_LOWER);
                } else {
                    sec_channel = channel->ic_vhtop_ch_num_seg1 - SEC_40_UPPER;
                    sec_freq = channel->ic_vhtop_freq_seg1 - (5 * SEC_40_UPPER);
                }
                break;
            case IEEE80211_CHAN_160MHZ:
                pri_center_ch_diff = channel_ieee_se - channel->ic_vhtop_ch_num_seg1;

                if(pri_center_ch_diff > 0) {
                    sec_channel = channel->ic_vhtop_ch_num_seg1 - SEC_80_4;
                    sec_freq = channel->ic_vhtop_freq_seg1 - (5 * SEC_80_4);
                } else {
                    sec_channel = channel->ic_vhtop_ch_num_seg1 + SEC_80_1;
                    sec_freq = channel->ic_vhtop_freq_seg1 + (5 * SEC_80_1);
                }
                break;
            default:
                break;
        }
    }

    /* must report secondary channel always, 0 is harmless */
    ret_val = nla_put_u8(vendor_event,
            QCA_WLAN_VENDOR_ATTR_ACS_SECONDARY_CHANNEL, sec_channel);
    if (ret_val) {
        qdf_err("QCA_WLAN_VENDOR_ATTR_ACS_SECONDARY_CHANNEL put fail");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    /* must report secondary frequency always, 0 is harmless */
    ret_val = nla_put_u32(vendor_event,
            QCA_WLAN_VENDOR_ATTR_ACS_SECONDARY_FREQUENCY, sec_freq);
    if (ret_val) {
        qdf_err("QCA_WLAN_VENDOR_ATTR_ACS_SECONDARY_FREQUENCY put fail");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    if (primary_channel){
        mode = ieee80211_chan2mode(channel);
        if (IEEE80211_IS_CHAN_5GHZ_6GHZ(channel))
            hw_mode = QCA_ACS_MODE_IEEE80211A;
        else if (IEEE80211_IS_CHAN_2GHZ(channel))
            hw_mode = QCA_ACS_MODE_IEEE80211G;
        else if (IEEE80211_IS_CHAN_B(channel))
            hw_mode = QCA_ACS_MODE_IEEE80211B;

        ret_val = nla_put_u8(vendor_event,
                QCA_WLAN_VENDOR_ATTR_ACS_HW_MODE, hw_mode);
        if (ret_val) {
            qdf_err("QCA_WLAN_VENDOR_ATTR_ACS_HW_MODE put fail");
            wlan_cfg80211_vendor_free_skb(vendor_event);
            return;
        }
        chwidth = ieee80211_get_chan_width(channel);

        ret_val = nla_put_u16(vendor_event,
                QCA_WLAN_VENDOR_ATTR_ACS_CHWIDTH, chwidth);
        if (ret_val) {
            qdf_err("QCA_WLAN_VENDOR_ATTR_ACS_CHWIDTH put fail");
            wlan_cfg80211_vendor_free_skb(vendor_event);
            return;
        }
        /*
         * Note:
         * Driver adheres to 802.11-2016 wherein seg2 should contain center of entire 160 Mhz span
         * and seg1 contains center of primary 80 Mhz.
         * However hostapd currently adheres to the older 802.11ac-2013 wherein seg1 contains center
         * of entire 160Mhz span and seg2 contains zero.
         */
        if (((chwidth == CHWIDTH_160) && ieee80211_is_phymode_160(mode))
#ifdef WLAN_FEATURE_11BE
            || (chwidth == CHWIDTH_320)
#endif /* WLAN_FEATURE_11BE */
           ) {
            vht_seg0 = channel->ic_vhtop_ch_num_seg1;
            vht_seg0_freq = channel->ic_vhtop_freq_seg1;
        } else {
            vht_seg0 = channel->ic_vhtop_ch_num_seg1;
            vht_seg0_freq = channel->ic_vhtop_freq_seg1;
        }

        ret_val = nla_put_u8(vendor_event,
                QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG0_CENTER_CHANNEL, vht_seg0);
        if (ret_val) {
            qdf_err("QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG0_CENTER_CHANNEL put fail");
            wlan_cfg80211_vendor_free_skb(vendor_event);
            return;
        }

        ret_val = nla_put_u32(vendor_event,
                QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG0_CENTER_FREQUENCY, vht_seg0_freq);
        if (ret_val) {
            qdf_err("QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG0_CENTER_FREQUENCY put fail");
            wlan_cfg80211_vendor_free_skb(vendor_event);
            return;
        }

        if (ieee80211_is_phymode_8080(mode) || ieee80211_is_phymode_160(mode)
#ifdef WLAN_FEATURE_11BE
            || (chwidth == CHWIDTH_320)
#endif /* WLAN_FEATURE_11BE */
	   ) {
            vht_seg1 = channel->ic_vhtop_ch_num_seg2;
            vht_seg1_freq = channel->ic_vhtop_freq_seg2;
        } else {
            vht_seg1 = 0;
            vht_seg1_freq = 0;
        }

        ret_val = nla_put_u8(vendor_event,
                QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG1_CENTER_CHANNEL, vht_seg1);
        if (ret_val) {
            qdf_err("qca_wlan_vendor_attr_acs_vht_seg1_center_channel put fail");
            wlan_cfg80211_vendor_free_skb(vendor_event);
            return;
        }
        ret_val = nla_put_u32(vendor_event,
                QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG1_CENTER_FREQUENCY, vht_seg1_freq);
        if (ret_val) {
            qdf_err("qca_wlan_vendor_attr_acs_vht_seg1_center_channel put fail");
            wlan_cfg80211_vendor_free_skb(vendor_event);
            return;
        }

#ifdef WLAN_FEATURE_11BE
        ret_val = nla_put_u16(vendor_event,
                QCA_WLAN_VENDOR_ATTR_ACS_PUNCTURE_BITMAP, puncture_bitmap);
        if (ret_val) {
            qdf_err("qca_wlan_vendor_attr_acs_puncture_bitmap put fail");
            wlan_cfg80211_vendor_free_skb(vendor_event);
            return;
        }

        /*
         *  Add LinkID - only for LinkVAPs
         *
         */
        if (vap->vif_type == VIF_TYPE_MLD_LINK_VAP) {
            ret_val = nla_put_u8(vendor_event,
                    QCA_WLAN_VENDOR_ATTR_ACS_LINK_ID, vap->link_id);
            if (ret_val) {
                qdf_err("QCA_WLAN_VENDOR_ATTR_ACS_LINK_ID put fail");
                wlan_cfg80211_vendor_free_skb(vendor_event);
                return;
            }
        }
#endif /* WLAN_FEATURE_11BE */
    }

    if (!IEEE80211_IS_CHAN_VALID(channel)) {
       qdf_err("%s: Returning due to null channel.", __func__);
       wlan_cfg80211_vendor_free_skb(vendor_event);
       return;
    }

    qdf_nofl_info("vap-%d(%s): ACS result PCH %d freq %d, SCH %d freq %d, hw_mode %d chwidth %d, vht_seg0 %d freq %d, vht_seg1 %d freq %d"
#ifdef WLAN_FEATURE_11BE
                  " puncture pattern %x LinkID: %d"
#endif /* WLAN_FEATURE_11BE */
                  ,
                  vap->iv_unit, vap->iv_netdev_name,
                  channel->ic_ieee, channel->ic_freq, sec_channel, sec_freq, hw_mode, chwidth,
                  vht_seg0, vht_seg0_freq, vht_seg1, vht_seg1_freq
#ifdef WLAN_FEATURE_11BE
                  , puncture_bitmap, vap->link_id
#endif /* WLAN_FEATURE_11BE */
                 );

    vap->iv_des_cfreq2_80_80 = channel->ic_vhtop_freq_seg2;
    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);
}

/**
 * wlan_get_channel_flags - Get corresponding
 *                          vendor flags for internal flags
 * @flags                 : Flag to be converted
 *
 * Return: Corresponding Vendor flag
 */
uint64_t wlan_get_channel_flags(uint64_t flags)
{
    if (flags == IEEE80211_CHAN_2GHZ)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_2GHZ;

    if (flags == IEEE80211_CHAN_5GHZ)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_5GHZ;

    if (flags == IEEE80211_CHAN_HT20)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HT20;

    if (flags == IEEE80211_CHAN_PASSIVE)
         return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_PASSIVE;

    if (flags == IEEE80211_CHAN_HT40PLUS)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HT40PLUS;

    if (flags == IEEE80211_CHAN_HT40MINUS)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HT40MINUS;

    if (flags == IEEE80211_CHAN_VHT20)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_VHT20;

    if (flags == IEEE80211_CHAN_VHT40PLUS)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_VHT40PLUS;

    if (flags == IEEE80211_CHAN_VHT40MINUS)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_VHT40MINUS;

    if (flags == IEEE80211_CHAN_VHT80)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_VHT80;

    if (flags == IEEE80211_CHAN_VHT160)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_VHT160;

    if (flags == IEEE80211_CHAN_VHT80_80)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_VHT80_80;

    if (flags == IEEE80211_CHAN_HE20)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HE20;

    if (flags == IEEE80211_CHAN_HE40PLUS)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HE40PLUS;

    if (flags == IEEE80211_CHAN_HE40MINUS)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HE40MINUS;

    if (flags == IEEE80211_CHAN_HE80)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HE80);

    if (flags == IEEE80211_CHAN_HE160)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HE160);

    if (flags == IEEE80211_CHAN_HE80_80)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HE80_80);

    if (flags == IEEE80211_CHAN_6GHZ)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_6GHZ);

    if (flags == IEEE80211_CHAN_A)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_A);

    if (flags == IEEE80211_CHAN_B)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_B);

    if (flags == IEEE80211_CHAN_PUREG)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_PUREG);

    if (flags == IEEE80211_CHAN_HALF)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_HALF;

    if (flags == IEEE80211_CHAN_QUARTER)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_QUARTER;

    if (flags == IEEE80211_CHAN_ST)
        return QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_TURBO;

#ifdef WLAN_FEATURE_11BE
    if (flags == IEEE80211_CHAN_EHT20)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EHT20);

    if (flags == IEEE80211_CHAN_EHT40PLUS)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EHT40PLUS);

    if (flags == IEEE80211_CHAN_EHT40MINUS)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EHT40MINUS);

    if (flags == IEEE80211_CHAN_EHT80)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EHT80);

    if (flags == IEEE80211_CHAN_EHT160)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EHT160);

    if (flags == IEEE80211_CHAN_EHT320)
        return VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EHT320);
#endif  /* WLAN_FEATURE_11BE*/

    return 0;
}

/**
 * wlan_get_channel_flags_ext - Get corresponding
 *                              vendor flags ext for internal flags
 * @flags                 : Flag to be converted
 *
 * Return: Corresponding Vendor Ext flag
 */
uint32_t wlan_get_channel_flags_ext(uint32_t flags)
{
    uint32_t retval = 0;

    if (flags & IEEE80211_CHAN_DFS)
        retval |= QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EXT_DFS;

    if (flags & IEEE80211_CHAN_PSC)
        retval |= QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EXT_PSC;

    if (flags & IEEE80211_CHAN_DISALLOW_ADHOC)
        retval |= QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EXT_DISALLOW_ADHOC;

    if (flags & IEEE80211_CHAN_DFS_CFREQ2)
        retval |= QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EXT_DFS_CFREQ2;

    return retval;
}

/**
 * convert_6g_power_mode_internal_to_nl - Get the vendor enum corresponding to
 * internal enum reg_6g_ap_type.
 * @pwr_mode : Internal enum value of power mode to be converted
 *
 * Return: Vendor enum for power mode
 */
uint8_t
convert_6g_power_mode_internal_to_nl(enum reg_6g_ap_type pwr_mode)
{
    switch (pwr_mode) {
        case REG_INDOOR_AP:
            return QCA_WLAN_VENDOR_EXTERNAL_ACS_CHAN_LOW_POWER;
        case REG_STANDARD_POWER_AP:
            return QCA_WLAN_VENDOR_EXTERNAL_ACS_CHAN_STANDARD_POWER;
        case REG_VERY_LOW_POWER_AP:
            return QCA_WLAN_VENDOR_EXTERNAL_ACS_CHAN_VERY_LOW_POWER;
        default:
            return QCA_WLAN_VENDOR_EXTERNAL_ACS_CHAN_LOW_POWER;
    }
}

/* Short name for QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_CHAN_INFO event */
#define CHAN_INFO_ATTR_FLAGS \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_FLAGS
#define CHAN_INFO_ATTR_FLAG_EXT \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_FLAG_EXT
#define CHAN_INFO_ATTR_FREQ \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_FREQ
#define CHAN_INFO_ATTR_MAX_REG_POWER \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_MAX_REG_POWER
#define CHAN_INFO_ATTR_MAX_POWER \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_MAX_POWER
#define CHAN_INFO_ATTR_MIN_POWER \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_MIN_POWER
#define CHAN_INFO_ATTR_REG_CLASS_ID \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_REG_CLASS_ID
#define CHAN_INFO_ATTR_ANTENNA_GAIN \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_ANTENNA_GAIN
#define CHAN_INFO_ATTR_VHT_SEG_0 \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_VHT_SEG_0
#define CHAN_INFO_ATTR_VHT_SEG_1 \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_VHT_SEG_1
#define CHAN_INFO_ATTR_FREQ_SEG_0 \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_FREQ_SEG_0
#define CHAN_INFO_ATTR_FREQ_SEG_1 \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_FREQ_SEG_1
#define CHAN_INFO_ATTR_FREQ_OVERLAP_SEG_1 \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_FREQ_OVERLAP_SEG_1
#define CHAN_INFO_ATTR_FLAGS_2 \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_FLAGS_2
#define CHAN_INFO_ATTR_POWER_MODE_FLAG \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_INFO_ATTR_SUPP_POWER_MODES
#define CHAN_POWER_INFO_ATTR_POWER_LEVEL \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_POWER_INFO_ATTR_POWER_MODE
#define CHAN_POWER_INFO_ATTR_POWER_VALUE \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_POWER_INFO_ATTR_POWER_VALUE
#define CHAN_POWER_INFO_ATTR_PSD_FLAG \
    QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_POWER_INFO_ATTR_PSD_FLAG

#define CHAN_FLAGS_LOWER32(_flag) ((_flag) & 0xFFFFFFFF)

#define CHAN_FLAGS_UPPER32(_flag) \
    (((_flag) & 0xFFFFFFFF00000000) >> 32)


/**
 * cfg80211_update_channel_info() - add channel info attributes
 * @skb: pointer to sk buff
 * @vap: pointer to vap structure
 * @idx: attribute index
 * @freq_list: pointer to the channel frequency list array
 * @ccount: number of channels in the freq_list array
 * @chan_2_4ghz_found: pointer to location of bool which is to be set to true if
 * any 2.4 GHz channel is found
 * @chan_5ghz_found: pointer to location of bool which is to be set to true if
 * any 5 GHz channel is found
 * @chan_6ghz_found: pointer to location of bool which is to be set to true if
 * any 6 GHz channel is found
 *
 * Return: Success(0) or reason code for failure
 */
int32_t
cfg80211_update_channel_info(struct sk_buff *skb,
                             wlan_if_t vap, int idx, uint32_t *freq_list,
                             uint32_t *ccount,
                             bool *chan_2_4ghz_found,
                             bool *chan_5ghz_found,
                             bool *chan_6ghz_found)
{
    struct ol_ath_softc_net80211 *scn = NULL;
    struct nlattr *nla_attr;
    struct nlattr *channel;
    struct nlattr *chan_pwr_attr;
    struct nlattr *power_vals;
    struct ieee80211_ath_channel *icv = NULL;
    int i;
    int status = 0;
    bool is_wideband_csa_allowed;
    struct ieee80211req_chaninfo *chanlist = NULL;
    struct ieee80211_channel_list_info *chanlist_info = NULL;
    int nchans_max = ((IEEE80211_CHANINFO_MAX - 1) * sizeof(__u32))/
        sizeof(struct ieee80211_ath_channel);
    enum reg_6g_ap_type pwr_mode;
    struct ieee80211com *ic;
    struct wlan_objmgr_pdev *pdev;
    uint8_t band_mask = REG_BAND_UNKNOWN;

    if (NULL == skb) {
        qdf_err("skb is NULL");
        status = -EINVAL;
        goto fail;
    }

    if (NULL == vap) {
        qdf_err("vap is NULL");
        status = -EINVAL;
        goto fail;
    }

    scn = OL_ATH_SOFTC_NET80211(vap->iv_ic);
    if (NULL == scn) {
        qdf_err("scn is NULL");
        status = -EINVAL;
        goto fail;
    }

    ic = vap->iv_ic;
    if (!ic) {
        qdf_err("ic is null");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;
    if (!pdev) {
        qdf_err("pdev is null");
        return -EINVAL;
    }

    if (NULL == freq_list) {
        qdf_err("freq_list is NULL");
        status = -EINVAL;
        goto fail;
    }

    if (NULL == ccount) {
        qdf_err("ccount is NULL");
        status = -EINVAL;
        goto fail;
    }

    if (NULL == chan_2_4ghz_found) {
        qdf_err("chan_2_4ghz_found is NULL");
        status = -EINVAL;
        goto fail;
    }

    if (NULL == chan_5ghz_found) {
        qdf_err("chan_5ghz_found is NULL");
        status = -EINVAL;
        goto fail;
    }

    if (NULL == chan_6ghz_found) {
        qdf_err("chan_6ghz_found is NULL");
        status = -EINVAL;
        goto fail;
    }

    *chan_2_4ghz_found = *chan_5ghz_found = *chan_6ghz_found = false;

    chanlist = (struct ieee80211req_chaninfo *)qdf_mem_malloc(sizeof(*chanlist));
    if (NULL == chanlist) {
        qdf_print("Not enough memmory to form channel list %s",__func__);
        status = -ENOMEM;
        goto fail;
    }

    chanlist_info = (struct ieee80211_channel_list_info *)qdf_mem_malloc(
            sizeof(*chanlist_info));
    if (!chanlist_info) {
        qdf_err("NULL chanlist_info");
        status = -ENOMEM;
        goto fail;
    }

    wlan_get_chan_info(vap, chanlist->ic_chans, chanlist_info->chans,
                      &chanlist->ic_nchans);

    if (chanlist->ic_nchans > nchans_max) {
        chanlist->ic_nchans = nchans_max;
    }

    *ccount = 0;

    nla_attr = nla_nest_start(skb, idx);

    if (!nla_attr) {
        status = -EINVAL;
        goto fail;
    }

    /*
     * Check for wideband support only if DCS is triggered. For all other
     * invocations, allow all supported channels to be considered.
     */
    if (vap->iv_ic->cw_inter_found &&
        (check_inter_band_switch_compatibility(vap->iv_ic) == QDF_STATUS_SUCCESS)) {
        is_wideband_csa_allowed = true;
    } else {
        is_wideband_csa_allowed = false;
    }

    for (i = 0; i < chanlist->ic_nchans; i++) {
        channel = nla_nest_start(skb, i);

        if (!channel) {
            status = -EINVAL;
            goto fail;
        }

        icv = &chanlist->ic_chans[i];
        if (!IEEE80211_IS_CHAN_VALID(icv)) {
            qdf_print("channel info not found %s",__func__);
            status = -EINVAL;
            goto fail;
        }

        /*
         * Skip interband channels from the list for DCS cases if:
         * (1) Wideband CSA is not allowed.
         * (2) Wideband CSA is allowed but DCS policy is not set to interband.
         */
        if (vap->iv_ic->cw_inter_found &&
            IEEE80211_ARE_CHANS_INTERWIDEBAND(vap->iv_ic->ic_curchan, icv) &&
            (!is_wideband_csa_allowed ||
             (scn->scn_dcs.dcs_wideband_policy != DCS_WIDEBAND_POLICY_INTERBAND))) {
            continue;
        }

        freq_list[i] = icv->ic_freq;

        if (nla_put_u16(skb, CHAN_INFO_ATTR_FREQ,
                icv->ic_freq) ||
            nla_put_u32(skb, CHAN_INFO_ATTR_FLAGS,
                CHAN_FLAGS_LOWER32(chanlist_info->chans[i].flags)) ||
            nla_put_u32(skb, CHAN_INFO_ATTR_FLAG_EXT,
                (chanlist_info->chans[i].flags_ext)) ||
            nla_put_u8(skb, CHAN_INFO_ATTR_MAX_REG_POWER,
                icv->ic_maxregpower) ||
            nla_put_u8(skb, CHAN_INFO_ATTR_MAX_POWER,
                icv->ic_maxpower) ||
            nla_put_u8(skb, CHAN_INFO_ATTR_MIN_POWER,
                icv->ic_minpower) ||
            nla_put_u8(skb, CHAN_INFO_ATTR_REG_CLASS_ID,
                icv->ic_regClassId) ||
            nla_put_u8(skb, CHAN_INFO_ATTR_ANTENNA_GAIN,
                icv->ic_antennamax) ||
            nla_put_u32(skb, CHAN_INFO_ATTR_FLAGS_2,
                CHAN_FLAGS_UPPER32(chanlist_info->chans[i].flags)) ||
            nla_put_u16(skb, CHAN_INFO_ATTR_POWER_MODE_FLAG,
                chanlist_info->chans[i].supp_power_modes)) {
            qdf_print("put fail");
            status = -EINVAL;
            goto fail;
        }

        if (IEEE80211_IS_CHAN_2GHZ(icv)) {
            band_mask = BIT(REG_BAND_2G);
        }

        if (IEEE80211_IS_CHAN_5GHZ(icv)) {
            band_mask = BIT(REG_BAND_5G);
        }

        if (IEEE80211_IS_CHAN_6GHZ(icv)) {
            band_mask = BIT(REG_BAND_6G);
        }

#ifdef WLAN_FEATURE_11BE
        if((chanlist_info->chans[i].flags &
            VENDOR_CHAN_FLAG2(QCA_WLAN_VENDOR_CHANNEL_PROP_FLAG_EHT320))) {
            if (nla_put_u32(skb, CHAN_INFO_ATTR_FREQ_SEG_0,
                    wlan_reg_chan_band_to_freq(pdev,
                    chanlist_info->chans[i].vhtop_ch_num_seg1, band_mask)) ||
                nla_put_u32(skb, CHAN_INFO_ATTR_FREQ_SEG_1,
                    wlan_reg_chan_band_to_freq(pdev,
                    chanlist_info->chans[i].vhtop_ch_num_seg2[INDEX_320_SEG2_CENTER1],
                    band_mask)) ||
                nla_put_u32(skb, CHAN_INFO_ATTR_FREQ_OVERLAP_SEG_1,
                    wlan_reg_chan_band_to_freq(pdev,
                    chanlist_info->chans[i].vhtop_ch_num_seg2[INDEX_320_SEG2_CENTER2],
                    band_mask))) {
                qdf_err("put fail");
                status = -EINVAL;
                goto fail;
            }
        } else {
#endif
            if (nla_put_u32(skb, CHAN_INFO_ATTR_FREQ_SEG_0,
                    wlan_reg_chan_band_to_freq(pdev,
                    chanlist_info->chans[i].vhtop_ch_num_seg1, band_mask)) ||
                nla_put_u32(skb, CHAN_INFO_ATTR_FREQ_SEG_1,
                    wlan_reg_chan_band_to_freq(pdev,
                    chanlist_info->chans[i].vhtop_ch_num_seg2[INDEX_160_SEG2_CENTER],
                    band_mask))) {
                qdf_err("put fail");
                status = -EINVAL;
                goto fail;
            }
#ifdef WLAN_FEATURE_11BE
        }
#endif

        chan_pwr_attr = nla_nest_start(skb,
                        QCA_WLAN_VENDOR_EXTERNAL_ACS_EVENT_CHAN_POWER_INFO_ATTR);
        if (!chan_pwr_attr) {
            status = -EINVAL;
            goto fail;
        }
        for (pwr_mode = REG_INDOOR_AP; pwr_mode < REG_CURRENT_MAX_AP_TYPE; pwr_mode++) {
            power_vals = nla_nest_start(skb, pwr_mode);

            if (!power_vals) {
                status = -EINVAL;
                goto fail;
            }

            if (nla_put_u8(skb, CHAN_POWER_INFO_ATTR_POWER_LEVEL,
                   convert_6g_power_mode_internal_to_nl(pwr_mode)) ||
                nla_put_u32(skb, CHAN_POWER_INFO_ATTR_POWER_VALUE,
                   chanlist_info->chans[i].reg_powers[pwr_mode].tx_power)) {
                qdf_err("put fail");
                status = -EINVAL;
                goto fail;
            }

            nla_nest_end(skb, power_vals);
        }
        nla_nest_end(skb, chan_pwr_attr);

        /*
         * For flexibility, we do not use an if-else decision while populating
         * whether 2.4/5/6 GHz channels are found. Rather, we use independent
         * checks and let the underlying macro infrastructure to decide on
         * enforcing the mutual exclusivity.
         */
        if (IEEE80211_IS_CHAN_2GHZ(icv)) {
            *chan_2_4ghz_found = true;
        }

        if (IEEE80211_IS_CHAN_5GHZ(icv)) {
            *chan_5ghz_found = true;
        }

        if (IEEE80211_IS_CHAN_6GHZ(icv)) {
            *chan_6ghz_found = true;
        }

        (*ccount)++;

        nla_nest_end(skb, channel);
    }
    nla_nest_end(skb, nla_attr);
fail:
    if (chanlist) {
        qdf_mem_free(chanlist);
    }

    if (chanlist_info) {
        qdf_mem_free(chanlist_info);
    }

    return status;
}

#undef CHAN_INFO_ATTR_FLAGS
#undef CHAN_INFO_ATTR_FLAG_EXT
#undef CHAN_INFO_ATTR_FREQ
#undef CHAN_INFO_ATTR_MAX_REG_POWER
#undef CHAN_INFO_ATTR_MAX_POWER
#undef CHAN_INFO_ATTR_MIN_POWER
#undef CHAN_INFO_ATTR_REG_CLASS_ID
#undef CHAN_INFO_ATTR_ANTENNA_GAIN
#undef CHAN_INFO_ATTR_VHT_SEG_0
#undef CHAN_INFO_ATTR_VHT_SEG_1
#undef CHAN_INFO_ATTR_FLAGS_2
#undef CHAN_INFO_ATTR_FREQ_SEG_0
#undef CHAN_INFO_ATTR_FREQ_SEG_1
#undef CHAN_INFO_ATTR_FREQ_OVERLAP_SEG_1

/**
 * wlan_cfg80211_get_wideband_support: Get wideband support for a given
 * interface.
 * Send a boolean flag for wideband support and not the driver
 * maintained enumeration for various modes.
 *
 * NOTE: This function is temporary and will be removed once the corresponding
 *       vendor command has been upstreamed.
 *
 * @wiphy : Pointer to wiphy
 * @wdev  : Pointer to wdev
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 for success or corresponding error code for failure.
 */
static int wlan_cfg80211_get_wideband_support(struct wiphy *wiphy,
                                      struct wireless_dev *wdev,
                                      struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int cmd_type = -1;
    void *cmd = NULL;
    wlan_if_t vap = NULL;
    uint32_t wideband_support;

    if (params == NULL) {
        qdf_err("NULL params argument.");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);
    if (cmd == NULL) {
        qdf_err("NULL command context obtained. Sanity check failed. "
                "Investigate.");
        return -EINVAL;
    }

    if (cmd_type == VAP_CMD) {
        vap = (wlan_if_t)cmd;
    } else {
        qdf_err("Invalid interface");
        return -EINVAL;
    }

    /* Sending a boolean value to the requestor */
    wideband_support = !!ic->ic_wideband_csa_support;

    qdf_info("Sending wideband support: %u", wideband_support);
    return cfg80211_reply_command(wiphy,
                                  sizeof(uint32_t),
                                  &wideband_support, 0);
}

static int send_sched_mode_probe_resp_event(struct wiphy *wiphy,
                                            struct wireless_dev *wdev,
                                            struct wlan_host_sched_mode_probe_resp_event *evt_params)
{
    struct sk_buff *skb;
    uint32_t len;

    len = NLMSG_HDRLEN + nla_total_size(sizeof(struct wlan_host_sched_mode_probe_resp_event));

    skb = wlan_cfg80211_vendor_event_alloc(wiphy,
            wdev, len,
            QCA_NL80211_VENDOR_SUBCMD_DISABLE_MU_MODES_INDEX,
            GFP_ATOMIC);
    if (!skb) {
        qdf_err("cfg80211_vendor_event_alloc failed");
        goto ret;
    }

    if (wlan_nla_put_u64(skb, QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_VIF_ID,
                         evt_params->vdev_id)) {
        qdf_err("%d: put failure\n", __LINE__);
        goto free_ret;
    }

    if (wlan_nla_put_u64(skb, QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_HW_LINK_ID,
                        evt_params->hw_link_id)) {
        qdf_err("%d: put failure\n", __LINE__);
        goto free_ret;
    }

    if (wlan_nla_put_u64(skb, QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_ACTIVE_TPUT,
                         evt_params->tput_mbps_on)) {
        qdf_err("%d: put failure\n", __LINE__);
        goto free_ret;
    }

    if (wlan_nla_put_u64(skb, QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_INACTIVE_TPUT,
                         evt_params->tput_mbps_off)) {
        qdf_err("%d: put failure\n", __LINE__);
        goto free_ret;
    }

    wlan_cfg80211_vendor_event(skb, GFP_ATOMIC);
    goto ret;

free_ret:
    qdf_info("%s: Sending sched mode probe resp event failed", __func__);
    if(skb)
        wlan_cfg80211_vendor_free_skb(skb);
ret:
    return 0;
}

#ifdef WLAN_FEATURE_11BE_MLO
static int send_link_removal_tbtt_update_event(struct wiphy *wiphy,
                                               struct wireless_dev *wdev,
                                               struct cfg80211_mlo_link_removal_evt_params *evt_params)
{
    struct sk_buff *skb;
    int length;
    int status = 0;

    length = NLMSG_HDRLEN + nla_total_size(sizeof(struct cfg80211_mlo_link_removal_evt_params));

    skb = wlan_cfg80211_vendor_event_alloc(wiphy,
            wdev,
            length,
            QCA_NL80211_VENDOR_SUBCMD_MLO_LINK_REMOVAL_TBTT_UPDATE_INDEX,
            GFP_ATOMIC);
    if (!skb) {
        qdf_err("%s: cfg80211_vendor_event_alloc failed", __func__);
        status = -ENOMEM;
        goto ret;
    }

    if (nla_put_u16(skb, QCA_WLAN_VENDOR_ATTR_MLO_LINK_TBTT_UPDATE_HW_LINK_ID,
                    evt_params->hw_link_id)) {
            qdf_err("%d: put failure\n", __LINE__);
            status = -EINVAL;
            goto free_ret;
    }

    if (nla_put(skb, QCA_WLAN_VENDOR_ATTR_MLO_LINK_TBTT_UPDATE_AP_MLD_ADDR, QDF_MAC_ADDR_SIZE,
                &evt_params->mld_addr[0])) {
            qdf_err("%d: put failure\n", __LINE__);
            status = -EINVAL;
            goto free_ret;
    }

    if (wlan_nla_put_u64(skb, QCA_WLAN_VENDOR_ATTR_MLO_LINK_TBTT_UPDATE_TSF,
                         evt_params->tsf)) {
        qdf_err("%d: put failure\n", __LINE__);
        status = -EINVAL;
        goto free_ret;
    }

    if (nla_put_u16(skb, QCA_WLAN_VENDOR_ATTR_MLO_LINK_TBTT_UPDATE_BCN_INT,
                    evt_params->beacon_interval)) {
        qdf_err("%d: put failure\n", __LINE__);
        status = -EINVAL;
        goto free_ret;
    }

    if (nla_put_u16(skb, QCA_WLAN_VENDOR_ATTR_MLO_LINK_TBTT_UPDATE_TBTT,
                    evt_params->tbtt_count)) {
        qdf_err("%d: put failure\n", __LINE__);
        status = -EINVAL;
        goto free_ret;
    }

    wlan_cfg80211_vendor_event(skb, GFP_ATOMIC);
    goto ret;

free_ret:
    qdf_info("%s: Sending link removal TBTT update event failed", __func__);
    if(skb)
        wlan_cfg80211_vendor_free_skb(skb);
ret:
    return status;
}
#endif

#ifdef WLAN_FEATURE_11BE
QDF_STATUS wlan_cfg80211_send_link_unavailable_update_event(struct wlan_objmgr_vdev *vdev,
                                                   struct wlan_t2lm_info *t2lm)
{
    struct sk_buff *skb;
    struct cfg80211_mlo_link_update_evt_params link_update_params = {0};
    struct ieee80211vap *vap;
    struct ieee80211com *ic;
    osif_dev *osif;
    struct net_device *dev;
    struct wlan_objmgr_pdev *pdev;
    struct qdf_mac_addr *mld_addr = NULL;
    QDF_STATUS status = QDF_STATUS_E_INVAL;
    int length=0;
    uint16_t valid_link_mask = 0;
    uint8_t i = 0;
    struct wlan_objmgr_vdev *wlan_vdev_list[WLAN_UMAC_MLO_MAX_VDEVS] = {NULL};
    uint16_t vdev_count = 0;
    struct wlan_objmgr_pdev *tmp_pdev = NULL;
    struct wlan_objmgr_vdev *tmp_vdev = NULL;
    struct wlan_mlo_dev_context *ml_dev;

    if(!t2lm) {
       qdf_err("t2lm is null");
       return QDF_STATUS_E_NULL_VALUE;
    }

    if (!vdev) {
        qdf_err("vdev is null");
        return QDF_STATUS_E_NULL_VALUE;
    }

    vap = wlan_vdev_get_vap(vdev);
    if (!vap) {
        qdf_err("vap is null");
        return QDF_STATUS_E_NULL_VALUE;
    }

    ic = vap->iv_ic;
    if (!ic) {
        qdf_err("ic is null");
        return QDF_STATUS_E_NULL_VALUE;
    }

    pdev = ic->ic_pdev_obj;
    if (!pdev) {
        qdf_err("pdev is null");
        return QDF_STATUS_E_NULL_VALUE;
    }

    osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    dev = osif->netdev;
    mld_addr = (struct qdf_mac_addr *)wlan_vdev_mlme_get_mldaddr(vdev);
    if(!mld_addr) {
        qdf_err("mld_addr is NULL");
        return QDF_STATUS_E_NULL_VALUE;
    }

    ml_dev = wlan_mlo_get_mld_ctx_by_mldaddr(mld_addr);
    if (!ml_dev) {
        qdf_err("Failed to get MLD dev context by mld addr "QDF_MAC_ADDR_FMT,
            QDF_MAC_ADDR_REF(mld_addr->bytes));
        if (!vdev->mlo_dev_ctx) {
            qdf_err("Failed to get MLD dev context from vdev");
            return QDF_STATUS_E_NULL_VALUE;
        }

        ml_dev = vdev->mlo_dev_ctx;
    }

    length = NLMSG_HDRLEN +
             (sizeof(struct cfg80211_mlo_link_update_evt_params));

    if (!osif_vap_event_filter_status_to_app(vap, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_TTLM_LINK_UPDATE_INDEX)) {
        return QDF_STATUS_SUCCESS;
    }
    skb = wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy,
            dev->ieee80211_ptr,
            length,
            QCA_NL80211_VENDOR_SUBCMD_TTLM_LINK_UPDATE_INDEX,
            GFP_ATOMIC);

    if (!skb) {
        qdf_err("cfg80211_vendor_event_alloc failed");
        status = QDF_STATUS_E_NULL_VALUE;
        goto ret;
    }

    mlo_get_ml_vdev_list(vap->vdev_obj, &vdev_count, wlan_vdev_list);
    if (!vdev_count) {
        qdf_err("Number of VDEVs under MLD is reported as 0");
        status = QDF_STATUS_E_INVAL;
        goto free_ret;
    }

    for (i = 0; i < vdev_count; i++) {
        tmp_vdev = wlan_vdev_list[i];
        if (!tmp_vdev) {
            qdf_err("tmp_vdev is null");
            continue;
        }

        tmp_pdev = wlan_vdev_get_pdev(tmp_vdev);
        if (!tmp_pdev) {
            qdf_err("tmp_pdev is null");
            continue;
        }

        valid_link_mask |= BIT(ieee80211_mlo_get_pdev_hw_link_id(tmp_pdev));
    }

    if (ieee80211_mlo_release_vdev_list_refs(wlan_vdev_list,
            QDF_ARRAY_SIZE(wlan_vdev_list), vdev_count, 0) != QDF_STATUS_SUCCESS) {
        qdf_err("Failed to release the vdev reference");
        status = QDF_STATUS_E_FAILURE;
        goto free_ret;
    }

    if(t2lm->expected_duration_present) {
        link_update_params.hw_link_id_map = ((t2lm->hw_link_map_tid[0]) & valid_link_mask);
    } else {
        link_update_params.hw_link_id_map = valid_link_mask;
    }

    qdf_info("hw_link_id_map sent to the user space: 0x%x",link_update_params.hw_link_id_map);
    if (nla_put_u16(skb, QCA_WLAN_VENDOR_ATTR_TTLM_LINK_UPDATE_MLO_LINK_BITMAP,
        link_update_params.hw_link_id_map)) {
        qdf_err("%d: put failure", __LINE__);
        status = QDF_STATUS_E_FAILURE;
        goto free_ret;
    }

    qdf_mem_copy(link_update_params.ap_mld_addr, mld_addr, 6);
    if (nla_put(skb, QCA_WLAN_VENDOR_ATTR_TTLM_LINK_UPDATE_AP_MLD_ADDR, QDF_MAC_ADDR_SIZE,
        &link_update_params.ap_mld_addr[0])) {
        qdf_err("%d: put failure", __LINE__);
        status = QDF_STATUS_E_FAILURE;
        goto free_ret;
    }

    wlan_cfg80211_vendor_event(skb, GFP_ATOMIC);
    status = QDF_STATUS_SUCCESS;
    goto ret;

free_ret:
    qdf_err("Sending Link Unavailable event failed");
    if(skb)
        wlan_cfg80211_vendor_free_skb(skb);
ret:
    return status;
}
qdf_export_symbol(wlan_cfg80211_send_link_unavailable_update_event);

#endif

int send_ssid_event(struct wiphy *wiphy, struct wireless_dev *wdev, ieee80211_ssid *ssid)
{
    struct sk_buff *skb;
    int status = 0;

    skb = wlan_cfg80211_vendor_event_alloc(wiphy,
                                           wdev,
                                           NLMSG_HDRLEN + ((ssid->len + 1) * sizeof(u_int8_t)),
                                           QCA_NL80211_VENDOR_SUBCMD_UPDATE_SSID_INDEX,
                                           GFP_KERNEL);
    if (!skb) {
        qdf_err("%s: cfg80211_vendor_event_alloc failed", __func__);
        status = -ENOMEM;
        goto ret;
    }

    if (nla_put(skb, NL80211_ATTR_SSID, ssid->len + 1, ssid->ssid)) {
        qdf_err("%s: put fail", __func__);
        status = -EINVAL;
        goto free_ret;
    }
    wlan_cfg80211_vendor_event(skb, GFP_KERNEL);
    goto ret;

free_ret:
    qdf_info("%s: Sending SSID event failed", __func__);
    if(skb)
        wlan_cfg80211_vendor_free_skb(skb);
ret:
    return status;
}

int send_acs_event(wlan_if_t vap, cfg80211_hostapd_acs_params *cfg_acs_params,
                    uint8_t reason)
{
    struct sk_buff *skb;
    uint32_t channel_count = 0, status;
    uint32_t freq_list[NUM_CHANNELS] = {0};
    struct ieee80211com *ic;
    osif_dev *osif;
    struct net_device *dev;
    int band = 0;
    int phy_mode = 0;
    int cwidth = 0;
    bool chan_2_4ghz_found = false;
    bool chan_5ghz_found = false;
    bool chan_6ghz_found = false;
    bool normal_spectral_scan_support;
    struct wlan_objmgr_pdev *pdev;
    bool is_afc_capable = false;

    if (!vap) {
        qdf_err("vap is null");
        return -EINVAL;
    }

    if (!cfg_acs_params) {
        qdf_err("cfg_acs_params is NULL");
        return -EINVAL;
    }

    ic = vap->iv_ic;
    if (!ic) {
        qdf_err("ic is null");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;
    if (!pdev) {
        qdf_err("pdev is null");
        return -EINVAL;
    }

    osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    dev = osif->netdev;

    if (!osif_vap_event_filter_status_to_app(vap, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_UPDATE_EXTERNAL_ACS_CONFIG)) {
        return QDF_STATUS_SUCCESS;
    }
    skb = wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy,
                                           dev->ieee80211_ptr,
                                           EXTSCAN_EVENT_BUF_SIZE + NLMSG_HDRLEN,
                                           QCA_NL80211_VENDOR_SUBCMD_UPDATE_EXTERNAL_ACS_CONFIG,
                                           GFP_ATOMIC);
    if (!skb) {
        qdf_print("cfg80211_vendor_event_alloc failed");
        return -ENOMEM;
    }

    normal_spectral_scan_support =
        !wlan_pdev_nif_feat_ext_cap_get(pdev, WLAN_PDEV_FEXT_NORMAL_SPECTRAL_SCAN_DIS);
    phy_mode = cfg_acs_params->hw_mode;
    cwidth = cfg_acs_params->ch_width;
#ifdef CONFIG_AFC_SUPPORT
    is_afc_capable = ieee80211_is_afc_capable(ic, phy_mode);
#endif

    status = cfg80211_update_channel_info(skb, vap,
            QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_CHAN_INFO, freq_list,
            &channel_count, &chan_2_4ghz_found, &chan_5ghz_found,
            &chan_6ghz_found);
    if (status != 0)
        goto fail;

    /*
     * We currently send wlan_band_id until nl80211_band definitions are
     * available for 6 GHz. Also, we tentatively send a single band ID.
     */
    if (ieee80211_is_phymode_2g(phy_mode)) {
        if (!chan_2_4ghz_found) {
            qdf_err("The required PHY mode is in 2.4 GHz, but no 2.4 GHz channel found");
            goto fail;
        }

        band = WLAN_BAND_2GHZ;
    } else if (ieee80211_is_phymode_5g_or_6g(phy_mode)) {
        /*
         * Since a single band ID is sent tentatively, 6 GHz if present is given
         * preference over 5 GHz.
         */
        if (chan_6ghz_found) {
            band = WLAN_BAND_6GHZ;
        } else if (chan_5ghz_found) {
            band = WLAN_BAND_5GHZ;
        } else {
            qdf_err("The required PHY mode is in 5 GHz or 6 GHz, but no 5 or 6 GHz channel found");
            goto fail;
        }
    } else {
        qdf_err("The required PHY mode is in an unhandled band");
        goto fail;
    }

    qdf_info("external acs event params reason:%d spectral:%d offload:1"
             " chan stats:1 channel width:%d afc capable:%d", reason,
             normal_spectral_scan_support, cwidth, is_afc_capable);
    qdf_info("vapaddr:%x-%x-%x-%x-%x-%x",vap->iv_myaddr[0], vap->iv_myaddr[1], vap->iv_myaddr[2],
             vap->iv_myaddr[3], vap->iv_myaddr[4], vap->iv_myaddr[5]);
    qdf_info("band:%d phymode:%d", band, phy_mode);
    print_eacs_chanlist(freq_list, channel_count);

    /* Update values in NL buffer */
    if (nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_REASON,
               reason) ||
        nla_put_u8(skb,
        QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_IS_OFFLOAD_ENABLED,
               true) ||
        nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_ADD_CHAN_STATS_SUPPORT,
               true) ||
        nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_CHAN_WIDTH,
               cwidth) ||
        nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_BAND,
               band) ||
        nla_put_u32(skb, QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_PHY_MODE,
               phy_mode) ||
        nla_put(skb, QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_FREQ_LIST,
            channel_count * sizeof(uint32_t), freq_list) ||
        nla_put_u16(skb, QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_RROPAVAIL_INFO,
            QCA_WLAN_VENDOR_ATTR_RROPAVAIL_INFO_VSCAN_END)) {
        qdf_print("nla put fail");
        goto fail;
    }

    if (normal_spectral_scan_support && nla_put_flag(skb,
        QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_IS_SPECTRAL_SUPPORTED)) {
        qdf_err("nla put fail");
        goto fail;
    }

    if (is_afc_capable && nla_put_flag(skb,
        QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_EVENT_AFC_CAPABILITY)) {
        qdf_err("nla put fail");
        goto fail;
    }

    wlan_cfg80211_vendor_event(skb, GFP_ATOMIC);
    return 0;
fail:
    qdf_print("sending acs event failed %s",__func__);
    if (skb)
        wlan_cfg80211_vendor_free_skb(skb);
    return -EPERM;
}
static void wlan_check_mon_vap(struct wlan_objmgr_pdev *pdev, void *object,
                                  void *arg)
{
    struct ieee80211vap *tmpvap = NULL;
    struct wlan_objmgr_vdev *vdev = (struct wlan_objmgr_vdev *)object;
    uint8_t *mon_vap = (uint8_t *)arg;

    tmpvap = wlan_vdev_get_mlme_ext_obj(vdev);

    if (!tmpvap)
        return;

    if (tmpvap->iv_opmode == IEEE80211_M_MONITOR) {
        *mon_vap = 1;
    }
}

static bool wlan_check_acs_scan_or_report(wlan_if_t vap)
{

    uint8_t mon_vap = 0;
    struct ieee80211_ath_channel *channel = NULL;
    struct ieee80211com *ic = vap->iv_ic;

    if (!ic)
       return false;

    channel = vap->iv_des_chan[vap->iv_des_mode];
    wlan_objmgr_pdev_iterate_obj_list(ic->ic_pdev_obj, WLAN_VDEV_OP, wlan_check_mon_vap,
                                      &mon_vap, 0, WLAN_MLME_NB_ID);

    if (mon_vap && !ieee80211_get_num_active_vaps(ic)) {
       return true;
    } else if (ic->ic_sta_vap && ieee80211_vap_is_connected(ic->ic_sta_vap) && IEEE80211_IS_CHAN_VALID(ic->ic_curchan)) {
       *vap->iv_des_chan[vap->iv_des_mode] = *ic->ic_curchan;
       return false;
    } else if (!IEEE80211_IS_CHAN_VALID(channel)) {
       return true;
    } else {
       return false;
    }
}

#if UMAC_SUPPORT_ACS
/**
 * wlan_cfg80211_do_acs - ACS trigger command from hostapd.
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_do_acs(struct wiphy *wiphy,
                                struct wireless_dev *wdev,
                                const void *data,
                                int data_len)
{
    /* To get the link_id from caller for acs */
    struct ieee80211com *ic = NULL;

    osif_dev *osifp = NULL;
    wlan_if_t vap;
    cfg80211_hostapd_acs_params cfg_acs_params = {0};
    u_int8_t hw_mode = 0, link_id = 0xff;
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_ACS_MAX + 1];
    struct nlattr *nla;
    struct ieee80211_ath_channel *channel = NULL;


    if( wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_ACS_MAX,
                                data, data_len,
                                wlan_cfg80211_do_acs_policy)) {
        qdf_print("%s[%d] nla_parse failed  ", __func__,__LINE__);
        return -EINVAL;
    }

    /* Get channel list and copy to acs structure */
    nla = nla_find(data, data_len, QCA_WLAN_VENDOR_ATTR_ACS_CH_LIST);
    if(nla){
        cfg_acs_params.ch_list_len = nla_len(nla);
        if (cfg_acs_params.ch_list_len){
            cfg_acs_params.ch_list = qdf_mem_malloc(cfg_acs_params.ch_list_len);
            if (cfg_acs_params.ch_list){
                nla_memcpy((void*)cfg_acs_params.ch_list,attr[QCA_WLAN_VENDOR_ATTR_ACS_CH_LIST], cfg_acs_params.ch_list_len);
            }
        }
    }

    nla = nla_find(data, data_len, QCA_WLAN_VENDOR_ATTR_ACS_FREQ_LIST);
    if (nla) {
        cfg_acs_params.ch_list_len = nla_len(nla);
        if (cfg_acs_params.ch_list_len) {
            cfg_acs_params.freq_list = qdf_mem_malloc(cfg_acs_params.ch_list_len);
            if (cfg_acs_params.freq_list) {
                nla_memcpy((void*)cfg_acs_params.freq_list, attr[QCA_WLAN_VENDOR_ATTR_ACS_FREQ_LIST], cfg_acs_params.ch_list_len);
            }
            cfg_acs_params.ch_list_len = cfg_acs_params.ch_list_len / sizeof(uint32_t);
        }
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_ACS_LINK_ID]) {
        link_id = nla_get_u8(
                     attr[QCA_WLAN_VENDOR_ATTR_ACS_LINK_ID]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_ACS_HW_MODE]) {
        hw_mode = nla_get_u8(
                     attr[QCA_WLAN_VENDOR_ATTR_ACS_HW_MODE]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_ACS_HT_ENABLED]) {
        cfg_acs_params.ht_enabled = nla_get_flag(
                    attr[QCA_WLAN_VENDOR_ATTR_ACS_HT_ENABLED]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_ACS_HT40_ENABLED]) {
        cfg_acs_params.ht40_enabled = nla_get_flag(
                    attr[QCA_WLAN_VENDOR_ATTR_ACS_HT40_ENABLED]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_ACS_VHT_ENABLED]) {
        cfg_acs_params.vht_enabled = nla_get_flag(
                    attr[QCA_WLAN_VENDOR_ATTR_ACS_VHT_ENABLED]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_ACS_CHWIDTH]) {
        cfg_acs_params.ch_width = nla_get_u16(
                    attr[QCA_WLAN_VENDOR_ATTR_ACS_CHWIDTH]);
    }

    /* find the hw mode through parameters recevied */
    if(cfg_acs_params.vht_enabled){
       if(cfg_acs_params.ch_width == 160)
            cfg_acs_params.hw_mode = IEEE80211_MODE_11AC_VHT160;
       else if(cfg_acs_params.ch_width == 80)
            cfg_acs_params.hw_mode = IEEE80211_MODE_11AC_VHT80;
       else if(cfg_acs_params.ch_width == 20)
         cfg_acs_params.hw_mode = IEEE80211_MODE_11AC_VHT80;
    } else if(hw_mode == QCA_ACS_MODE_IEEE80211A){
            if(cfg_acs_params.ht40_enabled )
                cfg_acs_params.hw_mode = IEEE80211_MODE_11NA_HT40;
            else if(cfg_acs_params.ht_enabled)
                cfg_acs_params.hw_mode = IEEE80211_MODE_11NA_HT20;
            else
                cfg_acs_params.hw_mode = IEEE80211_MODE_11A;
    } else if (hw_mode == QCA_ACS_MODE_IEEE80211G){
            if(cfg_acs_params.ht40_enabled )
                cfg_acs_params.hw_mode = IEEE80211_MODE_11NG_HT40;
            else if(cfg_acs_params.ht_enabled)
                cfg_acs_params.hw_mode = IEEE80211_MODE_11NG_HT20;
            else
                cfg_acs_params.hw_mode = IEEE80211_MODE_11G;
    } else if (hw_mode == QCA_ACS_MODE_IEEE80211B){
        cfg_acs_params.hw_mode = IEEE80211_MODE_11B;
    } else if (hw_mode == QCA_ACS_MODE_IEEE80211ANY){
        cfg_acs_params.hw_mode = IEEE80211_MODE_AUTO;
    } else {
        qdf_print("%s[%d] Invalid ACS hw mode ", __func__,__LINE__);
        if (cfg_acs_params.ch_list){
            qdf_mem_free((void *)cfg_acs_params.ch_list);
        }
        if (cfg_acs_params.freq_list){
            qdf_mem_free((void *)cfg_acs_params.freq_list);
        }
        return -EINVAL;
    }

    osifp = get_vap_device_context(wiphy, wdev->netdev, link_id);
    if (!osifp) {
        qdf_err("NULL osifp\n");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("NULL vap\n");
        return -EINVAL;
    }

    ic = vap->iv_ic;
    if (NULL == ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cfg_acs_params.hw_mode = wlan_get_desired_phymode(vap);

    qdf_info("vap-%d(%s):ACS Params", vap->iv_unit,vap->iv_netdev_name);
    qdf_info("ht_enabled:%d|ht40_enabled:%d|vht_enabled:%d|hw_mode:%d|chwidth:%d|",
                    cfg_acs_params.ht_enabled, cfg_acs_params.ht40_enabled,
                    cfg_acs_params.vht_enabled, cfg_acs_params.hw_mode, cfg_acs_params.ch_width);

    if (ieee80211_ic_externalacs_enable_is_set(ic)) {
        /* set the deired mode for vap */
        vap->iv_des_mode = cfg_acs_params.hw_mode;
        /* If any VAP is active, the channel is already selected
         * so go ahead and init the VAP, the same channel will be used */
        if (ieee80211_vaps_active(vap->iv_ic)) {
            /* Set the curent channel to the VAP */
            struct ieee80211_ath_channel sel_chan_obj;
            wlan_chan_t sel_chan = &sel_chan_obj;
            int sel_ieee_chan_freq = 0;
            int error;
            struct chan_params chan_p = {0};
            *sel_chan = wlan_get_current_channel(vap, true);
            sel_ieee_chan_freq = wlan_channel_frequency(sel_chan);
            chan_p.freq = sel_ieee_chan_freq;
            chan_p.cfreq2 = sel_chan->ic_vhtop_freq_seg2;
            error = wlan_set_channel(vap, &chan_p);
            qdf_print("wlan_set_channel error code: %d", error);
            if (error !=0) {
                IEEE80211_DPRINTF(vap, IEEE80211_MSG_ACS,
                                  "%s : failed to set channel with error code %d\n",
                                  __func__, error);
                qdf_print("wlan_set_channel failed. error code : %d", error);
                if (cfg_acs_params.ch_list){
                    qdf_mem_free((void *)cfg_acs_params.ch_list);
                }
                if (cfg_acs_params.freq_list){
                    qdf_mem_free((void *)cfg_acs_params.freq_list);
                }
                 return -EINVAL;
            } else {
                qdf_print("Inheriting the channel from the active vap");
                wlan_cfg80211_acs_report_channel(vap, sel_chan);
            }
        } else {
            int ret = 0;
            /* No VAPs active */
            /* An external entity is responsible for
               Auto Channel Selection at VAP init
               time */
            if (ic->ext_acs_request_in_progress) {
                qdf_info("External channel selection was already requested on this radio");
                goto done;
            }

            ret = send_acs_event(vap, &cfg_acs_params, QCA_WLAN_VENDOR_ACS_SELECT_REASON_INIT);
            if (ret == 0) {
                qdf_print("External channel selection triggered");
                ic->ext_acs_request_in_progress = true;
            } else {
                qdf_print("sending acs event failed %s",__func__);
                if (cfg_acs_params.ch_list){
                    qdf_mem_free((void *)cfg_acs_params.ch_list);
                }
                if (cfg_acs_params.freq_list){
                    qdf_mem_free((void *)cfg_acs_params.freq_list);
                }
                 return -EINVAL;
            }
        }
    } else {
        channel = vap->iv_des_chan[vap->iv_des_mode];
        if (wlan_check_acs_scan_or_report(vap)) {
            wlan_cfg80211_start_acs_scan(vap, &cfg_acs_params);
        } else {
            wlan_cfg80211_acs_report_channel(vap, channel);
        }
    }

done:
    if (cfg_acs_params.ch_list){
        qdf_mem_free((void *)cfg_acs_params.ch_list);
    }
    if (cfg_acs_params.freq_list){
        qdf_mem_free((void *)cfg_acs_params.freq_list);
    }


    return 0;
}
#endif /* UMAC_SUPPORT_ACS */

/**
 * wlan_cfg80211_do_dcs_trigger - Send DCS trigger to external handler.
 * @vap: Handle for VAP structure
 * @interference_type: Interference type
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_do_dcs_trigger(wlan_if_t vap,
                                 uint32_t interference_type)
{
    struct ieee80211com *ic = NULL;
    cfg80211_hostapd_acs_params cfg_acs_params;
    enum ieee80211_phymode phymode;
    enum ieee80211_cwm_width ch_width;
    u_int8_t reason = 0;
    int ret = 0;

    if (NULL == vap) {
        qdf_err("vap is NULL");
        return -EINVAL;
    }

    ic = vap->iv_ic;
    if (NULL == ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    if (!ieee80211_ic_externalacs_enable_is_set(ic)) {
        /* As of now, this functionality is applicable only for external ACS */
        qdf_info("cfg80211 DCS trigger is currently applicable only for external ACS");
        return 0;
    }

    qdf_mem_set(&cfg_acs_params, sizeof(cfg_acs_params), 0);

    phymode = vap->iv_des_mode;
    ch_width = get_chwidth_phymode(phymode);

    cfg_acs_params.hw_mode = phymode;
    cfg_acs_params.ch_width = ieee80211_get_nl80211_chwidth(ch_width, phymode);

    if (ic->ext_acs_request_in_progress) {
        qdf_info("External channel selection was already requested on this radio");
        return 0;
    }

    switch (interference_type) {
        case CAP_DCS_WLANIM:
            reason = QCA_WLAN_VENDOR_ACS_SELECT_REASON_80211_INTERFERENCE;
            break;
        case CAP_DCS_CWIM:
            reason = QCA_WLAN_VENDOR_ACS_SELECT_REASON_CW_INTERFERENCE;
            break;
#ifdef CONFIG_AFC_SUPPORT
        case CAP_DCS_AFC:
            reason = QCA_WLAN_VENDOR_ACS_SELECT_REASON_AFC_TRIGGER;
            break;
#endif
        default:
            qdf_err("Interference type %u not currently valid",
                    interference_type);
            return -EINVAL;
    }

    ret = send_acs_event(vap, &cfg_acs_params, reason);
    if (ret == 0) {
        qdf_info("External channel selection for DCS triggered");
        ic->ext_acs_request_in_progress = true;
    } else {
        qdf_err("Sending acs event failed");
        return ret;
    }

    return 0;
}
qdf_export_symbol(wlan_cfg80211_do_dcs_trigger);

/* extract generic command params & send back them to caller */
static int extract_generic_command_params(struct wiphy *wiphy,
        const void *data, int data_len,
        struct wlan_cfg8011_genric_params *params)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_CONFIG_MAX + 1];

    if ((data == NULL) || (!data_len)) {
        qdf_print("%s: invalid data length data ptr: %pK ", __func__, data);
        return -1;
    }

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_CONFIG_MAX,
                                data, data_len,
                                wlan_cfg80211_setget_wificonfiguration_policy)) {
        qdf_err("Returning ...wlan_cfg80211_nla_parse fail");
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_COMMAND]) {
        params->command = nla_get_u32(
                attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_COMMAND]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_VALUE]) {
        params->value = nla_get_u32(
                attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_VALUE]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_DATA]) {
        params->data = nla_data(
                attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_DATA]);
        params->data_len = nla_len(attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_DATA]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_LENGTH]) {
        params->length = nla_get_u32(
                attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_LENGTH]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_FLAGS]) {
        params->flags = nla_get_u32(
                attr[QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_FLAGS]);
    }

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if (attr[QCA_WLAN_VENDOR_ATTR_CONFIG_MLO_LINK_ID]) {
        params->link_id = nla_get_u8(
                attr[QCA_WLAN_VENDOR_ATTR_CONFIG_MLO_LINK_ID]);
    } else
        params->link_id = INVALID_LINK_ID;

#else
    params->link_id = INVALID_LINK_ID;
#endif

    return 0;
}

/* extract vendor command params & send back them to caller */
static int extract_vendor_command_params(struct wiphy *wiphy,
        const void *data, int data_len,
        struct wlan_cfg8011_vendor_params *params)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_CONFIG_MAX + 1];

    if ((data == NULL) || (!data_len)) {
        qdf_err("%s: invalid data length data ptr: %pK ", __func__, data);
        return -1;
    }

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_CONFIG_MAX,
                                data, data_len,
                                wlan_cfg80211_setget_wificonfiguration_policy)) {
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_CONFIG_CHANNEL_WIDTH]) {
        params->puncture_bitmap = nla_get_u32(
                attr[QCA_WLAN_VENDOR_ATTR_CONFIG_CHANNEL_WIDTH]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_CONFIG_PHY_MODE]) {
        params->ccfs = nla_get_u32(
                attr[QCA_WLAN_VENDOR_ATTR_CONFIG_PHY_MODE]);
        params->mode_chan_command_type = params->ccfs;
    }

    return 0;
}

void wlan_cfg80211_dfs_cac_start(wlan_if_t vap, uint32_t timeout)
{
    struct sk_buff *vendor_event;
    int ret_val;
    struct ieee80211com *ic = vap->iv_ic;
    struct ieee80211_ath_channel *channel = ic->ic_curchan;
    osif_dev *osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    struct net_device *dev = osif->netdev;
    struct nlattr *nla;
    uint32_t ch_width;

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    if (!osif_vap_event_filter_status_to_app(vap, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_DFS_OFFLOAD_CAC_STARTED_INDEX)) {
        return;
    }
    vendor_event = wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, NULL,
                        6 * sizeof(uint32_t) + NLMSG_HDRLEN,
                        QCA_NL80211_VENDOR_SUBCMD_DFS_OFFLOAD_CAC_STARTED_INDEX,
                        qdf_mem_malloc_flags());
    if (!vendor_event) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "cfg80211_vendor_event_alloc failed");
        return;
    }

    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);

    ret_val = nla_put_u32(vendor_event,
            NL80211_ATTR_IFINDEX,
            dev->ifindex);
    if (ret_val) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "NL80211_ATTR_IFINDEX put fail");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }
    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);
    if(nla == NULL){
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "nla_nest_start fail nla is NULL");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }
    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);

    ret_val = nla_put_u32(vendor_event, NL80211_ATTR_WIPHY_FREQ,
                channel->ic_freq);
    if (ret_val) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "%s:%d NL80211_ATTR_WIPHY_FREQ put fail", __func__, __LINE__);
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    ret_val = nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_DATA,
                timeout);
    if (ret_val) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "%s:%d QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_DATA put fail", __func__, __LINE__);
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    if (IEEE80211_IS_CHAN_20MHZ(channel))
            ret_val = nla_put_u32(vendor_event, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
                        NL80211_CHAN_HT20);
    else if (IEEE80211_IS_CHAN_40PLUS(channel))
            ret_val = nla_put_u32(vendor_event, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
                        NL80211_CHAN_HT40PLUS);
    else if (IEEE80211_IS_CHAN_40MINUS(channel))
            ret_val = nla_put_u32(vendor_event, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
                        NL80211_CHAN_HT40MINUS);
    else
            ret_val = nla_put_u32(vendor_event, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
                        NL80211_CHAN_NO_HT);

    if (ret_val) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "%s:%d NL80211_ATTR_WIPHY_CHANNEL_TYPE put fail", __func__, __LINE__);
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }
    ch_width = ieee80211_get_chan_width(channel);
    ret_val = nla_put_u32(vendor_event, NL80211_ATTR_CHANNEL_WIDTH,
                ch_width);
    if (ret_val) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "%s:%d NL80211_ATTR_WIPHY_CHANNEL_TYPE put fail", __func__, __LINE__);
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    ret_val = nla_put_u32(vendor_event, NL80211_ATTR_CENTER_FREQ1,
                channel->ic_vhtop_ch_num_seg1);
    if (ret_val) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "%s:%d NL80211_ATTR_CENTER_FREQ1 put fail", __func__, __LINE__);
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    ret_val = nla_put_u32(vendor_event, NL80211_ATTR_CENTER_FREQ2,
                channel->ic_vhtop_ch_num_seg2);
    if (ret_val) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "%s:%d NL80211_ATTR_CENTER_FREQ2 put fail", __func__, __LINE__);
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    nla_nest_end(vendor_event, nla);
    wlan_cfg80211_vendor_event(vendor_event, qdf_mem_malloc_flags());
}
qdf_export_symbol(wlan_cfg80211_dfs_cac_start);

#ifdef CONFIG_AFC_SUPPORT
static int get_afc_evt_data_len(enum qca_wlan_vendor_afc_event_type event_type,
                                void *afc_data)
{
    uint32_t len = NLMSG_HDRLEN;
    struct wlan_afc_host_request *afc_req = NULL;
    struct wlan_afc_frange_list *afc_frange_list = NULL;
    uint8_t num_opclasses;
    struct wlan_afc_opclass_obj *afc_opclass_obj = NULL;
    struct wlan_afc_opclass_obj_list *afc_opclass_obj_lst = NULL;
    struct reg_fw_afc_power_event *pow_evt = NULL;
    struct afc_chan_obj *pow_evt_chan_info = NULL;
    int i = 0;

#define AFC_POWER_EVENT_BUFFER 500
/* AFC request buffer size computed in this API does not include the buffer
 * required by nested NL attributes and the buffer consumed by
 * __cfg80211_alloc_vendor_skb(). Hence adding an extra buffer size here.
 * Need to compute the exact buffer size needed and then allocate.
 */
#define AFC_REQUEST_BUFFER 200

    /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_TYPE */
    len += nla_total_size(sizeof(u8));

    switch(event_type) {
        case QCA_WLAN_VENDOR_AFC_EVENT_TYPE_EXPIRY:

            afc_req = (struct wlan_afc_host_request *)afc_data;
            len += /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_REQ_ID*/
                   nla_total_size(sizeof(u32)) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_AFC_WFA_VERSION
                    * Lower 16 bits
                    */
                   nla_total_size(sizeof(u16)) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_AFC_WFA_VERSION
                    * Higher 16 bits
                    */
                   nla_total_size(sizeof(u16)) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_MIN_DES_PWR */
                   nla_total_size(sizeof(u16));

            afc_frange_list = afc_req->freq_lst;
            len += /* QCA_WLAN_VENDOR_ATTR_AFC_FREQ_PSD_INFO_RANGE_START */
                   (nla_total_size(sizeof(u16)) * afc_frange_list->num_ranges) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_FREQ_PSD_INFO_RANGE_END */
                   (nla_total_size(sizeof(u16)) * afc_frange_list->num_ranges);

            afc_opclass_obj_lst = afc_req->opclass_obj_lst;
            num_opclasses = afc_opclass_obj_lst->num_opclass_objs;

            len += /* QCA_WLAN_VENDOR_ATTR_AFC_OPCLASS_INFO */
                   (nla_total_size(sizeof(u8)) *
                    num_opclasses);

            afc_opclass_obj = afc_opclass_obj_lst->opclass_objs;

            for (i = 0; i < num_opclasses; i++) {
                len += /* QCA_WLAN_VENDOR_ATTR_AFC_CHAN_EIRP_INFO_CHAN_NUM */
                       (nla_total_size(sizeof(u8)) *
                        afc_opclass_obj->opclass_num_cfis);

                afc_opclass_obj ++;
            }
            len = nla_total_size(len + AFC_REQUEST_BUFFER);
        break;

        case QCA_WLAN_VENDOR_AFC_EVENT_TYPE_POWER_UPDATE_COMPLETE:
            pow_evt = (struct reg_fw_afc_power_event *)afc_data;

            len += nla_total_size(
                   /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_REQ_ID */
                   nla_total_size(sizeof(u32)) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_STATUS_CODE */
                   nla_total_size(sizeof(u8)) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_SERVER_RESP_CODE */
                   nla_total_size(sizeof(u32)) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_AFC_WFA_VERSION */
                   nla_total_size(sizeof(u32)) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_EXP_DATE */
                   nla_total_size(sizeof(u32)) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_EVENT_EXP_TIME */
                   nla_total_size(sizeof(u32)));

            len += nla_total_size(
                   /* QCA_WLAN_VENDOR_ATTR_AFC_FREQ_PSD_INFO_RANGE_START */
                   (nla_total_size(sizeof(u16)) * pow_evt->num_freq_objs) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_FREQ_PSD_INFO_RANGE_END */
                   (nla_total_size(sizeof(u16)) * pow_evt->num_freq_objs) +
                   /* QCA_WLAN_VENDOR_ATTR_AFC_FREQ_PSD_INFO_PSD */
                   (nla_total_size(sizeof(u32)) * pow_evt->num_freq_objs));

            len += nla_total_size(
                   /* QCA_WLAN_VENDOR_ATTR_AFC_OPCLASS_INFO */
                   nla_total_size(sizeof(u8)) *  pow_evt->num_chan_objs);

            pow_evt_chan_info = pow_evt->afc_chan_info;
            for (i = 0; i < pow_evt->num_chan_objs; i++) {

                len += nla_total_size(
                       /* QCA_WLAN_VENDOR_ATTR_AFC_CHAN_EIRP_INFO_CHAN_NUM */
                       nla_total_size((nla_total_size(sizeof(u8)) *
                           pow_evt_chan_info[i].num_chans) +
                       /* QCA_WLAN_VENDOR_ATTR_AFC_CHAN_EIRP_INFO_EIRP */
                       (nla_total_size(sizeof(u32)) *
                           pow_evt_chan_info[i].num_chans)));

            }
            /* Add a buffer of 500 bytes to resolve issues with bigger
             * AFC responses. This is a temporary change and will be
             * refined to avoid adding buffer.
             */
            len = nla_total_size(len + AFC_POWER_EVENT_BUFFER);
        break;

        case QCA_WLAN_VENDOR_AFC_EVENT_TYPE_PAYLOAD_RESET:
            len = nla_total_size(len);
        break;

        default:
            qdf_err("Invalid AFC event type: %d", event_type);
            return -EINVAL;
        break;
    }

    return len;
}

static void afc_resp_ntoh_conv(u_int32_t *data, int data_len)
{
    int iter = 0;

    if (!data || !data_len) {
        qdf_err("Invalid AFC response");
        return;
    }

    for(iter = 0; iter < data_len; iter++) {
        /* Skip endian conversion for description field
         * in the AFC response as it is a char array.
         */
        if ((iter < QCA_WLAN_AFC_RESP_DESC_FIELD_START_OCTET) ||
                (iter > QCA_WLAN_AFC_RESP_DESC_FIELD_END_OCTET)) {
            data[iter] = ntohl(data[iter]);
        }
    }

    return;
}

static int wlan_cfg80211_afc_response(struct wiphy *wiphy,
                                      struct wireless_dev *wdev,
                                      const void *data,
                                      int data_len)
{
    struct cfg80211_context *cfg_ctx = NULL;
    struct ieee80211com *ic = NULL;
    struct wlan_objmgr_psoc *psoc = NULL;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
#else
    ic = cfg_ctx->ic;
#endif

    QDF_TRACE(QDF_MODULE_ID_AFC, QDF_TRACE_LEVEL_DEBUG,
        "%s: Received AFC response from user application", __func__);

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);

    wlan_cfg80211_vendor_afc_response(psoc,
                                      ic->ic_pdev_obj,
                                      data,
                                      data_len);

    return 0;
}

/**
 * wlan_cfg80211_afc_reset - AFC reset command from the user application
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: pointer to wlan_cfg8011_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
static int
wlan_cfg80211_afc_reset(struct wiphy *wiphy, struct wireless_dev *wdev,
                        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (ic == NULL) {
       qdf_err("Invalid Interface");
       return -EINVAL;
    }

    QDF_TRACE(QDF_MODULE_ID_AFC, QDF_TRACE_LEVEL_DEBUG,
              "%s: Received AFC Reset request from user application", __func__);
    ieee80211_send_afc_cmd(ic, REG_AFC_SERV_RESP_FORMAT_BINARY,
                           REG_AFC_CMD_RESET_AFC);

    return 0;
}

/**
 * wlan_cfg80211_afc_payload_reset - AFC payload command from the user application
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: pointer to wlan_cfg8011_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
static int
wlan_cfg80211_afc_payload_reset(struct wiphy *wiphy, struct wireless_dev *wdev,
                                struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    QDF_STATUS ret_val;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (ic == NULL) {
       qdf_err("Invalid Interface");
       return -EINVAL;
    }

    ret_val = ieee80211_send_afc_cmd(ic, REG_AFC_SERV_RESP_FORMAT_BINARY, REG_AFC_CMD_CLEAR_AFC_PAYLOAD);

    if (ret_val) {
        qdf_err("AFC Payload Reset Failed");
        return -EINVAL;
    } else {
        QDF_TRACE(QDF_MODULE_ID_AFC, QDF_TRACE_LEVEL_DEBUG,
                  "%s: Received AFC Payload Reset request from user application", __func__);
    }

    return 0;
}

static int wlan_cfg80211_get_dev_deployment_type(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    int ret = -EINVAL;
    struct ieee80211com *ic;
    enum reg_afc_dev_deploy_type reg_afc_dev_type;
    enum reg_6g_ap_type ap_pwr_type;
    uint8_t num_reg_power_rules[REG_CURRENT_MAX_AP_TYPE];
    void *cmd;
    int cmd_type;

    struct __get_dev_type_reply {
        uint32_t reg_afc_dev_type;
        uint8_t num_reg_power_rules[REG_CURRENT_MAX_AP_TYPE];
    } reply;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic || !ic->ic_pdev_obj) {
        qdf_err("Invalid interface");
        goto exit;
    }

    cmd = extract_command(ic, wdev, &cmd_type, 0);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type == RADIO_CMD) {
        qdf_err("Command received on invalid interface");
        goto exit;
    }

    /* Fetch device deployment type from Regulatory */
    ret = ieee80211_get_dev_deployment_type(ic->ic_pdev_obj, &reg_afc_dev_type);
    if (ret) {
        qdf_err("Get device deployment type failed");
        goto exit;
    }

    /* Fetch reg rules for each power type from Regulatory */
    for (ap_pwr_type = REG_INDOOR_AP; ap_pwr_type < REG_CURRENT_MAX_AP_TYPE; ap_pwr_type++) {
        num_reg_power_rules[ap_pwr_type] =
        wlan_reg_get_num_rules_of_ap_pwr_type(ic->ic_pdev_obj, ap_pwr_type);
    }

    /* Send reply to hostapd */
    reply.reg_afc_dev_type = reg_afc_dev_type;
    qdf_mem_copy(reply.num_reg_power_rules, num_reg_power_rules,
                 sizeof(num_reg_power_rules));
    ret = cfg80211_reply_command(wiphy, sizeof(struct __get_dev_type_reply),
                                 &reply, 0);

exit:
    if (ret > 0) {
        qdf_err("Error is positive (%d). Returning as negative", ret);
        ret = -ret;
    }

    return ret;
}

/**
 * wlan_cfg80211_send_reg_eirp_update - Update the EIRP values in reply skb
 *                                      and send in response to vendor command
 *                                      QCA_NL80211_VENDOR_SUBCMD_AFC_GET_REG_EIRP.
 * @wiphy: pointer to wireless wiphy structure.
 * @skb: SKB buffer to send back the response.
 * @eirp_list: EIRP power values updated from the regulatory component.
 */
static int wlan_cfg80211_send_reg_eirp_update(struct wiphy *wiphy,
                                        struct sk_buff *skb,
                                        struct channel_power *eirp_list)
{
    uint32_t buff_len = ((4 * NLMSG_HDRLEN) +
                        ((nla_total_size(sizeof(u16)) +
                         nla_total_size(sizeof(u8)) +
                         nla_total_size(sizeof(u32))) *
                        NUM_6GHZ_CHANNELS));
    int i, status = 0;
    struct nlattr *nla_attr;
    struct channel_power *eirp_info = eirp_list;

    skb = wlan_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, buff_len);

    if (!skb) {
        qdf_err("Reply skb alloc failed");
        return -ENOMEM;
    }

    /* Update all the data in reply buffer */
    nla_attr = nla_nest_start(skb, QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_UPDATE_CENTER_FREQ);
    if (!nla_attr) {
        goto fail;
    }

    for (i = 0; i < NUM_6GHZ_CHANNELS; i++) {
        if (!eirp_info)
            goto fail;

        if (nla_put_u16(skb, i, eirp_info->center_freq))
            goto fail;

        eirp_info = eirp_list++;
    }

    nla_nest_end(skb, nla_attr);

    nla_attr = nla_nest_start(skb,
                        QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_UPDATE_CHAN_NUM);
    if (!nla_attr) {
        goto fail;
    }

    for (i = 0; i < NUM_6GHZ_CHANNELS; i++) {
        if (!eirp_info)
            goto fail;

        if (nla_put_u16(skb, i, eirp_info->chan_num))
            goto fail;

        eirp_info = eirp_list++;
    }

    nla_nest_end(skb, nla_attr);

    nla_attr = nla_nest_start(skb,
                        QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_UPDATE_TX_POWER);
    if (!nla_attr) {
        goto fail;
    }

    for (i = 0; i < NUM_6GHZ_CHANNELS; i++) {

        if (!eirp_info)
            goto fail;

        if (nla_put_u16(skb, i, eirp_info->tx_power))
            goto fail;

        eirp_info = eirp_list++;
    }

    nla_nest_end(skb, nla_attr);

    /* Send the response to user space */
    status = wlan_cfg80211_qal_devcfg_send_response((qdf_nbuf_t)skb);

    return status;

fail:
    wlan_cfg80211_vendor_free_skb(skb);
    return -EINVAL;
}
/**
 * wlan_cfg80211_get_afc_reg_eirp - AFC command from user application to
 *                                  retrieve Regulatory EIRP limits.
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_get_afc_reg_eirp(struct wiphy *wiphy,
                                          struct wireless_dev *wdev,
                                          const void *data,
                                          int data_len)
{
    struct ieee80211com *ic = NULL;
    uint8_t pwr_type = 0, client_type = 0;
    bool is_client_needed = false;
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_MAX + 1];
    int pdev_id;
    int ret_val = 0;
    struct sk_buff *skb;
    struct channel_power *chan_eirp_list =
                            qdf_mem_malloc(sizeof(struct channel_power) *
                                            NUM_6GHZ_CHANNELS);

    if (chan_eirp_list == NULL) {
        qdf_err("Buffer allocation failed");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    QDF_TRACE(QDF_MODULE_ID_AFC, QDF_TRACE_LEVEL_DEBUG,
              "%s: Received AFC Regulatory EIRP power request from user"
              "application", __func__);

    pdev_id = wlan_objmgr_pdev_get_pdev_id(ic->ic_pdev_obj);
    if ((data == NULL) || (!data_len)) {
        qdf_err("Invalid data length data ptr: %pK ", data);
        goto err;
    }

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_MAX,
                                data, data_len,
                                wlan_cfg80211_afc_reg_eirp_policy)) {
        qdf_err("Error parsing NL attributes");
        goto err;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_POWER_TYPE]) {
        pwr_type = nla_get_u8(
                attr[QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_POWER_TYPE]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_CLIENT_TYPE]) {
        client_type = nla_get_u8(
                attr[QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_CLIENT_TYPE]);
    }

    is_client_needed = (client_type < QCA_WLAN_VENDOR_AFC_CLIENT_TYPE_MAX) ?
                            true : false;

    if (wlan_reg_get_max_reg_eirp_from_list(ic->ic_pdev_obj, pwr_type,
                                        is_client_needed, client_type,
                                        chan_eirp_list, NUM_6GHZ_CHANNELS) < 0) {
        qdf_err("Error is retrieving Regulatory EIRP data");
        goto err;
    }

    ret_val = wlan_cfg80211_send_reg_eirp_update(wiphy, skb, chan_eirp_list);
    if (ret_val < 0) {
        qdf_err("Reg EIRP update to user space failed");
    }

    return ret_val;

err:
    qdf_mem_free(chan_eirp_list);
    return -EINVAL;
}
#endif /* CONFIG_AFC_SUPPORT */

static int wlan_cfg80211_addmac(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s :%s \n", __func__, ether_sprintf(mac));

    ret = wlan_set_acl_add(vap, mac, IEEE80211_ACL_FLAG_ACL_LIST_1);

#if QCA_SUPPORT_ACL_IMMEDIATE
    if (ret == EOK && (vap->iv_acl_immediate & IEEE80211_ACL_FLAG_ACL_LIST_1))
        ret = wlan_acl_scrutinize_macs_for_policy(vap, mac,
                IEEE80211_ACL_FLAG_ACL_LIST_1, IEEE80211_ACL_IMMEDIATE_ACTION_ADDMAC);
#endif /* QCA_SUPPORT_ACL_IMMEDIATE */

    return ret;
}

static int wlan_cfg80211_delmac(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s :%s \n", __func__, ether_sprintf(mac));
    ret = wlan_set_acl_remove(vap, mac, IEEE80211_ACL_FLAG_ACL_LIST_1);

#if QCA_SUPPORT_ACL_IMMEDIATE
    if (ret == EOK && (vap->iv_acl_immediate & IEEE80211_ACL_FLAG_ACL_LIST_1))
        ret = wlan_acl_scrutinize_macs_for_policy(vap, mac,
                IEEE80211_ACL_FLAG_ACL_LIST_1, IEEE80211_ACL_IMMEDIATE_ACTION_DELMAC);
#endif /* QCA_SUPPORT_ACL_IMMEDIATE */

    return ret;
}

#if WLAN_DFS_CHAN_HIDDEN_SSID
static int wlan_cfg80211_conf_bssid(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s :%s \n", __func__, ether_sprintf(mac));

    ret = ieee80211_set_conf_bssid(vap,mac);

    return ret;
}

static int wlan_cfg80211_get_conf_bssid(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("NULL cmd\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    qdf_mem_copy(&mac, vap->iv_conf_des_bssid, QDF_MAC_ADDR_SIZE);
    cfg80211_reply_command(wiphy, QDF_MAC_ADDR_SIZE, &mac, 0);

    return 0;
}
#endif /* WLAN_DFS_CHAN_HIDDEN_SSID */

#if ATH_ACL_SOFTBLOCKING
static int wlan_cfg80211_addmac_sec(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s :%s \n", __func__, ether_sprintf(mac));

    ret = wlan_set_acl_add(vap, mac, IEEE80211_ACL_FLAG_ACL_LIST_2);

#if QCA_SUPPORT_ACL_IMMEDIATE
    if (ret == EOK && (vap->iv_acl_immediate & IEEE80211_ACL_FLAG_ACL_LIST_2))
        ret = wlan_acl_scrutinize_macs_for_policy(vap, mac,
                IEEE80211_ACL_FLAG_ACL_LIST_2, IEEE80211_ACL_IMMEDIATE_ACTION_ADDMAC);
#endif /* QCA_SUPPORT_ACL_IMMEDIATE */

    return ret;
}

static int wlan_cfg80211_delmac_sec(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s :%s \n", __func__, ether_sprintf(mac));
    ret = wlan_set_acl_remove(vap, mac, IEEE80211_ACL_FLAG_ACL_LIST_2);

#if QCA_SUPPORT_ACL_IMMEDIATE
    if (ret == EOK && (vap->iv_acl_immediate & IEEE80211_ACL_FLAG_ACL_LIST_2))
        ret = wlan_acl_scrutinize_macs_for_policy(vap, mac,
                IEEE80211_ACL_FLAG_ACL_LIST_2, IEEE80211_ACL_IMMEDIATE_ACTION_DELMAC);
#endif /* QCA_SUPPORT_ACL_IMMEDIATE */

    return ret;
}

static int wlan_cfg80211_get_aclmac_sec(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    osif_dev *osifp = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    u_int8_t *mac_list;
    int i, rc, num_mac;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        vap = (wlan_if_t)cmd;
    }

    /* read and send mac list to application */
    mac_list = (u_int8_t *)OS_MALLOC(osifp->os_handle,
            (QDF_MAC_ADDR_SIZE * 256), GFP_KERNEL);
    if (!mac_list) {
        return -EFAULT;
    }
    rc = wlan_get_acl_list(vap, mac_list, (QDF_MAC_ADDR_SIZE * 256),
            &num_mac, IEEE80211_ACL_FLAG_ACL_LIST_2);
    if(rc) {
        OS_FREE(mac_list);
        return -EFAULT;
    }

    for (i = 0; i < num_mac && i < 256; i++) {
        memcpy(&mac, &mac_list[i * QDF_MAC_ADDR_SIZE], QDF_MAC_ADDR_SIZE);
        cfg80211_reply_command(wiphy, QDF_MAC_ADDR_SIZE, &mac, 0);
    }
    OS_FREE(mac_list);
    return 0;
}
#endif

/*
 * wlan_cfg80211_check_11hcap: Checks a connected station for 802.11h
 * spectrum management capability using the concerned station's
 * MAC address as the input value.
 *
 * @wiphy: Pointer to wiphy structure
 * @wdev: Pointer to wireless_dev structure
 * @params: Pointer to the parameters sent from the cfg80211tool command
 *
 * Return: 0 is successful
 */

static int wlan_cfg80211_check_11hcap(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
        struct ieee80211com *ic = NULL;
        wlan_if_t vap = NULL;
        int cmd_type;
        void *cmd;
        u_int8_t mac[QDF_MAC_ADDR_SIZE];
        struct ieee80211_node *ni;
        bool spectrum_management_en;

        ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

        if (!ic) {
            qdf_err("ic NULL");
            return -EINVAL;
        }

        cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

        if (!cmd) {
            qdf_err("cmd is NULL\n");
            return -EINVAL;
        }

        if (cmd_type) {
                qdf_print("Command on Invalid Interface");
                return -EINVAL;
        }
        vap = (wlan_if_t)cmd;

        if (params->data_len != QDF_MAC_ADDR_SIZE) {
                qdf_print("Invalid MAC Address");
                return -EINVAL;
        }
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

        ni = ieee80211_vap_find_node(vap, mac, WLAN_MLME_SB_ID);
        if (ni == NULL) {
                qdf_print("MAC Address not found");
                return  -EINVAL;
        }

        spectrum_management_en = (ni->ni_capinfo & IEEE80211_CAPINFO_SPECTRUM_MGMT) ? true : false;
        cfg80211_reply_command(wiphy, sizeof(spectrum_management_en), &spectrum_management_en, 0);
        ieee80211_free_node(ni, WLAN_MLME_SB_ID);

        return 0;
}

static int wlan_cfg80211_add_sta_node(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    /* Get link id for this handler, for now using link_id as 0*/
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_PARAM_MAX + 1];
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type = 0;
    void *cmd = NULL;
    uint8_t *mac_addr = NULL, auth_algo = 0;
    bool is_ml = false;
    uint8_t node_created;
    const uint8_t hold_ref = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (ic == NULL) {
        qdf_err("Invalid Interface");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, 0);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Command on Invalid Interface");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if (wlan_cfg80211_nla_parse(attr,
                                QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_PARAM_MAX,
                                data, data_len,
                                qca_wlan_vendor_add_sta_node_attr)) {
        return -EINVAL;
    }


    /* Extracting MAC Address */
    if (!attr[QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_MAC_ADDR]) {
        qdf_err("Mac Address attribute is not present");
        return -EINVAL;
    }
    mac_addr = nla_data(
            attr[QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_MAC_ADDR]);

    if (attr[QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_AUTH_ALGO]) {
        auth_algo = nla_get_u16(
            attr[QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_AUTH_ALGO]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_IS_ML]) {
        is_ml = nla_get_u16(
            attr[QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_IS_ML]);
    }
    wlan_add_sta_node(vap, mac_addr, hold_ref, &node_created, is_ml, auth_algo);
    return 0;
}

static int wlan_cfg80211_send_egid(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_SEND_EGID_MAX + 1];
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type, ret = 0;
    void *cmd;
    uint32_t egid_data[ESL_EGID_INFO_MAX_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, 0);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_info("Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }
    if (wlan_cfg80211_nla_parse(attr,
                                QCA_WLAN_VENDOR_ATTR_SEND_EGID_MAX,
                                data, data_len,
                                qca_wlan_vendor_send_egid_attr)) {
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SEND_EGID_1] && attr[QCA_WLAN_VENDOR_ATTR_SEND_EGID_2] && attr[QCA_WLAN_VENDOR_ATTR_SEND_EGID_3] && attr[QCA_WLAN_VENDOR_ATTR_SEND_EGID_4]) {
		egid_data[0] = nla_get_u32(
                           attr[QCA_WLAN_VENDOR_ATTR_SEND_EGID_1]);
		qdf_info("EGID data[0] is  0x%x ", egid_data[0]);
		egid_data[1] = nla_get_u32(
                           attr[QCA_WLAN_VENDOR_ATTR_SEND_EGID_2]);
		qdf_info("EGID data[1] is  0x%x ", egid_data[1]);
		egid_data[2] = nla_get_u32(
                           attr[QCA_WLAN_VENDOR_ATTR_SEND_EGID_3]);
		qdf_info("EGID data[2] is  0x%x ", egid_data[2]);
		egid_data[3] = nla_get_u32(
                           attr[QCA_WLAN_VENDOR_ATTR_SEND_EGID_4]);
		qdf_info("EGID data[3] is  0x%x ", egid_data[3]);
    } else {
        return -EINVAL;
    }
    if ( ic->ic_cfg80211_radio_handler.send_egid_info ) {
       ret = ic->ic_cfg80211_radio_handler.send_egid_info(scn, egid_data);
    } else {
         ret = -EOPNOTSUPP;
    }
    return ret;
}

static int wlan_cfg80211_son_reg_params(struct wiphy *wiphy,
                             struct wireless_dev *wdev,
                             const void *data,
                             int data_len)
{
    uint8_t num_supp_op_class = 0, chan_num = 0, opclass = 0;
    int tx_power;
    uint8_t *opclass_list;
    struct ieee80211com *ic;
    wlan_if_t vap;
    int cmd_type;
    void *cmd;
    struct wlan_cfg8011_genric_params generic_params;

    qdf_mem_zero(&generic_params, sizeof(generic_params));
    extract_generic_command_params(wiphy, data, data_len, &generic_params);

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, generic_params.link_id);

    if (ic == NULL) {
       qdf_err("Invalid Interface");
       return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, generic_params.link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
       qdf_err("Command on Invalid Interface");
       return -EINVAL;
    }

    vap = (wlan_if_t)cmd;
    if ((data == NULL) || (!data_len)) {
       qdf_err("%s: Invalid data length data ptr: %pK ", __func__, data);
       return - EINVAL;
    }

    opclass_list = qdf_mem_malloc(sizeof(*opclass_list)*
                        REG_MAX_SUPP_OPER_CLASSES);
    if (!opclass_list) {
      qdf_err("Opclass_list not allocated");
      return -EINVAL;
    }

    wlan_pdev_get_supp_opclass_list(ic->ic_pdev_obj, opclass_list,
           &num_supp_op_class, true);
    wlan_vdev_get_curr_chan_and_opclass(vap->vdev_obj,&chan_num,
                               &opclass);
    tx_power = wlan_pdev_get_current_chan_txpower(ic->ic_pdev_obj);

    switch(generic_params.command) {
        case QCA_NL80211_SON_REG_PARAMS_NUM_OPCLASS:
             cfg80211_reply_command(wiphy, sizeof(uint8_t),&num_supp_op_class, 0);
             break;
        case QCA_NL80211_SON_REG_PARAMS_CURR_CHAN_NUM:
             cfg80211_reply_command(wiphy, sizeof(uint8_t),&chan_num, 0);
             break;
        case QCA_NL80211_SON_REG_PARAMS_CURR_OPCLASS_TXPOWER:
             cfg80211_reply_command(wiphy, sizeof(int),&tx_power, 0);
             break;
        case QCA_NL80211_SON_REG_PARAMS_OP_CLASS_LIST:
             cfg80211_reply_command(wiphy,
         sizeof(uint8_t)*REG_MAX_SUPP_OPER_CLASSES, opclass_list, 0);
             break;
    }
    qdf_mem_free(opclass_list);
    return 0;

}

/**
 * wlan_cfg80211_set_qdepth_thresh_cb: cfg80211 API to set the MSDU
 * queue depth threshold per TID per peer
 * @wiphy: wiphy pointer
 * @wdev: wireless_dev pointer
 * @params: parameters sent from the cfg80211tool command
 */

static int wlan_cfg80211_set_qdepth_thresh_cb(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    /* Need link_id, now using 0 */
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type = 0;
    void *cmd = NULL;
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_CONFIG_MAX + 1];
    uint8_t *mac_addr = NULL;
    uint32_t tid = 0, update_mask = 0, thresh_val = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (ic == NULL) {
        qdf_print("Invalid Interface");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, 0);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Command on Invalid Interface");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if ((data == NULL) || (!data_len)) {
        qdf_print("%s: Invalid data length data ptr: %pK ", __func__, data);
        return - EINVAL;
    }

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_MAX,
                                data, data_len,
                                wlan_cfg80211_set_qdepth_thresh_policy)) {
        return -EINVAL;
    }

    /* Extracting MAC Address */
    if(attr[QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_MAC_ADDR]) {
        mac_addr = nla_data(
                       attr[QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_MAC_ADDR]);
    }

    /* Extracting TID */
    if(attr[QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_TID]) {
        tid = nla_get_u32(
                  attr[QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_TID]);
    }

    /* Extracting Update Mask */
    if(attr[QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_UPDATE_MASK]) {
      update_mask = nla_get_u32(
                        attr[QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_UPDATE_MASK]);
    }

    /* Extracting Threshold Value */
    if(attr[QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_VALUE]) {
        thresh_val = nla_get_u32(
                         attr[QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_VALUE]);
    }

    ic->ic_vap_set_qdepth_thresh(vap, mac_addr, tid, update_mask, thresh_val);
    return 0;
}

/*
 * wlan_cfg80211_enable_sounding_int:
 * Enables/Disables TXBF sounding interval
 */
static int wlan_cfg80211_enable_sounding_int(struct wiphy *wiphy,
                struct wireless_dev *wdev,
                struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type, retval = 0;
    void *cmd;
    uint8_t mac[QDF_MAC_ADDR_SIZE];
    struct ieee80211_node *ni;
    uint32_t enable;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Command on Invalid Interface");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if(params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_print("Invalid MAC Address!");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    ni = ieee80211_vap_find_node(vap, mac, WLAN_MLME_SB_ID);
    if (ni == NULL) {
        qdf_print("MAC Address Not Found!");
        return -EINVAL;
    }

    enable = !!params->value;

    retval = ic->ic_node_enable_sounding_int(ni, enable);
    ieee80211_free_node(ni, WLAN_MLME_SB_ID);

    return retval;

}

/*
 * wlan_cfg80211_set_su_sounding_int:
 * Sets the single-user txbf sounding interval
 */
static int wlan_cfg80211_set_su_sounding_int(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;

    wlan_if_t vap = NULL;
    int cmd_type, retval = 0;
    void *cmd;
    uint8_t mac[QDF_MAC_ADDR_SIZE];
    struct ieee80211_node *ni;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Command on Invalid Interface");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if(params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_err("Invalid MAC Address!");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    ni = ieee80211_vap_find_node(vap, mac, WLAN_MLME_SB_ID);
    if (ni == NULL) {
        qdf_print("MAC Address Not Found!");
        return -EINVAL;
    }

    retval = ic->ic_node_set_su_sounding_int(ni, params->value);
    ieee80211_free_node(ni, WLAN_MLME_SB_ID);

    return retval;

}

/*
 * wlan_cfg80211_set_mu_sounding_int:
 * Sets the multi-user TXBF sounding interval
 */
static int wlan_cfg80211_set_mu_sounding_int(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;

    wlan_if_t vap = NULL;
    int cmd_type, retval = 0;
    void *cmd;
    uint8_t mac[QDF_MAC_ADDR_SIZE];
    struct ieee80211_node *ni;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Command on Invalid Interface");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if(params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_print("Invalid MAC Address!");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    ni = ieee80211_vap_find_node(vap, mac, WLAN_MLME_SB_ID);
    if (ni == NULL) {
        qdf_print("MAC Address Not Found!");
        return -EINVAL;
    }

    retval = ic->ic_node_set_mu_sounding_int(ni, params->value);
    ieee80211_free_node(ni, WLAN_MLME_SB_ID);

    return retval;

}

/*
 * wlan_cfg80211_sched_mu_enable:
 * Enables/Disables the scheduler API and stats for MU
 */
static int wlan_cfg80211_sched_mu_enable(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;

    wlan_if_t vap = NULL;
    int cmd_type, retval = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    struct ieee80211_node *ni;
    uint32_t enable;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Command on Invalid Interface");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if (params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_print("Invalid MAC Address");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    ni = ieee80211_vap_find_node(vap, mac, WLAN_MLME_SB_ID);
    if (ni == NULL) {
        qdf_print("MAC Address not found");
        return  -EINVAL;
    }

    enable = !!params->value;

    retval = ic->ic_node_sched_mu_enable(ni, enable);
    ieee80211_free_node(ni, WLAN_MLME_SB_ID);

    return retval;
}

/*
 * wlan_cfg80211_sched_ofdma_enable:
 * Enables/Disables the scheduler API and stats for ofdma
 */
static int wlan_cfg80211_sched_ofdma_enable(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;

    wlan_if_t vap = NULL;
    int cmd_type, retval = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    struct ieee80211_node *ni;
    uint32_t enable;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Command on Invalid Interface");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if (params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_print("Invalid MAC Address");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    ni = ieee80211_vap_find_node(vap, mac, WLAN_MLME_SB_ID);
    if (ni == NULL) {
        qdf_print("MAC Address not found");
        return  -EINVAL;
    }

    enable = !!params->value;

    retval = ic->ic_node_sched_ofdma_enable(ni, enable);
    ieee80211_free_node(ni, WLAN_MLME_SB_ID);

    return retval;
}

static int wlan_cfg80211_set_ulofdma_rtd(struct wiphy *wiphy,
         struct wireless_dev *wdev,
         struct wlan_cfg8011_genric_params *params)
{
     struct cfg80211_context *cfg_ctx = NULL;
     struct ieee80211com *ic = NULL;
     wlan_if_t vap = NULL;
     int cmd_type, retval = 0;
     void *cmd;
     uint8_t mac[QDF_MAC_ADDR_SIZE];
     struct ieee80211_node *ni;

     cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
     if (cfg_ctx == NULL) {
         qdf_err("Invalid Context");
         return -EINVAL;
     }

     ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

     if (ic == NULL) {
         qdf_err("Invalid Interface");
         return -EINVAL;
     }

     cmd = extract_command(ic, wdev, &cmd_type, params->link_id);
     if (!cmd) {
         qdf_err("cmd is NULL");
         return -EINVAL;
     }

     if (cmd_type) {
         qdf_err("Command on Invalid Interface");
         return -EINVAL;
     }

     vap = (wlan_if_t)cmd;
     if (!vap) {
         qdf_err("vap is NULL");
         return -EINVAL;
     }

     if(params->data_len != QDF_MAC_ADDR_SIZE) {
         qdf_err("Invalid MAC Address!");
         return -EINVAL;
     }
     qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

     ni = ieee80211_vap_find_node(vap, mac, WLAN_MLME_SB_ID);
     if (ni == NULL) {
         qdf_err("MAC Address Not Found!");
         return -EINVAL;
     }

     if(params->value > 600 || params->value < 0) {
         qdf_err("Invalid value. Supported range is 0 to 600");
         ieee80211_free_node(ni, WLAN_MLME_SB_ID);
         return -EINVAL;
     }

     retval = ic->ic_node_ulofdma_rtd(ni, params->value);
     ieee80211_free_node(ni, WLAN_MLME_SB_ID);

     return retval;

}

#if OBSS_PD
static int wlan_cfg80211_get_he_srg_bitmap(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define HE_SRG_BITMAP_ARGS      2
#define HE_SRG_BITMAP_STRING    20
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    uint32_t srg_field;
    int ret = -EOPNOTSUPP;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    uint32_t val[HE_SRG_BITMAP_ARGS] = {0};
    char str[HE_SRG_BITMAP_STRING];

    if (!params) {
        qdf_err("params is null");
        return -EINVAL;
    }

    srg_field = params->value;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (ic->ic_wdev.netdev == wdev->netdev) {
        scn = get_radio_device_context(wiphy, wdev->netdev);
        if ( ic->ic_cfg80211_radio_handler.get_he_srg_bitmap)
            ret = ic->ic_cfg80211_radio_handler.get_he_srg_bitmap(
                                            (void *)scn, val, srg_field);
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        if (!osifp) {
            qdf_err("osifp is NULL\n");
            return -EINVAL;
        }
        vap = osifp->os_if;
        if (!vap) {
            qdf_err("%s: VAP is null ", __func__);
            return -1;
        }
        if (ic->ic_vap_get_he_srg_bitmap)
            ret = ic->ic_vap_get_he_srg_bitmap(vap, val, srg_field);
    }

    if(!ret) {
        switch(srg_field)
        {
            case HE_SRP_IE_SRG_BSS_COLOR_BITMAP:
                snprintf(str, HE_SRG_BITMAP_STRING,
                    "0x%08X %08X", val[1], val[0]);
            break;

            case HE_SRP_IE_SRG_PARTIAL_BSSID_BITMAP:
                snprintf(str, HE_SRG_BITMAP_STRING,
                    "0x%08X %08X", val[1], val[0]);
            break;

            default:
                qdf_err("Unsupported Command");
            break;
        }

        return cfg80211_reply_command(wiphy, sizeof(str), str, 0);
    }

    return ret;
}

static int wlan_cfg80211_set_he_srg_bitmap(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    uint32_t srg_field;
    int ret = -EOPNOTSUPP;
    uint32_t data;
    uint32_t val[2] = {0};
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;

    if (!params) {
        qdf_err("params is null");
        return -EINVAL;
    }

    if(params->data == NULL) {
        qdf_err("Invalid Arguments ");
        return -EINVAL;
    }
    data = *(uint32_t *)params->data;
    srg_field = params->value;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (ic == NULL) {
        qdf_err("Invalid Interface");
        return -EINVAL;
    }

    val[0] = params->length;
    val[1] = data;

    if (ic->ic_wdev.netdev == wdev->netdev) {
        scn = get_radio_device_context(wiphy, wdev->netdev);
        if (ic->ic_cfg80211_radio_handler.set_he_srg_bitmap)
            ret = ic->ic_cfg80211_radio_handler.set_he_srg_bitmap(
                                            (void *)scn, val, srg_field);
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        if (!osifp) {
            qdf_err("osifp NULL\n");
            return -EINVAL;
        }
        vap = osifp->os_if;
        if (!vap) {
            qdf_err("%s: VAP is null ", __func__);
            return -1;
        }
        if (ic->ic_vap_set_he_srg_bitmap)
            ret = ic->ic_vap_set_he_srg_bitmap(vap, val, srg_field);
    }

    if (!ret) {
        switch(srg_field) {
            case HE_SRP_IE_SRG_BSS_COLOR_BITMAP:
                qdf_info("%s: SRG Color Bitmap: 0x%08X %08X",
                        __func__, val[1], val[0]);
            break;
            case HE_SRP_IE_SRG_PARTIAL_BSSID_BITMAP:
                qdf_info("%s: SRG Partial BSSID Bitmap: 0x%08X %08X",
                        __func__, val[1], val[0]);
            break;
            default:
                qdf_err("Unsupported Command");
            break;
        }
    }

    return ret;
}

static int wlan_cfg80211_sr_self_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic           = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;

    if(params->data == NULL) {
        qdf_info("Invalid Arguments");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (ic->ic_wdev.netdev == wdev->netdev) {
        scn = get_radio_device_context(wiphy, wdev->netdev);
        if (ic->ic_cfg80211_radio_handler.set_sr_self_config)
            return ic->ic_cfg80211_radio_handler.set_sr_self_config(
                                   (void *)scn, params->value, params->data,
                                   params->data_len, params->length, params->flags);
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        if (!osifp) {
            qdf_err("osifp NULL\n");
            return -EINVAL;
        }
        vap = osifp->os_if;
        if (vap == NULL) {
            qdf_err("%s: VAP is null ", __func__);
            return -1;
        }
        if (ic->ic_vap_set_self_sr_config)
            return ic->ic_vap_set_self_sr_config(
	    		        vap, params->value, params->data,
	    		        params->data_len, params->length);
    }
    return -EOPNOTSUPP;
}

static int wlan_cfg80211_get_sr_self_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define SELF_SR_CONFIG_SIZE 64
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int ret = -EOPNOTSUPP;
    char value[SELF_SR_CONFIG_SIZE] = {0};
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (ic->ic_wdev.netdev == wdev->netdev) {
        scn = get_radio_device_context(wiphy, wdev->netdev);
        if (ic->ic_cfg80211_radio_handler.get_sr_self_config)
            ret = ic->ic_cfg80211_radio_handler.get_sr_self_config(
                                                (void *)scn, params->value,
                                                value, sizeof(value));
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        if (!osifp) {
            qdf_err("osifp NULL\n");
            return -EINVAL;
        }
        vap = osifp->os_if;
        if (vap == NULL) {
            qdf_err("%s: VAP is null ", __func__);
            return -EINVAL;
        }
        if (ic->ic_vap_get_self_sr_config)
            ret = ic->ic_vap_get_self_sr_config(
	    		        vap, params->value, value, sizeof(value));
    }

    if (!ret)
        return cfg80211_reply_command(wiphy, strlen(value), value, 0);

    return ret;
}
#endif /* OBSS PD */

static int wlan_cfg80211_get_he_mesh_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define HE_MESH_CONFIG_STRING 20
#define HE_MESH_CONFIG_ARGS 2
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    int val[HE_MESH_CONFIG_ARGS] = {0};
    char string[HE_MESH_CONFIG_STRING];
    uint8_t subcmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    subcmd = params->value;
    if (ic->ic_cfg80211_radio_handler.get_he_mesh_config) {
        ret = ic->ic_cfg80211_radio_handler.get_he_mesh_config((void *)scn, val);
    }
    else {
        ret = -EOPNOTSUPP;
    }

    snprintf(string, HE_MESH_CONFIG_STRING, "%d BSS Color: %d", val[0], val[1]);

    cfg80211_reply_command(wiphy, sizeof(string), string, 0);

    return ret;
}

static int wlan_cfg80211_he_mesh_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define MESH_CONFIG_MAX_ARGS 2
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    uint8_t mesh_config_args[MESH_CONFIG_MAX_ARGS];
    uint8_t *data = (uint8_t *)params->data;

    if(data == NULL) {
        qdf_err("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    mesh_config_args[0] = params->value;
    mesh_config_args[1] = data[0];

    if (ic->ic_cfg80211_radio_handler.set_he_mesh_config) {
        ret = ic->ic_cfg80211_radio_handler.set_he_mesh_config((void *)scn,
                                                      mesh_config_args);
    }
    else {
        ret = -EOPNOTSUPP;
    }
    qdf_info("%s: Mesh enable flag: %d BSS Color: %d ret: %d", __func__,
            mesh_config_args[0], mesh_config_args[1], ret);

    return ret;
}

static int wlan_cfg80211_he_bss_color(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    uint8_t value, ovrride;
    uint8_t *data = (uint8_t *)params->data;

    if(data == NULL) {
        qdf_err("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    value = params->value;
    ovrride = data[0];

    if (ic->ic_cfg80211_radio_handler.set_he_bss_color) {
        ret = ic->ic_cfg80211_radio_handler.set_he_bss_color((void *)scn,
                                                      value, ovrride);
    }
    else {
        ret = -EOPNOTSUPP;
    }
    qdf_info("%s: value: %d override: %d ret: %d", __func__,
                                            value, ovrride, ret);

    return ret;
}

static int wlan_cfg80211_get_he_bss_color(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define HE_BSS_COLOR_STRING 20
#define HE_BSS_COLOR_ARGS 2
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    int val[HE_BSS_COLOR_ARGS] = {0};
    char string[HE_BSS_COLOR_STRING];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if (ic->ic_cfg80211_radio_handler.get_he_bss_color) {
        ret = ic->ic_cfg80211_radio_handler.get_he_bss_color((void *)scn, val);
    }
    else {
        ret = -EOPNOTSUPP;
    }

    snprintf(string, HE_BSS_COLOR_STRING, "%d Override: %d", val[0], val[1]);

    cfg80211_reply_command(wiphy, sizeof(string), string, 0);

    return ret;
}

static int wlan_cfg80211_nav_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    uint8_t value;
    uint32_t threshold;
    uint32_t *data = (uint32_t *)params->data;

    if(data == NULL) {
        qdf_err("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    value = (uint8_t)params->value;
    threshold = data[0];

    if (ic->ic_cfg80211_radio_handler.set_nav_override_config) {
        ret = ic->ic_cfg80211_radio_handler.set_nav_override_config((void *)scn,
                                                             value, threshold);
    }
    else {
        ret = -EOPNOTSUPP;
    }
    qdf_info("%s: value: %d threshold: %d ret: %d", __func__,
            value, threshold, ret);

    return ret;
}

static int wlan_cfg80211_get_nav_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define NAV_CONFIG_STRING 32
#define NAV_CONFIG_ARGS 2
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    int val[NAV_CONFIG_ARGS] = {0};
    char string[NAV_CONFIG_STRING];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if (ic->ic_cfg80211_radio_handler.get_nav_override_config) {
        ret = ic->ic_cfg80211_radio_handler.get_nav_override_config((void *)scn, val);
    }
    else {
        ret = -EOPNOTSUPP;
    }

    snprintf(string, NAV_CONFIG_STRING, "%d Threshold: %d", val[0], val[1]);

    cfg80211_reply_command(wiphy, sizeof(string), string, 0);

    return ret;
}

#if OBSS_PD
static int wlan_cfg80211_he_sr_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic           = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    uint8_t data;

    if (!params) {
        qdf_err("params is null");
        return -EINVAL;
    }

    if(params->data == NULL) {
        qdf_info("Invalid Arguments");
        return -EINVAL;
    }
    data = *((uint8_t *)params->data);

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (ic->ic_wdev.netdev == wdev->netdev) {
        scn = get_radio_device_context(wiphy, wdev->netdev);
        if (ic->ic_cfg80211_radio_handler.set_he_sr_config)
            return ic->ic_cfg80211_radio_handler.set_he_sr_config(
                                (void *)scn, params->value, data,
                                params->length, params->flags);
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        if (!osifp) {
            qdf_err("%s: osifp NULL\n", __func__);
            return -EINVAL;
        }
        vap = osifp->os_if;
        if (!vap) {
            qdf_err("%s: VAP is null ", __func__);
            return -1;
        }
        if (ic->ic_vap_set_he_sr_config)
            return ic->ic_vap_set_he_sr_config(vap, params->value, data,
                                               params->length, params->flags);
    }

    return -EOPNOTSUPP;
}

static int wlan_cfg80211_get_he_sr_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define HE_SR_CONFIG_OBSSPD_STRING 48
#define HE_SR_CONFIG_OBSSPD_ARGS 3
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int ret = -EOPNOTSUPP;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    uint32_t val[HE_SR_CONFIG_OBSSPD_ARGS]  = {0};
    char string[HE_SR_CONFIG_OBSSPD_STRING] = {0};

    if (!params) {
        qdf_err("params is null");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (ic->ic_wdev.netdev == wdev->netdev) {
        scn = get_radio_device_context(wiphy, wdev->netdev);
        if (ic->ic_cfg80211_radio_handler.get_he_sr_config)
            ret = ic->ic_cfg80211_radio_handler.get_he_sr_config((void *)scn, params->value, val);
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        if (!osifp) {
            qdf_err("%s: osifp NULL\n", __func__);
            return -EINVAL;
        }
        vap = osifp->os_if;
        if (!vap) {
            qdf_err("%s: VAP is null ", __func__);
            return -1;
        }
        if (ic->ic_vap_get_he_sr_config)
            ret = ic->ic_vap_get_he_sr_config(vap, params->value, val);
    }

    if (!ret) {
        switch (params->value) {
            case HE_SR_ENABLE_PER_AC:
            case HE_SR_PSR_ENABLE:
            case HE_SR_SR15_ENABLE:
                return cfg80211_reply_command(wiphy, sizeof(uint32_t), val, 0);
            break;

            /* Non-SRG OBSS_PD ENABLE */
            case HE_SR_NON_SRG_OBSSPD_ENABLE:
                snprintf(string, HE_SR_CONFIG_OBSSPD_STRING,
                        " enable: %u, max-offset: %u", val[0], val[1]);
                return cfg80211_reply_command(wiphy, strlen(string), string, 0);
            break;

            /* SRG OBSS_PD ENABLE */
            case HE_SR_SRG_OBSSPD_ENABLE:
                snprintf(string, HE_SR_CONFIG_OBSSPD_STRING,
                        " enable: %u, min-offset: %u, max-offset: %u",
                        val[0], val[1], val[2]);
                return cfg80211_reply_command(wiphy, strlen(string), string, 0);
            break;

            default:
                qdf_info("Unhandled SR config command");
                return -EINVAL;
        }
    }
    return ret;
}
#endif /* OBSS PD */

static int wlan_cfg80211_set_muedca_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    uint8_t muedcaparam, ac, value;

    void *cmd;
    uint8_t *data = (uint8_t *) params->data;

    if(data == NULL) {
        qdf_print("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        if (!osifp) {
            qdf_err("%s: osifp NULL\n", __func__);
            return -EINVAL;
        }
    }

    muedcaparam = params->value;
    ac = data[0];
    value = params->length;
    IEEE80211_DPRINTF
        (vap, IEEE80211_MSG_CFG80211,
         "%s: muedcaparam: %d ac: %d value: %d \n",
         __func__, muedcaparam, ac, value);
    return ieee80211_ucfg_set_muedcaparams((void *)osifp, muedcaparam,
            ac, value);

}

static int wlan_cfg80211_get_muedca_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    uint8_t muedcaparam, ac, value;

    void *cmd;
    uint8_t *data = (uint8_t *) params->data;

    if(data == NULL) {
        qdf_print("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    }

    muedcaparam = params->value;
    ac = (data[0] <= MUEDCA_AC_VO) ? data[0] : MUEDCA_AC_BE;
    value = ieee80211_ucfg_get_muedcaparams((void *)osifp, muedcaparam, ac);
    IEEE80211_DPRINTF
        (vap, IEEE80211_MSG_CFG80211,
         "%s: muedcaparam: %d ac: %d value: %d \n",
         __func__, muedcaparam, ac, value);
    return cfg80211_reply_command(wiphy, sizeof(uint8_t), &value, 0);

}

#if ATH_ACS_DEBUG_SUPPORT

/* wlan_cfg80211_acsdbgtool_add_bcn:
 * Sends the custom beacon from the user-space ACS debug tool and passes it
 * to the ACS debug framework
 *
 * Parameters:
 * wiphy: Pointer to the wiphy device structure
 * wdev: Pointer to the wireless_dev structure
 * params: Pointer containing all the custom beacons defined in the user-space
 *         ACS debug tool
 *
 * Return:
 * -1: Error
 *  0: Success
 */
static int wlan_cfg80211_acsdbgtool_add_bcn(struct wiphy *wiphy,
                                            struct wireless_dev *wdev,
                                            struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type = 0;
    void *cmd = NULL;
    void *bcn_data = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }
    if (cmd_type) {
        qdf_err("Invalid cfg80211 command");
        return -EINVAL;
    }

    vap = (wlan_if_t)cmd;

    if (!params->data_len) {
        bcn_data = NULL;
    } else {
        bcn_data = params->data;
    }

    if (acs_debug_create_bcndb(ic->ic_acs, bcn_data)) {
        if (params->data_len) {
            qdf_print("Could not create the ACS debug beacon database");
            return -EINVAL;
        } else {
            qdf_print("Continuing without beacon injections");
        }
    }

    return EOK;
}


/* wlan_cfg80211_acsdbgtool_add_chanev:
 * Sends the custom channel information from the user-space ACS debug tool and
 * passes it to the ACS debug framework
 *
 * Parameters:
 * wiphy: Pointer to the wiphy device structure
 * wdev: Pointer to the wireless_dev structure
 * params: Pointer containing all the custom beacons defined in the user-space
 *         ACS debug tool
 *
 * Return:
 * -1: Error
 *  0: Success
 */
static int wlan_cfg80211_acsdbgtool_add_chanev(struct wiphy *wiphy,
                                             struct wireless_dev *wdev,
                                             struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type = 0;
    void *cmd = NULL;
    void *chan_data = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid cfg80211 command");
        return -EINVAL;
    }

    vap = (wlan_if_t)cmd;

    if (!params->data_len) {
        chan_data = NULL;
    } else {
        chan_data = params->data;
    }

    if (acs_debug_create_chandb(ic->ic_acs, chan_data)) {
        if (params->data_len) {
            qdf_print("Could not create ACS debug channel event database");
            return -EINVAL;
        } else {
            qdf_print("Continuing without channel injections");
        }
    }

    return EOK;
}
#endif

static int wlan_cfg80211_kickmac(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,retval = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    struct ieee80211req_mlme mlme = {0};
    u_int8_t no_disassoc = 0;
#ifdef WLAN_FEATURE_11BE_MLO
    struct wlan_mlo_peer_context *mlo_peer_ctx;
    struct wlan_objmgr_peer *tmp_peer;
    bool release_ref = false;
#endif

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }

#ifdef WLAN_FEATURE_11BE_MLO
    /* Issued kickmac on MLD MAC address:
     * Find primary_peer from MLO peer context. If valid proceed with that link.
     **/
    if (ieee80211_mlo_is_mld_ap(vap->vdev_obj) || mlo_is_mld_sta(vap->vdev_obj)) {
        mlo_peer_ctx = wlan_mlo_get_mlpeer_by_mld_mac(vap->vdev_obj->mlo_dev_ctx,
                                                      (struct qdf_mac_addr *)mac);
        if (mlo_peer_ctx) {
            tmp_peer = wlan_mlo_peer_get_primary_peer(mlo_peer_ctx);
            if (tmp_peer) {
                vap = wlan_peer_get_vap(tmp_peer);
                if (!vap) {
                    qdf_err("Invalid vap!\n");
                    return -EINVAL;
                }
                /* Vap interface modified. Take reference and release after processing. */
                if (wlan_objmgr_vdev_try_get_ref(vap->vdev_obj, WLAN_OSIF_ID) == QDF_STATUS_SUCCESS) {
                    release_ref = true;
                } else {
                    qdf_err("Unable to get vdev reference!");
                    return -EINVAL;
                }
                ic = vap->iv_ic;
                if (!ic) {
                    wlan_objmgr_vdev_release_ref(vap->vdev_obj, WLAN_OSIF_ID);
                    qdf_err("Invalid ic!\n");
                    return -EINVAL;
                }
                osifp = (osif_dev *)((os_if_t)vap->iv_ifp);
                if (!osifp) {
                    wlan_objmgr_vdev_release_ref(vap->vdev_obj, WLAN_OSIF_ID);
                    qdf_err("Invalid osifp!\n");
                    return -EINVAL;
                }
                qdf_mem_copy(mac, wlan_peer_get_macaddr(tmp_peer), QDF_MAC_ADDR_SIZE);
            }
        }
    }
#endif

    if (params->value)
        no_disassoc = 1;

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s :%s \n", __func__, ether_sprintf(mac));
    /* Setup a MLME request for disassociation of the given MAC */
    mlme.im_op = IEEE80211_MLME_DISASSOC;
    mlme.im_reason = IEEE80211_REASON_UNSPECIFIED;
    qdf_mem_copy(&(mlme.im_macaddr), mac, QDF_MAC_ADDR_SIZE);

    if (no_disassoc) {
        mlme.im_reason = IEEE80211_REASON_ASSOC_LEAVE;
        qdf_info("Discon without disassoc mac:%s", ether_sprintf(mac));
    }

    /* Send the MLME request and return the result. */
    retval = ieee80211_ucfg_setmlme(ic, (void *)osifp, &mlme);
#ifdef WLAN_FEATURE_11BE_MLO
    if (release_ref)
        wlan_objmgr_vdev_release_ref(vap->vdev_obj, WLAN_OSIF_ID);
#endif

    return retval;
}

static int wlan_cfg80211_deauthmac(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct cfg80211_context *cfg_ctx = NULL;
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,retval = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    struct ieee80211req_mlme mlme;

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("NULL IC");
        return -EINVAL;
    }
#else
    ic = cfg_ctx->ic;
#endif

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);
    if (cmd_type) {
        qdf_err(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        if (!osifp) {
            qdf_err("NULL osifp link id : %u", params->link_id);
            return -EINVAL;
        }
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_err("Invalid mac address ");
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s :%s \n", __func__, ether_sprintf(mac));
    /* Setup a MLME request for deauth of the given MAC */
    mlme.im_op = IEEE80211_MLME_DEAUTH;
    mlme.im_reason = IEEE80211_REASON_AUTH_EXPIRE;
    qdf_mem_copy(&(mlme.im_macaddr), mac, QDF_MAC_ADDR_SIZE);

    /* Send the MLME request and return the result. */
    retval = ieee80211_ucfg_setmlme(ic, (void *)osifp, &mlme);
    return retval;
}

static int wlan_cfg80211_chan_switch(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params,
        struct wlan_cfg8011_vendor_params *vparams)
{
    struct ieee80211com *ic = NULL;
    enum wlan_band_id band;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t chan, tbtt;
    struct chan_params chan_p = {0};
#ifdef WLAN_FEATURE_11BE
    uint16_t chan_num_seg2;
#endif /* WLAN_FEATURE_11BE */

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (!vap) {
        qdf_err("vap is null");
        return -EINVAL;
    }

    chan = (u_int8_t)params->value;
    tbtt = (u_int8_t)params->length;
    band = (u_int8_t)params->flags;

    chan_p.freq = wlan_get_wlan_band_id_chan_to_freq(ic->ic_pdev_obj, chan, band);

    if (ieee80211_is_phymode_8080(vap->iv_cur_mode)) {
        chan_p.cfreq2 = vap->iv_des_cfreq2_80_80;
    }
#ifdef WLAN_FEATURE_11BE
    else if (!chan_p.cfreq2 && *(uint16_t *)params->data) {
        chan_num_seg2 = *((uint16_t *)params->data);
        chan_p.cfreq2 = wlan_get_wlan_band_id_chan_to_freq(ic->ic_pdev_obj, chan_num_seg2, band);
        if (!chan_p.cfreq2) {
            return -EINVAL;
        }
    }
#endif
    set_chan_params_puncture_bitmap(&chan_p, 0);
    if (vparams->puncture_bitmap) {
        set_chan_params_puncture_bitmap(&chan_p, vparams->puncture_bitmap);
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
            "%s chan; %d tbtt:%d band: %d, chan_freq: %d cfreq2 %d"
#ifdef WLAN_FEATURE_11BE
            "puncture bitmap %x"
#endif
            "\n",
            __func__, chan, tbtt, band, chan_p.freq, chan_p.cfreq2
#ifdef WLAN_FEATURE_11BE
            ,chan_p.puncture_bitmap
#endif
            );
    if (!chan_p.freq)
        return -EINVAL;

    chan_p.input_6g_pwr_mode = REG_BEST_PWR_MODE;
#ifdef WLAN_FEATURE_11BE
    chan_p.puncture_low_pwr = true;
#endif
    qdf_info("Enabling Channel Switch Announcement on current channel");
    return (ieee80211_ucfg_set_chanswitch(vap, &chan_p, tbtt, 0));
}

static int wlan_cfg80211_chan_widthswitch(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params,
        struct wlan_cfg8011_vendor_params *vparams)
{
    enum wlan_band_id band;
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t chan, tbtt;
    u_int8_t ccfs;
    u_int16_t ch_width;
    struct chan_params chan_p = {0};
    struct wlan_objmgr_vdev *vdev;
    int ret;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        vdev = vap->vdev_obj;
#ifdef WLAN_FEATURE_11BE
        /*
         * Set "is_user_punc" to true since user is the one who is puncturing
         */
        vdev->is_user_punc = true;
#endif
    }

    chan = (u_int8_t)params->value;
    tbtt = (((u_int8_t*)params->data)[0]);
    ch_width = (u_int16_t)params->length;
    band = (u_int16_t)params->flags;
    ccfs = (u_int16_t)vparams->ccfs;

    set_chan_params_puncture_bitmap(&chan_p, 0);
    if (vparams->puncture_bitmap) {
        set_chan_params_puncture_bitmap(&chan_p, vparams->puncture_bitmap);
    }

    chan_p.freq = wlan_get_wlan_band_id_chan_to_freq(ic->ic_pdev_obj, chan, band);
    chan_p.cfreq2 = wlan_get_wlan_band_id_chan_to_freq(ic->ic_pdev_obj, ccfs, band);

    if (ieee80211_is_phymode_8080(vap->iv_cur_mode)) {
        chan_p.cfreq2 = vap->iv_des_cfreq2_80_80;
    }
    qdf_nofl_info("chan; %d tbtt:%d ch_width: %d band: %d, chan_freq: %d cfreq2 %d:"
#ifdef WLAN_FEATURE_11BE
                  " puncture_bitmap %x"
#endif
                  , chan, tbtt, ch_width, band, chan_p.freq, chan_p.cfreq2
#ifdef WLAN_FEATURE_11BE
                  ,chan_p.puncture_bitmap
#endif
                  );
    if (!chan_p.freq) {
        qdf_err("Invalid channel frequency: %d", chan_p.freq);
#ifdef WLAN_FEATURE_11BE
        vdev->is_user_punc = false;
#endif
        return -EINVAL;
    }

    chan_p.input_6g_pwr_mode = REG_BEST_PWR_MODE;
#ifdef WLAN_FEATURE_11BE
    chan_p.puncture_low_pwr = true;
#endif
    qdf_nofl_info("Enabling Channel Switch Announcement on current channel");
    ret = ieee80211_ucfg_set_chanswitch(vap, &chan_p, tbtt, ch_width);

#ifdef WLAN_FEATURE_11BE
    if (ret && ret != -EALREADY) {
        vdev->is_user_punc = false;
    }
#endif

    return ret;
}

/*
 * is_command_execution_type_blocking() - Helper
 * API to check whether command execution type is blocking
 * @type: Command type
 *
 * Return: true if command type is blocking, else false
 */
static inline bool
is_command_execution_type_blocking(
                    enum command_execution_type type)
{
    return (type == COMMAND_EXECUTION_TYPE_BLOCKING);

}

#define MAX_PHYMODE_STRLEN 30
/*
 * struct channel_params - Internal structure to represent channel parameters
 *
 * @freq:        frequency
 * @cfreq2:      center frequency of second segment
 * @mode_str:    phymode string
 * @mode_strlen: length of the mode_str above
 * @mode:        phymode enum
 */
struct channel_params {
    uint16_t freq;
    int cfreq2;
    char mode_str[MAX_PHYMODE_STRLEN];
    uint16_t mode_strlen;
    enum ieee80211_phymode mode;
#ifdef WLAN_FEATURE_11BE
    uint16_t puncture_bitmap;
#endif
};

/*
 * get_current_chan_params() - Get current channel parameters
 * @ic: ic object
 * @chan: copy current channel here (OUT variable)
 *
 * This function gets the parameters from the current radio channel
 *
 * Return: 0 on success, -EINVAL on failure
 */
static int get_current_chan_params(struct ieee80211com *ic,
                                   struct channel_params *chan)
{
    struct ieee80211_ath_channel *current_chan;

    current_chan = ic->ic_curchan;
    chan->mode = ieee80211_chan2mode(current_chan);

    /*
     * Get freq and cfreq2
     */
    chan->freq = current_chan->ic_freq;
    if (!chan->freq) {
        qdf_err("ERROR!! current_freq not found\n");
        /* Error will be displayed from within the called API */
        return -EINVAL;
    }

    if ((chan->mode == IEEE80211_MODE_11AC_VHT80_80) ||
        (chan->mode == IEEE80211_MODE_11AXA_HE80_80)
#ifdef WLAN_FEATURE_11BE
        || (chan->mode == IEEE80211_MODE_11BEA_EHT320)
#endif /* WLAN_FEATURE_11BE */
       ) {
        /*
         * For modes other than 80_80, cfreq2 is irrelevant
         * So for other cases, cfreq2 should be 0 for consistency
         */
        chan->cfreq2 = current_chan->ic_vhtop_freq_seg2;
    }

#ifdef WLAN_FEATURE_11BE
    chan->puncture_bitmap = current_chan->op_puncture_bitmap;
#endif /* WLAN_FEATURE_11BE */
    /*
     * Get the current mode
     */
    qdf_mem_zero(chan->mode_str, sizeof(chan->mode_str));
    ieee80211_convert_phymode_to_string(chan->mode,
                                        chan->mode_str, &chan->mode_strlen);
    return 0;
}

/*
 * get_chan_params_from_cfg80211() - Get channel params coming through cfg80211
 * @ic: ic object
 * @params: cfg80211 params object
 * @chan: copy channel parameters coming through cfg80211 framework here (OUT)
 *
 * This function gets the channel parameters from the cfg80211 framework
 *
 * Return: 0 on success, -EINVAL on failure
 */
static int
get_chan_params_from_cfg80211(struct ieee80211com *ic,
                              struct wlan_cfg8011_genric_params *params,
                              struct wlan_cfg8011_vendor_params *vparams,
                              struct channel_params *chan)
{
    enum wlan_band_id band;
    u_int8_t chan_num;

    /*
     * Get the phymode
     */
    qdf_mem_zero(chan->mode_str, sizeof(chan->mode_str));
    if ((params->data_len) && (params->data_len < sizeof(chan->mode_str))) {
        qdf_mem_copy(chan->mode_str, params->data, params->data_len);
    } else {
        qdf_err("%s: Invalid mode %s", __func__, chan->mode_str);
        return -EINVAL;
    }
    chan->mode_strlen = params->data_len;
    chan->mode = ieee80211_convert_mode(chan->mode_str);
    if (((int)chan->mode) < 0) {
        qdf_err("ERROR!! Invalid mode passed %d %s\n", chan->mode,
                chan->mode_str);
        return -EINVAL;
    }

    /* band */
    band = (u_int16_t)params->flags;

    /* Channel number and frequency */
    chan_num = (u_int8_t)params->value;
    chan->freq = wlan_get_wlan_band_id_chan_to_freq(ic->ic_pdev_obj, chan_num, band);
    if (!(chan->freq)) {
        qdf_err("ERROR!! Invalid frequency passed chan %u freq %u band %d mode %d %s\n",
                chan_num, chan->freq, band, chan->mode, chan->mode_str);
        /* Error will be displayed from within the called API */
        return -EINVAL;
    }

    /* cfreq2 */
    if ((chan->mode == IEEE80211_MODE_11AC_VHT80_80) ||
        (chan->mode == IEEE80211_MODE_11AXA_HE80_80)
#ifdef WLAN_FEATURE_11BE
        || (chan->mode == IEEE80211_MODE_11BEA_EHT320)
#endif /* WLAN_FEATURE_11BE */
       )
        chan->cfreq2 = (u_int16_t)params->length;

#ifdef WLAN_FEATURE_11BE
    if (vparams->puncture_bitmap) {
        chan->puncture_bitmap = vparams->puncture_bitmap;
    }
#endif
    /*
     * Done copying the user passed params
     */
    qdf_debug("Got values chan-num:%d chan-mode:%s "
             "cfreq2:%d band:%d freq:%d mode_num:%d "
#ifdef WLAN_FEATURE_11BE
             "puncture_bitmap 0x%x"
#endif
             "\n",
             chan_num, chan->mode_str, chan->cfreq2, band,
             chan->freq, chan->mode
#ifdef WLAN_FEATURE_11BE
             , chan->puncture_bitmap
#endif
             );
    return 0;
}

/*
 * set_chan_param_tuple() - Set channel tuple to radio
 * @ic: ic object
 * @vap: vap object
 * @chan: set the channel tuple to the radio
 *
 * This function sets the channel parameters to the radio
 *
 * Return: 0 on success, -EINVAL on failure
 */
static int set_chan_param_tuple(struct ieee80211com *ic,
                                wlan_if_t vap, struct channel_params *chan)
{
    int dummy_ucfg_param;
    struct chan_params chan_p = {0};

    if (!chan) {
        return -EINVAL;
    }

    chan_p.freq = chan->freq;
    chan_p.cfreq2 = chan->cfreq2;
    chan_p.input_6g_pwr_mode = REG_BEST_PWR_MODE;
    set_chan_params_puncture_bitmap(&chan_p, chan->puncture_bitmap);

    /*
     * 1. Set the phymode (don't restart the VAPs)
     * 2. Set cfreq2 (in case of HT80+80)
     * 3. Set channel (may or may not restart VAPs)
     */
    if (ieee80211_ucfg_set_phymode(vap, chan->mode_str,
                                   chan->mode_strlen, false)) {
        qdf_err("ERROR!! Failed to set phymode\n");
        return -EINVAL;
    }

    if (chan->cfreq2 &&
#ifdef WLAN_FEATURE_11BE
            !ieee80211_is_phymode_11be(vap->iv_des_mode) &&
#endif
        ieee80211_ucfg_setparam(vap, IEEE80211_PARAM_SECOND_CENTER_FREQ,
                                (int)chan->cfreq2, (char *)&dummy_ucfg_param)) {
            qdf_err("ERROR!! Failed to set cfreq2\n");
            return -EINVAL;
    }

    if (ieee80211_ucfg_set_freq(vap, &chan_p)) {
        qdf_err("ERROR!! Failed to set frequency\n");
        return -EINVAL;
    }
    return 0;
}

bool wlan_vaps_in_diff_band(struct ieee80211com *ic,
                            enum ieee80211_phymode phymode)
{
    wlan_if_t tmpvap;
    bool is_mode_2g = ieee80211_is_phymode_2g(phymode);

    TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next) {
        if (is_mode_2g != ieee80211_is_phymode_2g(tmpvap->iv_des_mode)) {
            qdf_info("Band change detected. VAPs are in different bands\n");
            return true;
        }
    }

    return false;
}

/*
 * wlan_cfg80211_chan_tuple_set() - Sets channel-num, phymode, cfreq2 and band
 * @wiphy: wiphy object
 * @wdev: wireless_dev object
 * @params: parameters coming from cfg80211tool framework
 * @vparams: vendor parameters
 *
 * This function sets the 4-tuple (channel_num, phymode-string, cfreq2, band)
 *
 * Return: 0 on success, -EINVAL on failure
 */
static int wlan_cfg80211_chan_tuple_set(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params,
        struct wlan_cfg8011_vendor_params *vparams)
{
    struct ieee80211com *ic;
    wlan_if_t vap;
    int retval;
    u_int32_t sec_offset;
    struct channel_params original_chan = {0};
    struct channel_params input_chan = {0};
    struct chan_params chan_p = {0};
    enum command_execution_type command_type;
    enum ieee80211_phymode phymode;
    struct ieee80211vap *tmpvap = NULL;
    struct regulatory_channel reg_chan_obj = {0};
    struct regulatory_channel *reg_chan = &reg_chan_obj;
    struct wlan_objmgr_pdev *pdev;
    struct wlan_objmgr_vdev *vdev;
    struct wlan_objmgr_psoc *psoc;
    struct wlan_lmac_if_dfs_rx_ops *dfs_rx_ops;
    struct ieee80211_ath_channel ic_chanchange_channel;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    {
        /*
         * Get VAP Object
         */
        int cmd_type;
        void *cmd;

        cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

        if (!cmd) {
            qdf_err("cmd is NULL\n");
            return -EINVAL;
        }
        if (cmd_type) {
            qdf_err(" Command on invalid interface");
            return -EINVAL;
        } else {
            vap = (wlan_if_t)cmd;
            vdev = vap->vdev_obj;
#ifdef WLAN_FEATURE_11BE
            /*
             * Set "is_user_punc" to true since user is the one who is puncturing
             */
            vdev->is_user_punc = true;
#endif
        }
    }

    TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next) {
        ieee80211_clear_channel_switch_stats(tmpvap);
        tmpvap->iv_channel_switch_stats.command_handler_entry =
                qdf_get_log_timestamp();
    }

    if (get_chan_params_from_cfg80211(ic, params, vparams, &input_chan)) {
#ifdef WLAN_FEATURE_11BE
        /*
         * Reset "is_user_punc" to false since puncture has failed
         */
        vdev->is_user_punc = false;
#endif
        return -EINVAL;
    }

    /*
     * Before doing anything, check whether the user passed combination is
     * valid. If not no need in proceeding further
     */
    chan_p.freq = input_chan.freq;
    chan_p.cfreq2 = input_chan.cfreq2;
    chan_p.input_6g_pwr_mode = REG_BEST_PWR_MODE;
    set_chan_params_puncture_bitmap(&chan_p, input_chan.puncture_bitmap);

    *reg_chan = wlan_reg_get_reg_chan_list_based_on_freq(ic->ic_pdev_obj,
                                                         chan_p.freq,
                                                         chan_p.input_6g_pwr_mode);

    if (!ieee80211_is_dot11_channel_mode_valid(vap, &chan_p,
                                               input_chan.mode)) {
        /* It is expected that the channel state will be disabled during bootup.
         * Consequently, to prevent the default console print, this debug
         * print is being suppressed.
         */
        if (reg_chan && reg_chan->state == CHANNEL_STATE_DISABLE)
            IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "ERROR!! Channel state is disabled: mode: %d %s freq %u cfreq2 %d\n",
                              input_chan.mode, input_chan.mode_str, input_chan.freq, input_chan.cfreq2);
        else
            qdf_err("ERROR!! Invalid combination of mode %d %s freq %u cfreq2 %d\n",
                    input_chan.mode, input_chan.mode_str, input_chan.freq, input_chan.cfreq2);
#ifdef WLAN_FEATURE_11BE
        /*
         * Reset "is_user_punc" to false since puncture has failed
         */
        vdev->is_user_punc = false;
#endif
        return -EINVAL;
    }

    command_type = vparams->mode_chan_command_type;
    if (command_type >= COMMAND_EXECUTION_TYPE_MAX) {
        qdf_err("Invalid command type %d", command_type);
#ifdef WLAN_FEATURE_11BE
        /*
         * Reset "is_user_punc" to false since puncture has failed
         */
        vdev->is_user_punc = false;
#endif
        return -EINVAL;
    }

    qdf_debug("Command type = %d", command_type);

    pdev = wlan_vdev_get_pdev(vdev);
    if(pdev == NULL) {
#ifdef WLAN_FEATURE_11BE
       /*
        * Reset "is_user_punc" to false since puncture has failed
        */
       vdev->is_user_punc = false;
#endif
       qdf_info("%s : pdev is NULL", __func__);
       return -1;
    }

    psoc = wlan_pdev_get_psoc(pdev);
    if (psoc == NULL) {
        qdf_info("%s : psoc is NULL", __func__);
#ifdef WLAN_FEATURE_11BE
        /*
         * Reset "is_user_punc" to false since puncture has failed
         */
        vdev->is_user_punc = false;
#endif
        return -EINVAL;
    }

    dfs_rx_ops = wlan_lmac_if_get_dfs_rx_ops(psoc);
    if (!dfs_rx_ops) {
#ifdef WLAN_FEATURE_11BE
        /*
         * Reset "is_user_punc" to false since puncture has failed
         */
        vdev->is_user_punc = false;
#endif
        qdf_err("dfs_rx_ops is NULL");
        return -EINVAL;
    }

    ic_chanchange_channel = ieee80211_find_dot11_channel(ic, &chan_p, input_chan.mode);
#if (WLAN_FEATURE_11BE && QCA_DFS_BW_PUNCTURE)
    /*
     * Dont allow unpuncture of a punctured sub20 channel when the SM punc obj
     * of this sub20 channel has not reached CAC_DONE state.
     */
    if (WLAN_REG_IS_5GHZ_CH_FREQ(chan_p.freq) &&
        is_subset_channel_for_cac(ic, ic->ic_curchan, &ic_chanchange_channel) &&
        dfs_rx_ops->dfs_check_punc_chan_in_cac) {
        if (dfs_rx_ops->dfs_check_punc_chan_in_cac(pdev, chan_p.puncture_bitmap)) {
            qdf_err("Channel is already punctured and has not reached "
                    "CAC complete state");
            /*
             * Reset "is_user_punc" to false since puncture has failed
             */
            vdev->is_user_punc = false;
            return -EINVAL;
        }
    }
#endif

    /*
     * Determine all the pre-existing params, in case they need to be
     * restored (in case of failure)
     */
    if (get_current_chan_params(ic, &original_chan)) {
        qdf_err("ERROR! Failed to get current channel tuple\n");
#ifdef WLAN_FEATURE_11BE
        /*
         * Reset "is_user_punc" to false since puncture has failed
         */
        vdev->is_user_punc = false;
#endif
        return -EINVAL;
    }

    if (!IEEE80211_IS_SPECIAL_VAP_ONLY(vap)) {
        wlan_mbss_stop_vdevs(ic->ic_pdev_obj, NULL);

        TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next)
            tmpvap->iv_channel_switch_stats.block_for_vdev_down =
                    qdf_get_log_timestamp();
        if (wlan_pdev_wait_to_bringdown_vdevs(ic, ALL_VDEVS)) {
#ifdef WLAN_FEATURE_11BE
            /*
             * Reset "is_user_punc" to false since puncture has failed
             */
            vdev->is_user_punc = false;
#endif
            return -EINVAL;
        }
    }

    /* In case of mixed mode, if band is changed, there might be
     * the case where few VAPs are updated with new band and
     * few VAPs (which do not receive this command), will be in
     * older band. This leads to issue while deriving modes for
     * the repurpose case. Update the mode of all the VAPs
     * with new band to avoid above mentioned issue.
     */
    if (ieee80211_mixed_modes_config(vap, vap->iv_des_mode) &&
        (wlan_reg_freq_to_band(original_chan.freq) !=
                   wlan_reg_freq_to_band(input_chan.freq)) &&
        wlan_vaps_in_diff_band(vap->iv_ic, input_chan.mode)) {
        TAILQ_FOREACH(tmpvap, &vap->iv_ic->ic_vaps, iv_next) {
            if (ieee80211_is_phymode_40plus(tmpvap->iv_des_mode))
                sec_offset = IEEE80211_SEC_CHAN_OFFSET_SCA;
            else
                sec_offset = IEEE80211_SEC_CHAN_OFFSET_SCB;

            phymode = ieee80211_get_composite_phymode(get_mode_from_phymode(input_chan.mode),
                                                      get_chwidth_phymode(tmpvap->iv_des_mode),
                                                      sec_offset);
            /* chwidth of this vap might not be compatible with the new band.
             * Try with minimum chwidth.
             */
            if (!phymode)
                phymode = ieee80211_get_composite_phymode(get_mode_from_phymode(input_chan.mode),
                                                          IEEE80211_CWM_WIDTH20,
                                                          0);
                tmpvap->iv_des_mode = phymode;
                tmpvap->iv_des_hw_mode = phymode;
                qdf_info("%s:Setting des_mode %u\n", tmpvap->iv_netdev_name,
                         tmpvap->iv_des_mode);
        }
    }

    if (set_chan_param_tuple(ic, vap, &input_chan)) {
        /*
         * Operation failed: So restore all the previous settings
         */
        set_chan_param_tuple(ic, vap, &original_chan);
        retval = -EINVAL;
    } else {
        retval = 0;
    }

    /*Save the user configured channel*/
    if (!retval) {
        ic->ic_userconfiguredchan_obj = *(vap->iv_des_chan[vap->iv_des_mode]);
    }

    if (!IEEE80211_IS_SPECIAL_VAP_ONLY(vap)) {
        wlan_mbss_start_vdevs(ic->ic_pdev_obj, NULL);
    }
    if (is_command_execution_type_blocking(command_type)) {
        QDF_STATUS status;

        vap->iv_channel_switch_stats.block_for_vdev_up = qdf_get_log_timestamp();

        status = osif_vap_wait_for_vdev_up_state(vap);
        if (QDF_IS_STATUS_ERROR(status)) {
            qdf_err("Failed to wait for vap to go to up state");
#ifdef WLAN_FEATURE_11BE
            /*
             * Reset "is_user_punc" to false since puncture has failed
             */
            vdev->is_user_punc = false;
#endif
            return qdf_status_to_os_return(status);
        }
    }

    TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next)
        tmpvap->iv_channel_switch_stats.command_handler_exit =
                qdf_get_log_timestamp();

    mlme_debug("Command type = %s, execution time = %llu us",
               is_command_execution_type_blocking(command_type) ? "blocking" : "non-blocking",
               vap->iv_channel_switch_stats.command_handler_exit -
               vap->iv_channel_switch_stats.command_handler_entry);

#ifdef WLAN_FEATURE_11BE
    if (retval) {
        vdev->is_user_punc = false;
    }
#endif

    return retval;
}

static int wlan_cfg80211_set_acparams(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    u_int8_t ac, use_rts, aggrsize_scaling;
    u_int32_t min_kbps;

    void *cmd;
    u_int8_t *data = (u_int8_t *) params->data;

    if(data == NULL) {
        qdf_print("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ac  = (u_int8_t) params->value;
    use_rts = (u_int8_t) data[0];
    aggrsize_scaling = (u_int8_t) params->length;
    min_kbps = ((u_int8_t)params->flags) * 1000;

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: ac: %d rts: %d aggrscale: %d kbps: %d \n", __func__, ac, use_rts, aggrsize_scaling, min_kbps);

    if (ac > 3 || (use_rts != 0 && use_rts != 1) ||
        aggrsize_scaling > 4 || min_kbps > 250000)
    {
        goto error;
    }

    wlan_set_acparams(vap, ac, use_rts, aggrsize_scaling, min_kbps);
    return 0;

error:
    qdf_print("usage: acparams ac <0|3> RTS <0|1> aggr scaling <0..4> min mbps <0..250>");
    return -EINVAL;

}

static int wlan_cfg80211_setrtparams(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type , retv = -1;
    void *cmd;
    uint32_t param[4];
    uint32_t *data = (u_int32_t *) params->data;

    if(data == NULL) {
        qdf_print("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type == VAP_CMD) {
        vap = (wlan_if_t)cmd;
    } else {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    }

    param[0] = params->value;
    param[1] = data[0];
    param[2] = params->length;
    param[3] = params->flags;

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
            "%s: param0: %d param1: %d param2: %d param3: %d\n",
            __func__, param[0], param[1], param[2], param[3]);

    switch(param[0])
    {
        case IEEE80211_RCPARAMS_RTPARAM:
            retv = ieee80211_ucfg_rcparams_setrtparams(vap, param[1], param[2], param[3]);
            break;
        case IEEE80211_RCPARAMS_RTMASK:
            /* TODO: Last argument passed is 0 because support to extend command usage
             * for an extra argument is pending in WEXT. Will be updated once
             * the support is added for WEXT command as well. */
            retv = ieee80211_ucfg_rcparams_setratemask(vap, param[1], param[2], param[3], 0);
            break;
        default:
            break;
    }

    return retv;
}

static int wlan_cfg80211_setratemask(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type , retv = -1;
    void *cmd;
    uint32_t param[4];
    uint32_t *data = (u_int32_t *) params->data;

    if(data == NULL) {
        qdf_print("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type == VAP_CMD) {
        vap = (wlan_if_t)cmd;
    } else {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    }

    param[0] = params->value;
    param[1] = data[0];
    param[2] = params->length;
    param[3] = params->flags;

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
            "%s: param0: %d param1: %d param2: %d param3: %d \n",
            __func__, param[0], param[1], param[2], param[3]);

    retv = ieee80211_ucfg_rcparams_setratemask(vap, param[0], param[1],
                                                param[2], param[3]);

    return retv;
}

static int wlan_cfg80211_set_wmm_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    int wmmparam, ac, bss, value;

    void *cmd;
    u_int32_t *data = (u_int32_t *) params->data;

    if(data == NULL) {
        qdf_print("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    }

    wmmparam = params->value;
    ac = (data[0] < WME_NUM_AC) ? data[0] : WME_AC_BE;
    bss = params->length;
    value = params->flags;
    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: wmmparam: %d ac: %d bss: %d value: %d \n", __func__, wmmparam, ac, bss, value);
    return ieee80211_ucfg_setwmmparams((void *)osifp, wmmparam, ac, bss, value);
}

uint32_t map_app_filter_to_pnrxfilter(uint32_t app_filter)
{
    uint32_t pn_rxfilter = 0;

    if (app_filter & IEEE80211_FILTER_TYPE_BEACON)
        IEEE80211_PN_RXFILTER_SET(pn_rxfilter,
                                  IEEE80211_PN_RXFILTER_BEACON);

    if (app_filter & IEEE80211_FILTER_TYPE_PROBE_REQ)
        IEEE80211_PN_RXFILTER_SET(pn_rxfilter,
                                  IEEE80211_PN_RXFILTER_PROBE_REQ);

    if (app_filter & IEEE80211_FILTER_TYPE_PROBE_RESP)
        IEEE80211_PN_RXFILTER_SET(pn_rxfilter,
                                  IEEE80211_PN_RXFILTER_PROBE_RESP);

    if (app_filter & IEEE80211_FILTER_TYPE_ASSOC_REQ)
        IEEE80211_PN_RXFILTER_SET(pn_rxfilter,
                                  IEEE80211_PN_RXFILTER_ASSOC_REQ);

    if (app_filter & IEEE80211_FILTER_TYPE_ASSOC_RESP)
        IEEE80211_PN_RXFILTER_SET(pn_rxfilter,
                                  IEEE80211_PN_RXFILTER_ASSOC_RESP);

    if (app_filter & IEEE80211_FILTER_TYPE_AUTH)
        IEEE80211_PN_RXFILTER_SET(pn_rxfilter,
                                  IEEE80211_PN_RXFILTER_AUTH);

    if (app_filter & IEEE80211_FILTER_TYPE_DEAUTH)
        IEEE80211_PN_RXFILTER_SET(pn_rxfilter,
                                  IEEE80211_PN_RXFILTER_DEAUTH);

    if (app_filter & IEEE80211_FILTER_TYPE_DISASSOC)
        IEEE80211_PN_RXFILTER_SET(pn_rxfilter,
                                  IEEE80211_PN_RXFILTER_DISASSOC);

    if (app_filter & IEEE80211_FILTER_TYPE_ACTION)
        IEEE80211_PN_RXFILTER_SET(pn_rxfilter,
                                  IEEE80211_PN_RXFILTER_ACTION);

    return pn_rxfilter;
}

static int wlan_cfg80211_set_filter(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev  *osifp = NULL;
    wlan_if_t vap = NULL;
    uint32_t app_filterype = 0;
    uint32_t pn_rxfilter = 0;
    int cmd_type;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        vap = (wlan_if_t)cmd;

    }

    app_filterype = params->value;

    if (app_filterype & ~IEEE80211_FILTER_TYPE_ALL) {
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: app_filterype: %d \n", __func__, app_filterype);
    osifp->app_filter = app_filterype;

    pn_rxfilter = map_app_filter_to_pnrxfilter(osifp->app_filter);
    if (vap->iv_set_pn_mgmt_rxfilter)
        vap->iv_set_pn_mgmt_rxfilter(vap, pn_rxfilter);

    if (osifp->app_filter &
            (IEEE80211_FILTER_TYPE_ASSOC_REQ | IEEE80211_FILTER_TYPE_AUTH)) {
        wlan_set_param(vap, IEEE80211_TRIGGER_MLME_RESP, 1);
    }

    if (osifp->app_filter == 0) {
        wlan_set_param(vap, IEEE80211_TRIGGER_MLME_RESP, 0);
    }
    return 0;
}

void static
wlan_cfg80211_sta_send_mgmt(void *arg, struct ieee80211_node *ni)
{
    struct ieee80211vap    *vap = ni->ni_vap;
    struct ieee80211req_mgmtbuf *mgmt_frm = (struct ieee80211req_mgmtbuf *)arg;
    int rc =0;

    if (ni != vap->iv_bss)
    {
        rc = wlan_send_mgmt(vap, ni->ni_macaddr, mgmt_frm->buf, mgmt_frm->buflen);
        if (rc < 0) {
            qdf_err("%s: send mgmt failed with err %d \n", __func__, rc);
        }
    }
}

static int wlan_cfg80211_send_mgmt(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    int ret = 0;
    struct ieee80211req_mgmtbuf *mgmt_frm;
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    uint32_t *data = (u_int32_t *) params->data;

    if(data == NULL) {
        qdf_err("%s: Invalid Arguments \n", __func__);
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type == VAP_CMD) {
        vap = (wlan_if_t)cmd;
    } else {
        qdf_err(" %s Command on invalid interface \n", __func__);
        return -EINVAL;
    }

    mgmt_frm = (struct ieee80211req_mgmtbuf *) params->data;

    if(mgmt_frm->buflen >= 37 && mgmt_frm->buf[24] == 0xff) {
        qdf_err(" %s unknown action frame\n", __func__);
        return -EINVAL;
    }

    /* if the macaddr requested is for broadcast then search for
       all connected sta and send the mgmt packet */
    if(vap) {
        if(IEEE80211_IS_BROADCAST(mgmt_frm->macaddr)) {
            ret = wlan_iterate_station_list(vap, wlan_cfg80211_sta_send_mgmt, mgmt_frm);
        }
        else {
            ret = wlan_send_mgmt(vap, mgmt_frm->macaddr, mgmt_frm->buf, mgmt_frm->buflen);
        }
    } else {
        qdf_err("%s: Invalid vap \n", __func__);
        return -EINVAL;
    }

    /* wlan_iterate_station_list returns the number of sta connected,
       so return error only if the return value is less than zero */
    if (ret < 0) {
        return ret;
    } else {
        return 0;
    }
}

/*
 * special_post_scan_wait() - Wait till scan completes
 *
 * @vap: VAP handler
 *
 * This function waits till cur_chan scan is completes
 *
 * Return: 0 on successful scan_done on time, -E* on failure.
 */
#define SPL_VAP_SCAN_WAIT_DELAY ((CONVERT_SEC_TO_SYSTEM_TIME(30)/1000) + 1) /* 30 msec */
static QDF_STATUS special_post_scan_wait(struct ieee80211vap *vap)
{
    bool scan_done = false;
    uint16_t max_wait = 30, total_delay = 0;

    do {
        schedule_timeout_interruptible(SPL_VAP_SCAN_WAIT_DELAY);
        if (!wlan_scan_in_progress(vap)) {
            scan_done = true;
            break;
        }
        total_delay += 1;
    } while (!scan_done && (total_delay < max_wait));

    if (!scan_done) {
        qdf_debug("Max wait for scan_done reached.");
        return -EAGAIN;
    }
    return QDF_STATUS_SUCCESS;
}

/*
 * special_vap_trigger_curchan_scan() - Issue scan on cur_chan for special VAP.
 *
 * @vdev: VDEV object manager
 *
 * This function issues scan on the current channel for special VAP
 * with chan_info_evt enabled.
 *
 * Return: 0 on success, -E* on failure
 */
static QDF_STATUS special_vap_trigger_curchan_scan(struct wlan_objmgr_vdev *vdev)
{
    struct ieee80211vap *vap = wlan_vdev_get_mlme_ext_obj(vdev);
    osif_dev  *osifp;
    struct scan_start_request *scan_params = NULL;
    int status  = 0;
    enum ieee80211_opmode opmode;
    ieee80211_ssid    *ssid_list;
    int n_ssid = 0;
    struct ieee80211com *ic;
    u_int32_t scan_freq;

    status = wlan_objmgr_vdev_try_get_ref(vdev, WLAN_OSIF_SCAN_ID);
    if (QDF_IS_STATUS_ERROR(status)) {
        scan_info("unable to get reference");
        return -EBUSY;
    }

    if(vap) {
        osifp = (osif_dev *)vap->iv_ifp;
        ic = vap->iv_ic;
        opmode = wlan_vap_get_opmode(vap);
    } else {
        wlan_objmgr_vdev_release_ref(vdev, WLAN_OSIF_SCAN_ID);
        qdf_err("VAP is NULL");
        return -EINVAL;
    }

    if(!osifp || !ic) {
        wlan_objmgr_vdev_release_ref(vdev, WLAN_OSIF_SCAN_ID);
        qdf_err("OSIFP or IC is NULL");
        return -EINVAL;
    }

    ssid_list = OS_MALLOC(osifp->os_handle,
                          sizeof(ieee80211_ssid) * IEEE80211_SCAN_MAX_SSID,
                          GFP_KERNEL);
    if (ssid_list == NULL) {
        wlan_objmgr_vdev_release_ref(vdev, WLAN_OSIF_SCAN_ID);
        return -ENOMEM;
    }

    n_ssid = wlan_get_desired_ssidlist(vap, ssid_list, IEEE80211_SCAN_MAX_SSID);

    /* Fill scan parameter */
    scan_params = (struct scan_start_request *) qdf_mem_malloc(sizeof(*scan_params));
    if (scan_params == NULL) {
        qdf_err("Falied to allocate scan_params");
        wlan_objmgr_vdev_release_ref(vdev,WLAN_OSIF_SCAN_ID);
        OS_FREE (ssid_list);
        return QDF_STATUS_E_NOMEM;
    }

    status = wlan_update_scan_params(vap,scan_params,opmode,true,true,true,
                                     true, n_ssid, ssid_list, 0);
    if (status) {
        qdf_err("scan param init failed with status: %d\n", status);
        qdf_mem_free(scan_params);
        wlan_objmgr_vdev_release_ref(vdev,WLAN_OSIF_SCAN_ID);
        OS_FREE(ssid_list);
        return QDF_STATUS_E_FAILURE;
    }

    if (IEEE80211_IS_CHAN_VALID(ic->ic_curchan))
        scan_freq = ic->ic_curchan->ic_freq;

    ucfg_scan_init_chanlist_params(scan_params,
                                   1, &scan_freq, NULL);
    scan_params->scan_req.scan_f_chan_stat_evnt = 1;

    status = wlan_ucfg_scan_start(vap, scan_params, osifp->scan_requestor,
                                  SCAN_PRIORITY_VERY_HIGH, &(osifp->scan_id),
                                  0, NULL);

    if (status) {
        qdf_debug("scan start failed with status: %d", status);
        wlan_objmgr_vdev_release_ref(vdev,WLAN_OSIF_SCAN_ID);
        OS_FREE(ssid_list);
        return status;
    }
    special_post_scan_wait(vap);
    wlan_objmgr_vdev_release_ref(vdev,WLAN_OSIF_SCAN_ID);
    OS_FREE(ssid_list);
    return status;
}

/*
 * special_vap_prepare_scan() - Prepare for scan for special VAP.
 *
 * @vap: VAP handler
 *
 * This function waits until VDEV_UP to call special_vap_trigger_curchan_scan().
 *
 * Return: 0 on success, -E* on failure
 */
#define VDEV_UP_WAIT_DELAY ((CONVERT_SEC_TO_SYSTEM_TIME(3)/1000) + 1) /* 3 msec */
static QDF_STATUS special_vap_prepare_scan(struct ieee80211vap *vap)
{
    bool trigger_scan = false;
    uint16_t max_wait = 50, total_delay = 0;

    do {
        schedule_timeout_interruptible(VDEV_UP_WAIT_DELAY);
        if (!wlan_scan_in_progress(vap) &&
            QDF_IS_STATUS_SUCCESS(wlan_vdev_is_up_active_state(vap->vdev_obj))) {
            trigger_scan = true;
            break;
        }
        total_delay += 1;
    } while (!trigger_scan && (total_delay < max_wait));

    if (!trigger_scan) {
        qdf_err("Max wait for VDEV_UP reached.Skip scan trigger");
        return -EAGAIN;
    }
    return special_vap_trigger_curchan_scan(vap->vdev_obj);
}

/**
 * wlan_cfg80211_get_freq2_for_set_channel - cfreq2 is required for channel
 * widths like 80p80 and 320MHz. In case of 80p80MHz channel, get it from the
 * vap configuration. cfreq2 represents center of the 320MHz channel in case of
 * a 6GHz channel. If the user does not provide cfreq2 the find the first
 * available 320MHz channel center.
 *
 * @vap - Vap pointer.
 * @freq - Primary frequency of the channel.
 * @cfreq2 - Pointer to center frequency cfreq2.
 * @data - Pointer to the input data.
 * @data_len - Length of the input data.
 * @band - Band info i.e 2G/5G/6G.
 */
static int wlan_cfg80211_get_freq2_for_set_channel(struct ieee80211vap *vap,
                                                   qdf_freq_t freq, qdf_freq_t *cfreq2,
                                                   uint16_t *data, uint16_t data_len,
                                                   enum wlan_band_id band)
{
    if (ieee80211_is_phymode_8080(vap->iv_des_mode)) {
        *cfreq2 = vap->iv_des_cfreq2_80_80;
        return 0;
    }

#ifdef WLAN_FEATURE_11BE
    if (data_len && *data) {
        uint16_t chan_num_seg2 = *data;

        *cfreq2 = wlan_get_wlan_band_id_chan_to_freq(vap->iv_ic->ic_pdev_obj, chan_num_seg2, band);
        if (!(*cfreq2)) {
            qdf_debug("The input cfreq2 %u is invalid. Band %u", chan_num_seg2, band);
            return -EINVAL;
        }

        qdf_debug("%s: cfreq2 %u", vap->iv_netdev_name, *cfreq2);
        return 0;
    }

    if (!(*cfreq2) && WLAN_REG_IS_6GHZ_CHAN_FREQ(freq) &&
        ieee80211_is_phymode_320(vap->iv_des_mode)) {
        const struct bonded_channel_freq *bonded_chan_ptr;

        /*
         * Since the cfreq2 is not given for the 320MHz channel change, get the
         * bonded channel entry and assume first 320MHz channel.
         */
        bonded_chan_ptr = wlan_reg_get_bonded_chan_entry(freq,
                                wlan_reg_find_chwidth_from_bw(BW_320_MHZ), 0);
        if (!bonded_chan_ptr) {
            qdf_debug("320MHz bonded pair not found for freq %u", freq);
            return -EINVAL;
        }

        *cfreq2 = (bonded_chan_ptr->start_freq + bonded_chan_ptr->end_freq) / 2;
    }
#endif /* WLAN_FEATURE_11BE */

    qdf_debug("%s: cfreq2 %u", vap->iv_netdev_name, *cfreq2);
    return 0;
}

int wlan_cfg80211_set_channel(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params,
        struct wlan_cfg8011_vendor_params *vparams)
{
    enum wlan_band_id band;
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    int channel = 0;
    struct chan_params chan_p = {0};
    QDF_STATUS status;
    int ret;
    enum command_execution_type command_type;
    struct ieee80211vap *tmpvap = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;

    }

    TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next) {
        ieee80211_clear_channel_switch_stats(tmpvap);
        tmpvap->iv_channel_switch_stats.command_handler_entry =
                qdf_get_log_timestamp();
    }

    channel = params->value;
    band = params->length;
    chan_p.freq = wlan_get_wlan_band_id_chan_to_freq(ic->ic_pdev_obj, channel, band);
    if (channel && !chan_p.freq) {
        /* Error will be displayed from within the called API */
        return -EINVAL;
    }

    chan_p.input_6g_pwr_mode = REG_BEST_PWR_MODE;
    if (wlan_cfg80211_get_freq2_for_set_channel(vap, chan_p.freq, &chan_p.cfreq2,
                                                (uint16_t *)params->data,
                                                params->data_len, band))
        return -EINVAL;

#ifdef WLAN_FEATURE_11BE
    set_chan_params_puncture_bitmap(&chan_p, 0);
    if (params->flags) {
        set_chan_params_puncture_bitmap(&chan_p, params->flags);
    }

    chan_p.puncture_low_pwr = true;

    if ((vap->iv_des_mode != IEEE80211_MODE_AUTO) &&
        !ieee80211_is_dot11_channel_mode_valid(vap, &chan_p, vap->iv_des_mode)) {
       qdf_err("Channel input is invalid");
       return -EINVAL;
    }
#endif /* WLAN_FEATURE_11BE */

    command_type = vparams->mode_chan_command_type;
    if (command_type >= COMMAND_EXECUTION_TYPE_MAX) {
        qdf_err("Invalid command type %d", command_type);
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211,
                      "%s: channel: %d band: %d, freq: %d cfreq2: %d "
#ifdef WLAN_FEATURE_11BE
                      "puncture_pattern: %x "
#endif /* WLAN_FEATURE_11BE */
                      "command_type = %d\n",
            __func__, channel, band, chan_p.freq, chan_p.cfreq2
#ifdef WLAN_FEATURE_11BE
            , chan_p.op_puncture_bitmap
#endif /* WLAN_FEATURE_11BE */
            , command_type);

    ret = wlan_cfg80211_set_channel_internal(ic, vap, &chan_p, command_type);
    if (!ret && vap->iv_spl_vap_scan) {
        status = special_vap_prepare_scan(vap);
        ret = qdf_status_to_os_return(status);
    }

    /*Save the user configured channel*/
    if (!ret) {
        ic->ic_userconfiguredchan_obj = *(vap->iv_des_chan[vap->iv_des_mode]);
    }

    TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next)
        tmpvap->iv_channel_switch_stats.command_handler_exit =
                qdf_get_log_timestamp();

    mlme_debug("Command type = %s, execution time = %llu us",
               is_command_execution_type_blocking(command_type) ? "blocking" : "non-blocking",
               vap->iv_channel_switch_stats.command_handler_exit -
               vap->iv_channel_switch_stats.command_handler_entry);

    return ret;
}

int wlan_cfg80211_get_channel_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct net_device *dev;
    wlan_if_t vap = NULL;
    struct ieee80211_ath_channel chan_obj;
    wlan_chan_t chan = &chan_obj;
    int cmd_type;
    void *cmd;
    uint8_t rply[2] = {0};

    if (!wdev)
        return -EINVAL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    dev = wdev->netdev;
    if (!vap || !dev)
        return -EINVAL;

    if (dev->flags & (IFF_UP | IFF_RUNNING))
        *chan = ieee80211_ucfg_get_bss_channel(vap);
    else
        *chan = ieee80211_ucfg_get_current_channel(vap, true);

    rply[0] = chan->ic_ieee;
    rply[1] = reg_wifi_band_to_wlan_band_id(wlan_reg_freq_to_band(chan->ic_freq));
    cfg80211_reply_command(wiphy, 2, rply, 0);

    return 0;
}
/*
 * wlan_cfg80211_set_channel_internal() - Set frequency to the radio
 * @ic: ic object handle
 * @vap: vap object handle
 * @chan_p: channel parameters
 * @command_type: command type
 *
 * This function sets the radio frequency
 *
 * Return: 0 on success, -EINVAL on failure
 */
static int wlan_cfg80211_set_channel_internal(struct ieee80211com *ic,
                                              wlan_if_t vap,
                                              struct chan_params *chan_p,
                                              enum command_execution_type command_type)
{
    struct ol_ath_softc_net80211 *scn;

    if (chan_p == NULL) {
        return -EINVAL;
    }

    scn = OL_ATH_SOFTC_NET80211(ic);
    if ((wlan_vdev_chan_config_valid(vap->vdev_obj) == QDF_STATUS_SUCCESS)) {
        if (ieee80211_ucfg_set_freq(vap, chan_p) < 0) {
            qdf_err("Could not set channel frequency %u", chan_p->freq);
            return -EINVAL;
        }

        if (is_command_execution_type_blocking(command_type)) {
            QDF_STATUS status;

            vap->iv_channel_switch_stats.block_for_vdev_up = qdf_get_log_timestamp();

            status = osif_vap_wait_for_vdev_up_state(vap);
            if (QDF_IS_STATUS_ERROR(status)) {
                qdf_err("Failed to wait for vap to go to up state");
                return qdf_status_to_os_return(status);
            }
        }

        return 0;
    } else {
        if (!chan_p->freq) {
            return -EINVAL;
        }
        /* store channel frequency value in VAP, which will be set in start_ap */
        /*
         * when strict_channel_mode is set, we need to allow the user
         * space to set channel even when the VAPs are down
         */
        if (vap->iv_opmode == IEEE80211_M_MONITOR ||
            IEEE80211_IS_SPECIAL_VAP(vap) ||
            (wlan_psoc_nif_feat_cap_get(scn->soc->psoc_obj, WLAN_SOC_F_STRICT_CHANNEL) &&
             vap->iv_opmode == IEEE80211_M_HOSTAP)) {
            if (ieee80211_ucfg_set_freq(vap, chan_p) < 0) {
                qdf_err("%s: Could not set channel frequency for monitor vap\n", __func__);
                return -EINVAL;
            }
        }
        return 0;
    }
}

static int wlan_cfg80211_get_aclmac(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    osif_dev *osifp = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    u_int8_t *mac_list;
    int i, rc, num_mac;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        vap = (wlan_if_t)cmd;
    }

    /* read and send mac list to application */
    mac_list = (u_int8_t *)OS_MALLOC(osifp->os_handle,
            (QDF_MAC_ADDR_SIZE * 256), GFP_KERNEL);
    if (!mac_list) {
        return -EFAULT;
    }
    rc = wlan_get_acl_list(vap, mac_list, (QDF_MAC_ADDR_SIZE * 256),
            &num_mac, IEEE80211_ACL_FLAG_ACL_LIST_1);
    if(rc) {
        OS_FREE(mac_list);
        return -EFAULT;
    }

    for (i = 0; i < num_mac && i < 256; i++) {
        memcpy(&mac, &mac_list[i * QDF_MAC_ADDR_SIZE], QDF_MAC_ADDR_SIZE);
        cfg80211_reply_command(wiphy, QDF_MAC_ADDR_SIZE, &mac, 0);
    }
    OS_FREE(mac_list);
    return 0;
}

static int wlan_cfg80211_mac_commands(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,ret = 0, mac_command = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    mac_command = params->value;
    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, " %s :%s  maccmd: %d \n", __func__, ether_sprintf(mac), mac_command);

    switch (mac_command)
    {
        case MAC_COMMND_ADD_WDS_ADDR:
            ret = ieee80211_add_wdsaddr(vap, (union iwreq_data *)mac);
            if (ret) {
                return -EFAULT;
            }
            break;
        case MAC_COMMND_SEND_WOWPKT:
            return ieee80211_sendwowpkt(wdev->netdev, mac);
            break;
	case MAC_COMMND_SET_PEER_KICKOUT:
	    ret = ieee80211_node_set_kickout(vap, mac, params->flags ? true : false);
        default:
            break;
    }

    return ret;
}

static int wlan_cfg80211_set_wirelessmode(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    char mode[30];
    bool reset_vaps;
    enum command_execution_type command_type;
    int ret;
    int repurpose = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    qdf_mem_zero(mode, sizeof(mode));

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if ((params->data_len) && (params->data_len < sizeof(mode))) {
        qdf_mem_copy(mode, params->data, params->data_len);
    } else {
        qdf_print("%s: Invalid mode ", __func__);
        return -EINVAL;
    }
    reset_vaps = params->flags ? false : true;
    repurpose = (params->length == 1) ? params->length : 0;

    command_type = params->value;
    if (command_type >= COMMAND_EXECUTION_TYPE_MAX) {
        qdf_err("Invalid command type %d", command_type);
        return -EINVAL;
    }

    if (is_command_execution_type_blocking(command_type) &&
        !IEEE80211_IS_SPECIAL_VAP_ONLY(vap)) {
        qdf_err("Blocking mode change is only supported for special vap");
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: mode %s command_type %d\n",
                      __func__, mode, command_type);

    qdf_event_reset(&vap->wait_event_vdev_up_state);

    if (repurpose) {
        struct wlan_objmgr_pdev *pdev = wlan_vdev_get_pdev(vap->vdev_obj);

        if (!pdev) {
            qdf_err("pdev is null for vap (%s)", vap->iv_netdev_name);
            return -EINVAL;
        }

        qdf_info("Repurpose vap (%s) vdev:%u pdev:%u psoc:%u mbssid:%d for mode=%s",
                 vap->iv_netdev_name, vap->iv_unit, wlan_objmgr_pdev_get_pdev_id(pdev),
                 wlan_psoc_get_id(wlan_pdev_get_psoc(pdev)), ic->is_mbssid_enabled, mode);

        if (wlan_vdev_wait_for_init(vap, repurpose) != QDF_STATUS_SUCCESS) {
            qdf_err("Error while waiting for vap move to init state");
            return -EINVAL;
        }

        if (wlan_vdev_mlme_is_active(vap->vdev_obj) == QDF_STATUS_SUCCESS) {
            qdf_err("Vap needs to be in down state for repurposing");
            return -EINVAL;
        }

        vap->iv_repurpose = 1;
        ret = ieee80211_ucfg_set_phymode(vap, mode, params->data_len, FALSE);
    } else {
        ret = ieee80211_ucfg_set_phymode(vap, mode, params->data_len, reset_vaps);
    }

    vap->iv_repurpose = 0;
    if (!ret && is_command_execution_type_blocking(command_type)) {
        QDF_STATUS status;

        status = osif_vap_wait_for_vdev_up_state(vap);
        if (QDF_IS_STATUS_ERROR(status)) {
            qdf_err("Failed to wait for special vap to go to up state");
            return qdf_status_to_os_return(status);
        }
    }

    return ret;
}

static int wlan_cfg80211_get_wirelessmode(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    u_int16_t length = 0;
    void *cmd;
    char mode[30];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    qdf_mem_zero(mode, sizeof(mode));
    ieee80211_ucfg_get_phymode(vap, mode, &length, CURR_MODE);

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: mode %s length %d\n", __func__, mode, length);
    cfg80211_reply_command(wiphy, length+1, mode, 0);
    return 0;
}

static int wlan_cfg80211_get_wirelessopmode(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    u_int16_t length = 0;
    void *cmd;
    char mode[30];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if(vap == NULL) {
        qdf_err("Vap is NULL:");
        return -EINVAL;
    }

    qdf_mem_zero(mode, sizeof(mode));
    length = sizeof(mode);
    ieee80211_ucfg_get_opmode(vap, mode, &length);

    if(length > 0) {
        qdf_debug("opmode %s length %d\n", mode, length);
        return cfg80211_reply_command(wiphy, length+1, mode, 0);
    }
    else {
        qdf_err("Invalid Opmode:");
        return -EINVAL;
    }
}



static int wlan_cfg80211_get_ssid(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    ieee80211_ssid tmpssid;
    int des_nssid = 0, error = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }
    qdf_mem_zero(&tmpssid, sizeof(ieee80211_ssid));
    error = ieee80211_ucfg_get_essid(vap, &tmpssid, &des_nssid);
    if (error)
        return error;

    if ((des_nssid > 0) || (tmpssid.len > 0)) {
        cfg80211_reply_command(wiphy, tmpssid.len, tmpssid.ssid, 0);
    }

    return error;
}

static int wlan_cfg80211_set_ssid(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    ieee80211_ssid   tmpssid;
    int status;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (params->data_len) {

        if (params->data_len > IEEE80211_NWID_LEN) {
            params->data_len = IEEE80211_NWID_LEN;
        }

        tmpssid.len = params->data_len;
        qdf_mem_copy(tmpssid.ssid, params->data, params->data_len);
        tmpssid.ssid[tmpssid.len] = '\0';
    } else {
        /* ANY */
        tmpssid.ssid[0] = '\0';
        tmpssid.len = 0;
    }
    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: SSID %s \n", __func__, tmpssid.ssid);

    /*
     * Special VAP mode is AP+Monitor mode, for this mode VAP is up in dev_open itself.
     * As we are not do VAP bringup using start_ap. poulate SSID values so that
     * other applications (SON) can read SSID values.
     */

    if (IEEE80211_IS_SPECIAL_VAP(vap)) {
#ifdef CFG80211_MLO_SINGLE_NETDEV_API
        wdev->u.ap.ssid_len =  tmpssid.len;
        qdf_mem_copy(wdev->u.ap.ssid, tmpssid.ssid, wdev->u.ap.ssid_len);
#else
        wdev->ssid_len =  tmpssid.len;
        qdf_mem_copy(wdev->ssid, tmpssid.ssid, wdev->ssid_len);
#endif
    }

    status = ieee80211_ucfg_set_essid(vap, &tmpssid, 1);
    if (!status)
        status = send_ssid_event(wiphy, wdev, &tmpssid);
    return status;
}

/* Radio Commands */
#define ISO_NAME_SIZE 3

static int wlan_cfg80211_set_country(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    char isoname[ISO_NAME_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }
    if (!params->data) {
       qdf_info("Invalid or Insufficient arguments");
       return -EINVAL;
    }
    if (params->data_len <= ISO_NAME_SIZE) {
        qdf_mem_copy(&isoname, params->data, ISO_NAME_SIZE);
        if (params->data_len <= ISO_NAME_SIZE-1)
            isoname[params->data_len] = '\0';
    } else {
        qdf_print("Invalid country name/length ");
        return -EINVAL;
    }
    if(ic->ic_cfg80211_radio_handler.setcountry)
        ret = ic->ic_cfg80211_radio_handler.setcountry((void*)scn, (char *)&isoname);
    else
        ret = -EOPNOTSUPP;
    if (params->data_len < ISO_NAME_SIZE)
        qdf_print("%s: Country: %s ret: %d ", __func__, isoname, ret);

    return ret;
}

static int wlan_cfg80211_get_country(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    char isoname[ISO_NAME_SIZE+1] = "";

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if ( ic->ic_cfg80211_radio_handler.getcountry )
        ret =  ic->ic_cfg80211_radio_handler.getcountry((void*)scn, isoname);
    else
        ret = -EOPNOTSUPP;

    /* Ascii values are already set for Indoor ('I') and Outdoor ('O') */
    if (!(ic->ic_is_radio_outdoor || ic->ic_is_radio_indoor) && ic->ic_opclass_tbl_idx)
        isoname[ISO_NAME_SIZE-1] += '0';

    isoname[ISO_NAME_SIZE] = '\0';
    cfg80211_reply_command(wiphy, ISO_NAME_SIZE+1, isoname, 0);
    qdf_debug("%s: Country: %s ret: %d", __func__, isoname,ret);

    return ret;
}

static int wlan_cfg80211_get_noise_floor(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct wlan_objmgr_psoc *psoc = NULL;
    int ret = 0;
    int16_t nf = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if(ic->ic_is_target_lithium(psoc)){
        if(!ic->ic_get_cur_hw_nf){
            qdf_err("ic_get_cur_hw_nf is null");
            return -EINVAL;
        }
        nf = ic->ic_get_cur_hw_nf(ic);
    } else {
        if(!ic->ic_get_cur_chan_nf){
            qdf_err("ic_get_cur_chan_nf is null");
            return -EINVAL;
        }
        nf = ic->ic_get_cur_chan_nf(ic);
    }
    cfg80211_reply_command(wiphy, sizeof(nf), &nf, 0);
    return ret;
}

static int wlan_cfg80211_set_hwaddr(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }

    if (  ic->ic_cfg80211_radio_handler.sethwaddr )
        ret = ic->ic_cfg80211_radio_handler.sethwaddr((void*)scn, mac);
    else
        ret = -EOPNOTSUPP;
    qdf_debug("%s :%s ret: %d ", __func__, ether_sprintf(mac),ret);
    return ret;
}

static int wlan_cfg80211_set_ba_timeout(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    uint32_t duration;
    uint8_t ac;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }
    ac = params->value;
    duration = params->length;
   /* Valid access category - 0,1,2,3
    * 0 - Background
    * 1 - Best effort
    * 2 - Video
    * 3 - Voice
    */
    if ( ac > 3 ) {
        ret = -EOPNOTSUPP;
        qdf_print("Invalid AC value - %d\n", ac);
        return ret;
    }
    if ( ic->ic_cfg80211_radio_handler.set_ba_timeout ) {
        ic->ic_cfg80211_radio_handler.set_ba_timeout(scn, ac, duration);
    }
    else
        ret = -EOPNOTSUPP;
    qdf_print("%s: ac: %d timeout: %d ret: %d\n", __func__, ac, duration, ret);
    return ret;

}

static int wlan_cfg80211_get_ba_timeout(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    uint32_t duration;
    uint8_t ac;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }
    ac = params->value;
    /* Valid access category - 0,1,2,3
    * 0 - Background
    * 1 - Best effort
    * 2 - Video
    * 3 - Voice
    */
    if ( ac > 3 ) {
        ret = -EOPNOTSUPP;
        qdf_print("Invalid AC value - %d\n", ac);
        return ret;
    }
    if ( ic->ic_cfg80211_radio_handler.get_ba_timeout ) {
        ic->ic_cfg80211_radio_handler.get_ba_timeout(scn, ac, &duration);
        qdf_print("AC: %d BA_timeout: %d\n", ac, duration);
        return ret;
    }
    else
        ret = -EOPNOTSUPP;
    return ret;

}

static int wlan_cfg80211_set_aggr_burst(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    uint32_t ac, duration;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    ac = params->value;
    duration = params->length;

    if ( ic->ic_cfg80211_radio_handler.set_aggr_burst )
        ret = ic->ic_cfg80211_radio_handler.set_aggr_burst(scn, ac, duration);
    else
        ret = -EOPNOTSUPP;
    qdf_print("%s: ac: %d duration: %d ret: %d", __func__, ac, duration, ret);
    return ret;
}

static int wlan_cfg80211_set_atf_sched_dur(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    uint32_t ac, duration;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    ac = params->value;
    duration = params->length;
#if QCA_AIRTIME_FAIRNESS
    if ( ic->ic_cfg80211_radio_handler.set_atf_sched_dur )
        ret = ic->ic_cfg80211_radio_handler.set_atf_sched_dur(scn, ac, duration);
    else
#endif
        ret = -EOPNOTSUPP;
    return ret;
}

static int wlan_cfg80211_txrx_peer_stats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }
    if( ic->ic_cfg80211_radio_handler.txrx_peer_stats )
        ic->ic_cfg80211_radio_handler.txrx_peer_stats((void*)scn, mac);
    else
        return -EOPNOTSUPP;
    qdf_print("%s :%s  ", __func__, ether_sprintf(mac));

    return 0;
}

static int wlan_cfg80211_txrx_dp_fw_peer_stats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    u_int8_t caps;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }
    caps = params->value; /* attribute 18 holds caps value */
    qdf_print("%s :%s caps:%d ", __func__, ether_sprintf(mac), caps);

    if(ic->ic_cfg80211_radio_handler.get_dp_fw_peer_stats) {
        ic->ic_cfg80211_radio_handler.get_dp_fw_peer_stats((void*)scn, mac, caps);
    }
    else  {
        return -EOPNOTSUPP;
    }

    return 0;
}

/**
 * wlan_cfg80211_get_peer_extd_rate_link_stats: Get the peer extended
 *         rate and link stats.
 * @wiphy : Pointer to wiphy
 * @wdev  : Pointer to wdev
 * @params: Pointer to wlan_cfg80211_genric_params
 * Return: 0 for success or corresponding error code for failure.
 */
static int wlan_cfg80211_get_peer_extd_rate_link_stats(struct wiphy *wiphy,
                                        struct wireless_dev *wdev,
                                        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("IC is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
        if (!scn) {
            qdf_err("scn is NULL");
            return -EINVAL;
        }
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_err("Invalid mac address ");
        return -EINVAL;
    }
    if( ic->ic_cfg80211_radio_handler.get_peer_extd_rate_link_stats)
        ic->ic_cfg80211_radio_handler.get_peer_extd_rate_link_stats((void*)scn, mac);
    else
        return -EOPNOTSUPP;
    qdf_info("%s :%s  ", __func__, ether_sprintf(mac));

    return 0;
}

static int wlan_cfg80211_set_peer_nexthop(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    u_int32_t if_num;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }
    if (cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }
    if_num = params->value; /* attribute 18 holds next hop interface number */

    if (if_num > MAX_NSS_INTERFACE_NUM) {
        qdf_print("Next hop interface number should be less than %d", MAX_NSS_INTERFACE_NUM);
        return -EINVAL;
    }

    return ieee80211_ucfg_set_peer_nexthop((void *)osifp, mac, if_num);
}

#if SM_ENG_HIST_ENABLE
extern void wlan_mlme_print_all_sm_history(void);

static int wlan_cfg80211_sm_history(struct wiphy *wiphy,
                                    struct wireless_dev *wdev,
                                    struct wlan_cfg8011_genric_params *params)
{
    wlan_mlme_print_all_sm_history();
    return 0;
}
#endif

static int wlan_cfg80211_set_vlan_type(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    uint8_t default_vlan, port_vlan;
    uint8_t param[2];
    uint8_t *data;

    if (params->data == NULL) {
        return -EINVAL;
    }

    data = (uint8_t *) params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    }

    param[0] = params->value;
    param[1] = data[0];

    default_vlan = param[0];
    port_vlan = param[1];
    ieee80211_ucfg_set_vlan_type((void *)osifp, default_vlan, port_vlan);

    return 0;
}

static struct ol_ath_softc_net80211 *
wlan_cfg80211_extract_radio_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
    if (ic == NULL) {
        qdf_err("Invalid Interface");
        return NULL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, 0);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return NULL;
    }

    if (!cmd_type)
        qdf_err(" Command on Invalid interface");
    else
        scn = (struct ol_ath_softc_net80211 *)cmd;
    return scn;
}

static wlan_if_t
wlan_cfg80211_extract_vap_intf(struct wiphy *wiphy, struct wireless_dev *wdev,
                               uint8_t link_id)
{
    struct ieee80211com *ic = NULL;

    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, link_id);
    if (ic == NULL) {
        qdf_err("Invalid Interface");
        return NULL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return NULL;
    }

    if (cmd_type) {
        qdf_err("Command on Invalid Interface");
        return NULL;
    }

    vap = (wlan_if_t)cmd;
    return vap;
}

#if UMAC_SUPPORT_ACFG
/* set vap vendor param using nl80211 */
static int wlan_cfg80211_vap_vendor_param(struct wiphy *wiphy,
            struct wireless_dev *wdev,
            struct wlan_cfg8011_genric_params *params)
{
    int status = 0;
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type = 0;
    void *cmd = NULL;
    struct net_device *dev = NULL;
    acfg_vendor_param_req_t *req;
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        dev = wdev->netdev;
    }

    req = (acfg_vendor_param_req_t *)params->data;

    status = osif_set_vap_vendor_param(dev, req, params->link_id);
    return status;
}
#endif

#if UNIFIED_SMARTANTENNA
#define MAX_SA_PARAM_LEN 16     /* 4 DWORDS */
/*
 * wlan_cfg80211_set_sa_params:
 * Sets smart antenna params for a particular radio
 */
static int
wlan_cfg80211_set_sa_params(struct wiphy *wiphy, struct wireless_dev *wdev,
                            struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    int ret = 0;
    char sa_param_buf[MAX_SA_PARAM_LEN] = {0};
    uint32_t *buff = (uint32_t *)sa_param_buf;

    if (params->data == NULL) {
        qdf_err("Invalid Arguments");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if ((!cmd_type) || (!cmd)) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else
        scn = (struct ol_ath_softc_net80211 *)cmd;

    buff[0] = params->value;
    buff[1] = *((uint32_t *)params->data);
    buff[2] = params->length;
    buff[3] = params->flags;

    if (ic->ic_cfg80211_radio_handler.set_saparam) {
        ic->ic_cfg80211_radio_handler.set_saparam((void *)scn, sa_param_buf);
    } else
        ret = -EOPNOTSUPP;

    return ret;
}

/*
 * wlan_cfg80211_get_sa_params:
 * Gets smart antenna params for a particular radio
 */
static int
wlan_cfg80211_get_sa_params(struct wiphy *wiphy, struct wireless_dev *wdev,
                            struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    int ret = 0;
    char sa_param_buf[MAX_SA_PARAM_LEN] = {0};
    uint32_t *buff = (uint32_t *)sa_param_buf;

    if (params->data == NULL) {
        qdf_err("Invalid Arguments");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if ((!cmd_type) || (!cmd)) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else
        scn = (struct ol_ath_softc_net80211 *)cmd;

    buff[0] = params->value;
    buff[1] = *((uint32_t *)params->data);
    buff[2] = params->length;

    if (ic->ic_cfg80211_radio_handler.get_saparam) {
        ret = ic->ic_cfg80211_radio_handler.get_saparam((void *)scn, sa_param_buf);
    } else
        ret = -EOPNOTSUPP;

    if (ret == 0)
        cfg80211_reply_command(wiphy, sizeof(u_int32_t), sa_param_buf, 0);

    return ret;
}
#endif

/*
 * wlan_updt_vap_pcp_tid_map:
 * Updates pcp to tid mapping for all vap's of a particular radio
 */
static INLINE void wlan_updt_vap_pcp_tid_map(void *arg, wlan_if_t vap)
{
    uint32_t pcp = *(uint32_t *)arg;
    if (!vap->iv_tidmap_tbl_id)
        wlan_set_vap_pcp_tid_map(vap, pcp,
                                 (uint32_t)vap->iv_ic->ic_pcp_tid_map[pcp]);
}

/*
 * wlan_cfg80211_set_def_pcp_tid_map:
 * Sets pcp to tid mapping for a particular radio
 */
static int
wlan_cfg80211_set_def_pcp_tid_map(struct wiphy *wiphy,
                                  struct wireless_dev *wdev,
                                  struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int ret = 0;
    uint32_t pcp, tid, target_type;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else
        ic = &scn->sc_ic;

    target_type = ic->ic_get_tgt_type(ic);
    /*Feature supported for IPQ8074 and IPQ6018 only*/
    if (!((target_type == TARGET_TYPE_QCA8074) ||
          (target_type == TARGET_TYPE_QCA8074V2) ||
          (target_type == TARGET_TYPE_QCA9574) ||
          (target_type == TARGET_TYPE_QCN9000) ||
          (target_type == TARGET_TYPE_QCN9224) ||
          (target_type == TARGET_TYPE_QCN6122) ||
          (target_type == TARGET_TYPE_QCN9160) ||
          (target_type == TARGET_TYPE_QCA6018) ||
          (target_type == TARGET_TYPE_QCA5332) ||
          (target_type == TARGET_TYPE_QCA5018) ||
          (target_type == TARGET_TYPE_QCN6432))) {
        qdf_err("Feature not supported for target");
        return -EOPNOTSUPP;
    }

    pcp = params->value;
    tid = params->length;

    if ( ic->ic_cfg80211_radio_handler.set_pcp_tid_map ) {
        ic->ic_cfg80211_radio_handler.set_pcp_tid_map(scn, pcp, tid);
    } else
        ret = -EOPNOTSUPP;

    return ret;
}

/*
 * wlan_cfg80211_get_def_pcp_tid_map:
 * Gets pcp to tid mapping for a particular radio
 */
static int
wlan_cfg80211_get_def_pcp_tid_map(struct wiphy *wiphy,
                                  struct wireless_dev *wdev,
                                  struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int retval = 0;
    uint32_t pcp, value, target_type;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else
        ic = &scn->sc_ic;
    target_type = ic->ic_get_tgt_type(ic);
    if (!((target_type == TARGET_TYPE_QCA8074) ||
          (target_type == TARGET_TYPE_QCA8074V2) ||
          (target_type == TARGET_TYPE_QCA9574) ||
          (target_type == TARGET_TYPE_QCN9000) ||
          (target_type == TARGET_TYPE_QCN9224) ||
          (target_type == TARGET_TYPE_QCN6122) ||
          (target_type == TARGET_TYPE_QCN9160) ||
          (target_type == TARGET_TYPE_QCA6018) ||
          (target_type == TARGET_TYPE_QCA5332) ||
          (target_type == TARGET_TYPE_QCA5018) ||
          (target_type == TARGET_TYPE_QCN6432))) {
        qdf_err("Feature not supported for target");
        return -EOPNOTSUPP;
    }
    pcp = params->value;
    if ( ic->ic_cfg80211_radio_handler.get_pcp_tid_map ) {
        ic->ic_cfg80211_radio_handler.get_pcp_tid_map(ic, pcp, &value);
        if (value < 0)
            retval = -EOPNOTSUPP;
    } else
        retval = -EOPNOTSUPP;

    cfg80211_reply_command(wiphy, sizeof(u_int32_t), &value, 0);
    return retval;
}

/*
 * wlan_updt_vap_tidmap_prty:
 * Updates tidmap priority for all vap's of a particular radio
 */
static INLINE void wlan_updt_vap_tidmap_prty(void *arg, wlan_if_t vap)
{
    if (!vap->iv_tidmap_tbl_id)
        wlan_set_vap_tidmap_prty(vap, (uint32_t)vap->iv_ic->ic_tidmap_prty);
}
/*
 * wlan_cfg80211_set_def_tidmap_prty:
 * Sets tidmap priority for a particular radio
 */
static int wlan_cfg80211_set_def_tidmap_prty(struct wiphy *wiphy,
                struct wireless_dev *wdev,
                struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int retval = 0;
    uint32_t prio, target_type;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else
        ic = &scn->sc_ic;

    target_type = ic->ic_get_tgt_type(ic);
    if (!((target_type == TARGET_TYPE_QCA8074) ||
          (target_type == TARGET_TYPE_QCA8074V2) ||
          (target_type == TARGET_TYPE_QCA9574) ||
          (target_type == TARGET_TYPE_QCN9000) ||
          (target_type == TARGET_TYPE_QCN9224) ||
          (target_type == TARGET_TYPE_QCN6122) ||
          (target_type == TARGET_TYPE_QCN9160) ||
          (target_type == TARGET_TYPE_QCA6018) ||
          (target_type == TARGET_TYPE_QCA5332) ||
          (target_type == TARGET_TYPE_QCA5018) ||
          (target_type == TARGET_TYPE_QCN6432))) {
        qdf_err("Feature not supported for target");
        return -EOPNOTSUPP;
    }
    prio = params->value;
    if (ic->ic_cfg80211_radio_handler.set_tidmap_prty) {
        ic->ic_cfg80211_radio_handler.set_tidmap_prty(scn, prio);
        /*vap prty should be upgraded for IPQ4019 only*/
    } else
        retval = -EOPNOTSUPP;

    return retval;
}

/*
 * wlan_cfg80211_get_def_tidmap_prty:
 * Gets tidmap priority for a particular radio
 */
static int wlan_cfg80211_get_def_tidmap_prty(struct wiphy *wiphy,
                struct wireless_dev *wdev,
                struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int retval = 0;
    uint32_t value, target_type;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err("Command on Invalid interface");
        return -EINVAL;
    } else
        ic = &scn->sc_ic;
    target_type = ic->ic_get_tgt_type(ic);
    if (!((target_type == TARGET_TYPE_QCA8074) ||
          (target_type == TARGET_TYPE_QCA8074V2) ||
          (target_type == TARGET_TYPE_QCA9574) ||
          (target_type == TARGET_TYPE_QCN9000) ||
          (target_type == TARGET_TYPE_QCN9224) ||
          (target_type == TARGET_TYPE_QCN6122) ||
          (target_type == TARGET_TYPE_QCN9160) ||
          (target_type == TARGET_TYPE_QCA6018) ||
          (target_type == TARGET_TYPE_QCA5332) ||
          (target_type == TARGET_TYPE_QCA5018) ||
          (target_type == TARGET_TYPE_QCN6432))) {
        qdf_err("Feature not supported for target");
        return -EOPNOTSUPP;
    }
    if (ic->ic_cfg80211_radio_handler.get_tidmap_prty) {
        ic->ic_cfg80211_radio_handler.get_tidmap_prty(scn, &value);
        if (value < 0)
            retval = -EOPNOTSUPP;
    } else
        retval = -EOPNOTSUPP;

    cfg80211_reply_command(wiphy, sizeof(u_int32_t), &value, 0);
    return retval;
}

static int wlan_cfg80211_set_btcoex_duty_cycle(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int ret = 0;
    uint32_t period, duration;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    }
    ic = &scn->sc_ic;

    period = params->value;
    duration = params->length;
    if ( ic->ic_cfg80211_radio_handler.set_btcoex_duty_cycle ) {
        ret = ic->ic_cfg80211_radio_handler.set_btcoex_duty_cycle(scn, period, duration);
    }
    else
        ret = -EOPNOTSUPP;

    return ret;
}

#ifdef WLAN_SUPPORT_RX_FLOW_TAG
static int wlan_cfg80211_rx_flow_tag_op(struct wiphy *wiphy, struct wireless_dev *wdev,
            struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct net_device *dev = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct ieee80211req_athdbg *req = (struct ieee80211req_athdbg *) params->data;
    struct ieee80211_rx_flow_tag *flow_tag_info;
    int return_val = -EOPNOTSUPP;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (ic->ic_wdev.netdev == wdev->netdev) {
        dev = wdev->netdev;

        scn = get_radio_device_context(wiphy, wdev->netdev);
        flow_tag_info = (struct ieee80211_rx_flow_tag *) &req->data.rx_flow_tag_info;

        if (ic->ic_cfg80211_radio_handler.ic_rx_flow_tag_op)
            return_val = ic->ic_cfg80211_radio_handler.ic_rx_flow_tag_op((void*)scn, flow_tag_info);
    }
    else
        return_val = -EOPNOTSUPP;

    return return_val;
}
#endif /* WLAN_SUPPORT_RX_FLOW_TAG */

static int wlan_cfg80211_set_muedca_mode(struct wiphy *wiphy, struct wireless_dev *wdev,
           struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int  ret = 0;
    uint8_t mode;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    }
    ic = &scn->sc_ic;

    mode = params->value;

    /* Mode 0-Manual, 1-Host, 2-FW */
    if (mode >= HEMUEDCA_MODE_MAX) {
        ret = -EOPNOTSUPP;
        qdf_err("Invalid argument 1: Use 0-Manual, 1-Host, 2-FW");
        return ret;
    }
    if (ic->ic_cfg80211_radio_handler.set_muedca_mode) {
        ret = ic->ic_cfg80211_radio_handler.set_muedca_mode(scn, mode);
    } else {
        ret = -EOPNOTSUPP;
    }
    return ret;
}

static int wlan_cfg80211_set_non_ht_dup_en(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    uint8_t value;
    bool enable;
    uint8_t *data = (uint8_t *)params->data;

    if(data == NULL) {
        qdf_err("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if(params->value >= NON_HT_DUP_MAX) {
        qdf_err("Invalid arg1 value. Value should be less than %d\n",
                                                        NON_HT_DUP_MAX);
        return -EINVAL;
    }

    if(data[0] > 1) {
        qdf_err("Invalid arg2 value. Value should be 0 or 1\n");
        return -EINVAL;
    }

    value = (uint8_t)params->value;
    enable = data[0];

    if (ic->ic_cfg80211_radio_handler.set_non_ht_dup) {
        ret = ic->ic_cfg80211_radio_handler.set_non_ht_dup((void *)scn,
                                                             value, enable);
    }
    else {
        return -EINVAL;
    }
    qdf_info("%s: Configuring non-HT duplicate %s setting to %d\n", __func__,
            ((value == NON_HT_DUP_BEACON) ? "Beacon" :
             (value == NON_HT_DUP_FILS_DISCOVERY) ? "FILS Discovery" :
             (value == NON_HT_DUP_BCAST_PROBE_RESP) ? "Bcast Probe Resp" : ""),
             enable);

    return ret;
}

static int wlan_cfg80211_get_non_ht_dup_en(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define NON_HT_DUP_STRING 50
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    uint8_t frame = params->value;
    uint8_t value = 0;
    char string[NON_HT_DUP_STRING];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if(params->value >= NON_HT_DUP_MAX) {
        qdf_err("Invalid arg1 value. Value should be less than %d\n",
                                                        NON_HT_DUP_MAX);
        return -EINVAL;
    }

    if (ic->ic_cfg80211_radio_handler.get_non_ht_dup) {
        ret = ic->ic_cfg80211_radio_handler.get_non_ht_dup((void *)scn, frame,
                                                                        &value);
    }
    else {
        ret = -EOPNOTSUPP;
    }

    snprintf(string, NON_HT_DUP_STRING, "Non-HT duplicate %s setting is %d",
            ((frame == NON_HT_DUP_BEACON) ? "Beacon" :
            (frame == NON_HT_DUP_FILS_DISCOVERY) ? "FILS Discovery" :
            (frame == NON_HT_DUP_BCAST_PROBE_RESP) ? "Bcast Probe Resp" : ""),
            value);

    cfg80211_reply_command(wiphy, sizeof(string), string, 0);

    return ret;
}

static int wlan_cfg80211_get_muedca_mode(struct wiphy *wiphy,
                struct wireless_dev *wdev,
                struct wlan_cfg8011_genric_params *params)
{
    struct ol_ath_softc_net80211 *scn = NULL;
    struct ieee80211com *ic = NULL;
    int retval = 0, value;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    }
    ic = &scn->sc_ic;
    if (ic->ic_cfg80211_radio_handler.get_muedca_mode) {
        retval = ic->ic_cfg80211_radio_handler.get_muedca_mode(scn, &value);
    } else {
        return EOPNOTSUPP;
    }
    cfg80211_reply_command(wiphy, sizeof(u_int32_t), &value, 0);

    return retval;
}

static int wlan_cfg80211_set_6ghz_rnr(struct wiphy *wiphy, struct wireless_dev *wdev,
           struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int  ret = 0;
    uint8_t mode;
    uint8_t *data = (uint8_t *)params->data;
    uint8_t frm_val = 0;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    }
    ic = &scn->sc_ic;

    mode = params->value;
    if (data == NULL && mode < WLAN_RNR_MODE_MAX) {
        ret = -EOPNOTSUPP;
        qdf_err("Frm type invalid");
        return ret;
    }
    if (data)
        frm_val = data[0];

    /* 0-Disable, 1-Enable, 2-Driver selection */
    if (mode > WLAN_RNR_MODE_MAX) {
        ret = -EOPNOTSUPP;
        qdf_err("Invalid argument 1: Use 0-Disable, 1-Enable, 2-Driver");
        return ret;
    }

    if (frm_val > WLAN_RNR_FRM_MAX) {
        ret = -EOPNOTSUPP;
        qdf_err("Frm value is invalid - 0x0 to 0x7 are valid values");
        return ret;
    }

    if ((mode == 1 || mode == 0) && frm_val == 0) {
        ret = -EOPNOTSUPP;
        qdf_err("Mode is enable But frm is not selected. Invalid frm type");
        return ret;
    }

    if (ic->ic_cfg80211_radio_handler.set_col_6ghz_rnr) {
        ret = ic->ic_cfg80211_radio_handler.set_col_6ghz_rnr(scn, mode, frm_val);
    } else {
        ret = -EOPNOTSUPP;
    }
    return ret;
}

static int wlan_cfg80211_get_6ghz_rnr(struct wiphy *wiphy,
                struct wireless_dev *wdev,
                struct wlan_cfg8011_genric_params *params)
{
    struct ol_ath_softc_net80211 *scn = NULL;
    struct ieee80211com *ic = NULL;
    int retval = 0;
    uint8_t value;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    }
    ic = &scn->sc_ic;
    if (ic->ic_cfg80211_radio_handler.get_col_6ghz_rnr) {
        retval = ic->ic_cfg80211_radio_handler.get_col_6ghz_rnr(scn, &value);
    } else {
        return EOPNOTSUPP;
    }
    cfg80211_reply_command(wiphy, sizeof(uint8_t), &value, 0);

    return retval;
}

static int wlan_cfg80211_get_vdev_tsf(struct wiphy *wiphy,
                                      struct wireless_dev *wdev,
                                      struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    uint64_t value;
    void *cmd;
    int cmd_type;
    wlan_if_t vap = NULL;
    qdf_event_t wait_event;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    qdf_mem_zero(&wait_event, sizeof(wait_event));
    qdf_event_create(&wait_event);
    qdf_event_reset(&wait_event);

    qdf_atomic_init(&(vap->vap_tsf_event));

    if (wlan_get_param(vap, IEEE80211_VDEV_TSF)) {
        qdf_err("Failed to get VDEV TSF");
	return QDF_STATUS_E_FAILURE;
    }

#define TSF_EVENT_TIMEOUT 50 /* 50 ms */
    qdf_wait_single_event(&wait_event, TSF_EVENT_TIMEOUT);

    if (qdf_atomic_read(&(vap->vap_tsf_event)) != 1) {
            IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL,
                              "%s: VAP TSF EVENT FAILED\n", __func__);
        qdf_event_destroy(&wait_event);
        return QDF_STATUS_E_FAILURE;
    }
    qdf_event_destroy(&wait_event);

    value = vap->iv_tsf.iv_tsf;

    if (value == 0 && wlan_vdev_is_up(vap->vdev_obj) == QDF_STATUS_SUCCESS) {
        IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL,
                          "%s: VAP UP but TSF returned 0\n", __func__);
        return QDF_STATUS_E_FAILURE;
    }

    return cfg80211_reply_command(wiphy, sizeof(uint64_t), &value, 0);

}


#if DBG_LVL_MAC_FILTERING
static int wlan_cfg80211_set_dbglvlmac(struct wiphy *wiphy,
                                       struct wireless_dev *wdev,
                                       struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type = 0;
    void *cmd = NULL;
    int  ret = 0;
    uint8_t dbgmac_addr[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(dbgmac_addr, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_err("Invalid mac address");
        return -EINVAL;
    }

    if (ic->ic_cfg80211_radio_handler.set_dbglvlmac) {
        ret = ic->ic_cfg80211_radio_handler.set_dbglvlmac(vap, dbgmac_addr,
                                                          sizeof(dbgmac_addr),
                                                          params->value);
    } else {
        ret = -EOPNOTSUPP;
    }

    return ret;
}

static int wlan_cfg80211_get_dbglvlmac(struct wiphy *wiphy,
                                       struct wireless_dev *wdev,
                                       struct wlan_cfg8011_genric_params *params)
{
#define DBGLVLMAC_STRING 34
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type = 0;
    void *cmd = NULL;
    uint8_t val = 0;
    char string[DBGLVLMAC_STRING];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (ic->ic_cfg80211_radio_handler.get_dbglvlmac) {
        val = ic->ic_cfg80211_radio_handler.get_dbglvlmac(vap, params->value);
    } else {
        return EOPNOTSUPP;
    }

    if (val >= 0) {
        snprintf(string, DBGLVLMAC_STRING, "Num dbgLVLmac peers for vap[%d]: %d",
                 wlan_vdev_get_id(vap->vdev_obj), val);
        return cfg80211_reply_command(wiphy, sizeof(string), &string, 0);
    } else {
        return val;
    }
}
#endif /* DBG_LVL_MAC_FILTERING */

static int wlan_cfg80211_get_ema_config(struct wiphy *wiphy,
                                        struct wireless_dev *wdev,
                                        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic;
    struct ol_ath_softc_net80211 *scn;
    ol_ath_ema_pdev_ctx_t *ema_ctx;
    ol_ath_ema_ctx_t *soc_ema_ctx;
    int val, subtype;
    bool is_mbssid_enabled = true;
    wlan_if_t vap;

    if (params == NULL) {
        qdf_err("NULL params argument.");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    is_mbssid_enabled = wlan_pdev_nif_feat_cap_get(ic->ic_pdev_obj,
                                                   WLAN_PDEV_F_MBSS_IE_ENABLE);

    if(!is_mbssid_enabled) {
        qdf_info("MBSSID Disabled, no non-Tx profile info present");
        return -EINVAL;
    }

    switch (params->value) {
        case IEEE80211_EMA_VAP_CONFIG:
            vap = wlan_cfg80211_extract_vap_intf(wiphy, wdev, params->link_id);
            if (!vap) {
                qdf_err("Command on Invalid Interface");
                return -EINVAL;
            }

            if (params->data) {
                subtype = *(int *)params->data;
            } else {
                qdf_err("Command requires a param <1 (Vendor IE)>/ 0 (Optional IE)>.");
                return -EINVAL;
            }
            switch (subtype) {
                case IEEE80211_PARAM_VENDOR_IE:
                    if (IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap)) {
                        val = vap->iv_mbss.total_vendor_ie_size;
                    } else {
                        qdf_err("Request is not relevant for Tx-vap");
                        return -EINVAL;
                    }
                    break;
                case IEEE80211_PARAM_OPTIONAL_IE:
                    val = vap->iv_mbss.total_optional_ie_size;
                    break;
                default:
                    qdf_err("Invalid vap config request.");
                    return -EINVAL;
                    break;
            }
            break;
        case IEEE80211_EMA_IC_CONFIG:
            if (params->data) {
                subtype = *(int *)params->data;
            } else {
                qdf_err("Command requires subcase param.");
                return -EINVAL;
            }
            switch (subtype) {
                case IEEE80211_PARAM_NTX_PFL_SIZE:
                    val = ic->ic_mbss_ctx->non_tx_profile_size;
                    break;
                case IEEE80211_PARAM_MAX_PP:
                    scn     = OL_ATH_SOFTC_NET80211(ic);
                    ema_ctx = &scn->ema_ctx;
                    soc_ema_ctx = &scn->soc->ema_ctx;
                    val = soc_ema_ctx->max_pp;

                    if (soc_ema_ctx->max_pp > 1) {
                        /* Attribute 20 contains group_id */
                        uint8_t grp_id = params->length;
                        struct mbssid_context *mbss_ctx = ic->ic_mbss_ctx;

                        if (!ieee80211_mbssid_get_num_beaconing_ap_vaps_up(ic, grp_id)) {
                            if (grp_id < ema_ctx->max_ngroups) {
                                if (mbss_ctx->ic_mbss[grp_id].transmit_vap) {
                                    if (ic->ic_ema_config_init(
                                        mbss_ctx->ic_mbss[grp_id].transmit_vap)) {
                                        qdf_err("error calculating new max_pp");
                                        return -EINVAL;
                                    }
                                    val = mbss_ctx->ic_mbss[grp_id].max_pp;
                                } else {
                                    qdf_err("No Tx-VAP set so max_pp cannot be calculated");
                                    return -EINVAL;
                                }
                            } else {
                                val = soc_ema_ctx->max_pp;
                            }
                        } else {
                            val = mbss_ctx->ic_mbss[grp_id].max_pp;
                        }
                    }
                    break;
                default:
                    qdf_err("Invalid IC config request.");
                    return -EINVAL;
                    break;
            }
            break;

        default:
            qdf_err("Invalid request");
            return -EINVAL;
    }
        return cfg80211_reply_command(wiphy, sizeof(int), &val, 0);
}

/**
 * wlan_cfg80211_get_acs_precac_status: Get channel status information.
 *
 * NOTE: This function is temporary and will be removed once the corresponding
 *       vendor command has been upstreamed.
 *
 * @wiphy : Pointer to wiphy
 * @wdev  : Pointer to wdev
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 for success or corresponding error code for failure.
 */
static int wlan_cfg80211_get_acs_precac_status(struct wiphy *wiphy,
                                      struct wireless_dev *wdev,
                                      struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int cmd_type = -1;
    void *radioctx = NULL;
    int chan_ix = 0, precac_chan_ix = 0;
    struct precac_channel_status_list *precac_channel_list;
    struct regulatory_channel *cur_chan_list;
    int ret;
    struct ieee80211_ath_channel channel = empty_channel;

    /*
     * QCA_NL80211_VENDOR_SUBCMD_GET_ACS_PRECAC_SUPPORT is currently expected to
     * send a preCAC status for a list of channel described by its primary
     * center frequency.
     */

    if (params == NULL) {
        qdf_err("NULL params argument.");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    radioctx = extract_command(ic, wdev, &cmd_type, params->link_id);

    /*
     * Additional sanity checks for the command. Note that though we don't need
     * the radio context obtained above, we sanity check it as a precaution.
     */
    if (radioctx == NULL) {
        qdf_err("NULL radio context obtained from command. Sanity check "
                "failed. Investigate.");
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command is not on radio interface");
        return -EINVAL;
    }

    /*
     * If the ACS precac support is disabled (or) if the DFS precac list is
     * empty, then send an empty channel list.
     */
    if (!ic->ic_acs_precac_completed_chan_only ||
        (mlme_dfs_precac_status_for_channel(ic->ic_pdev_obj,
                      &channel) == DFS_NO_PRECAC_COMPLETED_CHANS)) {
        qdf_info("Sending empty channel list");
        goto send_empty;
    }

    /*
     * Allocate data for max channel size. However, when sending through
     * cfg80211, send only the buffer size limited by the channels to be
     * sent.
     */
    precac_channel_list = qdf_mem_malloc(sizeof(*precac_channel_list) *
                                         IEEE80211_CHAN_MAX);
    if (!precac_channel_list) {
        qdf_err("Could not allocate data for the precac channel list");
        return -ENOMEM;
    }

    cur_chan_list = qdf_mem_malloc(NUM_CHANNELS * sizeof(*cur_chan_list));
    if (!cur_chan_list) {
        qdf_err("Could not allocate data for the regulatory channel list");
        qdf_mem_free(precac_channel_list);
        return -ENOMEM;
    }

    if (wlan_reg_get_current_chan_list(ic->ic_pdev_obj, cur_chan_list) !=
        QDF_STATUS_SUCCESS) {
        qdf_err("Failed to get cur_chan list");
        qdf_mem_free(precac_channel_list);
        qdf_mem_free(cur_chan_list);
        return -EINVAL;
    }

    for (chan_ix = 0; chan_ix < NUM_CHANNELS; chan_ix++) {
        uint16_t chan_freq = cur_chan_list[chan_ix].center_freq;

        if (cur_chan_list[chan_ix].chan_flags & REGULATORY_CHAN_DISABLED)
            continue;

        /* Skip non-DFS channels */
        if (!(cur_chan_list[chan_ix].chan_flags & REGULATORY_CHAN_RADAR))
            continue;

        precac_channel_list[precac_chan_ix].chan_freq = chan_freq;

        /* Fill 20MHz temporary channel for DFS preCAC status API. */
        channel.ic_freq =              cur_chan_list[chan_ix].center_freq;
        channel.ic_ieee =              cur_chan_list[chan_ix].chan_num;
        channel.ic_vhtop_freq_seg1 =   cur_chan_list[chan_ix].center_freq;
        channel.ic_vhtop_ch_num_seg1 = cur_chan_list[chan_ix].chan_num;
        channel.ic_flags =             IEEE80211_CHAN_A;
        channel.ic_flagext =           IEEE80211_CHAN_DFS;

        switch(mlme_dfs_precac_status_for_channel(ic->ic_pdev_obj, &channel)) {
            case DFS_PRECAC_REQUIRED_CHAN:
                precac_channel_list[precac_chan_ix].precac_status = PRECAC_STATUS_PENDING;
                break;

            case DFS_PRECAC_COMPLETED_CHAN:
            case DFS_INVALID_PRECAC_STATUS:
            default:
                /*
                 * For all other codes other than required, send in a clear
                 * flag.
                 */
                precac_channel_list[precac_chan_ix].precac_status = PRECAC_STATUS_CLEAR;
                break;
        }

        precac_chan_ix++;

        if (precac_chan_ix == IEEE80211_CHAN_MAX) {
            break;
        }
    }
    qdf_mem_free(cur_chan_list);

    if (!precac_chan_ix) {
        qdf_err("Could not find set precac status for DFS channels");
        qdf_mem_free(precac_channel_list);
        return -EINVAL;
    }

    qdf_info("Sending %u channels in the preCAC status channel list", precac_chan_ix);
    ret = cfg80211_reply_command(wiphy,
                                (sizeof(*precac_channel_list) * precac_chan_ix),
                                (void *)(precac_channel_list),
                                0);

    if (precac_channel_list) {
        qdf_mem_free(precac_channel_list);
    }

    return ret;

send_empty:
    /*
     * ICM requires an empty channel list to disable preCAC rejection.
     */
    return cfg80211_reply_command(wiphy, 0, NULL, 0);
}

/**
 * wlan_cfg80211_get_pri20_blockchanlist : Get list of channels blocked for
 * usage as primary 20 MHz (applicable only for channel selection algorithms)
 * @wiphy: pointer to wiphy
 * @wdev: pointer to wireless_wdev
 * @params: pointer to wlan_cfg8011_genric_params
 *
 * Return: 0 for success or error code
 */
static int wlan_cfg80211_get_pri20_blockchanlist(struct wiphy *wiphy,
            struct wireless_dev *wdev,
            struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int cmd_type = -1;
    void *radioctx = NULL;
    uint32_t source_array_size = 0;

    /*
     * QCA_NL80211_VENDOR_SUBCMD_GET_PRI20_BLOCKCHANLIST is currently expected
     * to return primary 20 MHz center frequency values each having a size equal
     * to that of uint16_t, if the block channel list is non-empty. Enforce this
     * sizing.
     */
    qdf_assert_always(sizeof(ic->ic_pri20_cfg_blockchanlist.freq[0]) ==
            sizeof(uint16_t));

    if (params == NULL) {
        qdf_err("NULL params argument.");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    radioctx = extract_command(ic, wdev, &cmd_type, params->link_id);

    /*
     * Additional sanity checks for the command. Note that though we don't need
     * the radio context obtained above, we sanity check it as a precaution.
     */
    if (radioctx == NULL) {
        qdf_err("NULL radio context obtained from command. Sanity check "
                "failed. Investigate.");
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command is not on radio interface");
        return -EINVAL;
    }

    source_array_size = QDF_ARRAY_SIZE(ic->ic_pri20_cfg_blockchanlist.freq);
    if (ic->ic_pri20_cfg_blockchanlist.n_freq > source_array_size) {
        qdf_err("Number of channels indicated in source blocked chan list %hu "
                "exceeds source blocked chan list array size %u.",
                ic->ic_pri20_cfg_blockchanlist.n_freq, source_array_size);
        return -EINVAL;
    }

    if (ic->ic_pri20_cfg_blockchanlist.n_freq) {
        return cfg80211_reply_command(wiphy,
                    ic->ic_pri20_cfg_blockchanlist.n_freq *
                        sizeof(ic->ic_pri20_cfg_blockchanlist.freq[0]),
                    (void*)(&(ic->ic_pri20_cfg_blockchanlist.freq[0])), 0);
    } else {
        return cfg80211_reply_command(wiphy, 0, NULL, 0);
    }
}

/**
 * wlan_cfg80211_get_chan_rf_characterization_info : Get channel RF
 * characterization information (intended only for channel selection algorithms)
 * @wiphy: pointer to wiphy
 * @wdev: pointer to wireless_wdev
 * @params: pointer to wlan_cfg8011_genric_params
 *
 * Return: 0 for success or error code
 */
static int wlan_cfg80211_get_chan_rf_characterization_info(struct wiphy *wiphy,
            struct wireless_dev *wdev,
            struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int cmd_type = -1;
    void *radioctx = NULL;
#ifdef WLAN_SUPPORT_RF_CHARACTERIZATION
    struct ol_ath_softc_net80211 *scn = NULL;
    ol_ath_soc_softc_t *soc = NULL;
#endif /* WLAN_SUPPORT_RF_CHARACTERIZATION */

    if (params == NULL) {
        qdf_err("NULL params argument.");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (ic == NULL) {
        qdf_err("NULL ic obtained from cfg80211 context. Investigate.");
        return -EINVAL;
    }

    radioctx = extract_command(ic, wdev, &cmd_type, params->link_id);

    /*
     * Additional sanity checks for the command. Note that though we don't need
     * the radio context obtained above, we sanity check it as a precaution.
     */
    if (radioctx == NULL) {
        qdf_err("NULL radio context obtained from command. Sanity check "
                "failed. Investigate.");
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command is not on radio interface");
        return -EINVAL;
    }

#ifdef WLAN_SUPPORT_RF_CHARACTERIZATION
#if ATH_ACS_DEBUG_SUPPORT
    if (ic->ic_acs_debug_support)
        acs_debug_add_rf_char_info(ic->ic_acs);
#endif /* ATH_ACS_DEBUG_SUPPORT */

    scn = OL_ATH_SOFTC_NET80211(ic);
    if (scn == NULL) {
        qdf_err("NULL scn obtained from ic. Investigate.");
        return -EINVAL;
    }

    soc = scn->soc;
    if (!soc) {
        qdf_err("NULL soc obtained from scn. Investigate.");
        return -EINVAL;
    }

    if (!soc->num_rf_characterization_entries) {
        return cfg80211_reply_command(wiphy, 0, NULL, 0);
    } else {
        if (!soc->rf_characterization_entries) {
            qdf_err("Pointer to RF characterization entries is NULL");
            return -ENOMEM;
        }

        return cfg80211_reply_command(wiphy,
                    soc->num_rf_characterization_entries *
                        sizeof(soc->rf_characterization_entries[0]),
                    soc->rf_characterization_entries,
                    0);
    }
#else
    return cfg80211_reply_command(wiphy, 0, NULL, 0);
#endif /* WLAN_SUPPORT_RF_CHARACTERIZATION */
}

/**
 * wlan_cfg80211_set_gpio_config :set the gpio configuration
 * @wiphy: pointer to wiphy
 * @wdev: pointer to wireless_wdev
 * @data: pointer to data
 * @data_len: data length
 */
static int wlan_cfg80211_set_gpio_config(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    struct ieee80211com *ic = NULL;
    struct wlan_objmgr_psoc *psoc = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (ic->ic_wdev.netdev != wdev->netdev) {
         qdf_err("IC retrieved is not of radio");
          return -1;
    }

    if ((data == NULL) || (!data_len)) {
        qdf_print("%s: invalid data length data ptr: %pK ", __func__, data);
        return -1;
    }

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if (!psoc) {
        qdf_info("gpio psoc obj is null");
        return -1;
    }

    return  wlan_cfg80211_start_gpio_config(wiphy, psoc, data, data_len);
}

static int wlan_cfg80211_set_mgmt_rssi_thr(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    int value = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    }

    if(params->data) {
        value = *(int *)(params->data);
    } else {
        qdf_info("Invalid Arguments ");
        return -EINVAL;
    }

    if (value < SNR_MIN || value > SNR_MAX) {
        qdf_print("invalid value: %d, RSSI is between 1-127 ", value);
        return -EINVAL;
    }
    ic->mgmt_rx_snr = value;

    qdf_print("%s: value=%d", __func__, value);

    return ret;
}

/* set desired bssid using nl80211 */
static int wlan_cfg80211_set_bssid(struct wiphy *wiphy,
            struct wireless_dev *wdev,
            struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_print("Invalid mac address ");
        return -EINVAL;
    }

    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s :%s \n", __func__, ether_sprintf(mac));

    ret = ieee80211_ucfg_set_ap(vap, &mac);

    return ret;
}

static int wlan_cfg80211_get_bssid(struct wiphy *wiphy,
            struct wireless_dev *wdev,
            struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type ,ret = 0;
    void *cmd;
    u_int8_t bssid[QDF_MAC_ADDR_SIZE];
    struct ether_addr *data = (struct ether_addr *) &params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }
    ret = ieee80211_ucfg_get_ap(vap, bssid);
    qdf_mem_copy(&data->octet,bssid,QDF_MAC_ADDR_SIZE);
    cfg80211_reply_command(wiphy, QDF_MAC_ADDR_SIZE, &bssid, 0);

    return ret;
}

static int wlan_cfg80211_get_mgmt_rssi_thr(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int cmd_type ,ret = 0;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    }

    cfg80211_reply_command(wiphy, 4, &(ic->mgmt_rx_snr), 0);

    return ret;
}

static int wlan_cfg80211_get_wmm_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    int wmmparam, ac, bss, value;

    void *cmd;
    u_int32_t *data = (u_int32_t *) params->data;

    if(data == NULL) {
        qdf_print("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    }

    wmmparam = params->value;
    ac = (data[0] < WME_NUM_AC) ? data[0] : WME_AC_BE;
    bss = params->length;
    value = ieee80211_ucfg_getwmmparams((void *)osifp, wmmparam, ac, bss);
    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: wmmparam: %d ac: %d bss: %d value: %d \n", __func__, wmmparam, ac, bss, value);
    return cfg80211_reply_command(wiphy, sizeof(u_int32_t), &value, 0);

}

/*
 * wlan_cfg80211_set_block_mgt:
 * Enables blocking mgmt frames from a particular mac
 */
static int wlan_cfg80211_set_block_mgt(struct wiphy *wiphy,
                struct wireless_dev *wdev,
                struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;

    wlan_if_t vap = NULL;
    int cmd_type, retval = 0;
    void *cmd;
    uint8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Command on Invalid Interface\n");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if(params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_print("Invalid MAC Address!\n");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    retval = wlan_set_acl_block_mgmt(vap, mac, TRUE);

    return retval;
}

/*
 * wlan_cfg80211_clr_block_mgt:
 * Disables blocking mgmt frames from a particular mac
 */
static int wlan_cfg80211_clr_block_mgt(struct wiphy *wiphy,
                struct wireless_dev *wdev,
                struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;

    wlan_if_t vap = NULL;
    int cmd_type, retval = 0;
    void *cmd;
    uint8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Command on Invalid Interface\n");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if(params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_print("Invalid MAC Address!\n");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    retval = wlan_set_acl_block_mgmt(vap, mac, FALSE);

    return retval;
}

/*
 * wlan_cfg80211_get_block_mgt:
 * Get the list of addresses for which blocking mgmt frames is set
 */
static int wlan_cfg80211_get_block_mgt(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    u_int8_t *mac_list;
    int i, rc, num_mac;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print(" Command on invalid interface\n");
        return -EINVAL;
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        vap = (wlan_if_t)cmd;
    }

    /* read and send mac list to application */
    mac_list = (u_int8_t *)OS_MALLOC(osifp->os_handle,
                                     (QDF_MAC_ADDR_SIZE * 256), GFP_KERNEL);
    if (!mac_list)
        return -EFAULT;

    rc = wlan_get_acl_list(vap, mac_list, (QDF_MAC_ADDR_SIZE * 256),
                           &num_mac, IEEE80211_ACL_FLAG_ACL_LIST_1);
    if (rc) {
        OS_FREE(mac_list);
        return -EFAULT;
    }

    for (i = 0; i < num_mac; i++) {
        if (wlan_acl_is_block_mgmt_set(vap,
                                       &mac_list[i * QDF_MAC_ADDR_SIZE])) {
            memcpy(&mac, &mac_list[i * QDF_MAC_ADDR_SIZE], QDF_MAC_ADDR_SIZE);
            cfg80211_reply_command(wiphy, QDF_MAC_ADDR_SIZE, &mac, 0);
        }
    }
    OS_FREE(mac_list);
    return 0;
}

#ifdef WLAN_FEATURE_11BE_MLO
#define MAX_BPCC_LINK_ID_VAL 15
/*
 * wlan_cfg80211_get_link_id_bpcc_val:
 * Get the Link-Id and BPCC count for MLD vap and its partner
 */
static int wlan_cfg80211_get_link_id_bpcc_val(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    int cmd_type, i, num_links = 0;
    void *cmd;
    struct mlo_link_id_bpcc_count get_bpcc_link_id[MLD_MAX_LINKS];
    char str[MAX_BPCC_LINK_ID_VAL];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err(" Command on invalid interface\n");
        return -EINVAL;
    } else {
        osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
        vap = (wlan_if_t)cmd;
    }

    num_links = ieee80211_get_link_id_bpcc_val(vap, get_bpcc_link_id);
    if (num_links == -1) {
        qdf_err("Error while getting Link-Id and BPCC count for Vdev:%s", vap->iv_netdev_name);
        return -EINVAL;
    }

    for (i = 0; i < num_links; i++) {
         snprintf(str, MAX_BPCC_LINK_ID_VAL, "0x%X, 0x%X", get_bpcc_link_id[i].bpcc_link_id[0],
                  get_bpcc_link_id[i].bpcc_link_id[1]);
         cfg80211_reply_command(wiphy, sizeof(str), str, 0);
    }
    return 0;
}
#undef MAX_BPCC_LINK_ID_VAL
#endif

static int wlan_cfg80211_addie(struct wiphy *wiphy, struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig_ie *ie_buffer;
    int ret;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        QDF_PRINT_INFO(QDF_PRINT_IDX_SHARED, QDF_MODULE_ID_ANY,
                       QDF_TRACE_LEVEL_ERROR, "Command on invalid interface\n");
        ret = -EINVAL;
        goto exit;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ie_buffer = (struct ieee80211_wlanconfig_ie *)params->data;
    if (!ie_buffer) {
        ret = -EINVAL;
        goto exit;
    }

    /* If EMA Ext is enabled, add IE to the AppIE list only if enough Non-Tx Profile space is available*/
    if (IS_MBSSID_EMA_EXT_ENABLED(ic) &&
            IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap) &&
            ((ie_buffer->ftype == IEEE80211_APPIE_FRAME_BEACON) ||
             (ie_buffer->ftype == IEEE80211_APPIE_FRAME_PROBE_RESP))) {
        int ie_size = ie_buffer->ie.len + 2;
        int32_t *space_left =
            (ie_buffer->ftype == IEEE80211_APPIE_FRAME_BEACON) ? (&vap->iv_mbss.available_bcn_optional_ie_space) : (&vap->iv_mbss.available_prb_optional_ie_space);

        switch (ie_buffer->ie.elem_id) {
        case IEEE80211_ELEMID_VENDOR:
            if (ie_size > vap->iv_mbss.available_vendor_ie_space) {
                qdf_err("Vendor IE size %d beyond available size %d."
                        " Cannot add to beacon/probe response.",
                        ie_size, vap->iv_mbss.available_vendor_ie_space);
                ret = -ENOMEM;
            } else {
                ret = ieee80211_ucfg_addie(vap, ie_buffer);
                if (!ret)
                    vap->iv_mbss.available_vendor_ie_space -= ie_size;
            }
            break;
        default:
            if (ie_size > *space_left) {
                qdf_err("IE size %d beyond available size %d."
                        " Cannot add to beacon/probe response.",
                        ie_size, *space_left);
                ret = -ENOMEM;
            } else {
                ret = ieee80211_ucfg_addie(vap, ie_buffer);
                if (!ret)
                    *space_left = *space_left - ie_size;
            }
            break;
        }
    } else {
        ret = ieee80211_ucfg_addie(vap, ie_buffer);
    }

exit:
    return ret;
}

#if UMAC_SUPPORT_ACFG
/*
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed 1895
 *
 * Return: 0 on success, negative errno on failure
 */
static int
wlan_cfg80211_acfg(struct wiphy *wiphy, struct wireless_dev *wdev, const void *data, int data_len)
{
    /* Need link id for vap command */
    struct ieee80211com *ic = NULL;
    struct net_device *dev = NULL;
    int err = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (ic->ic_wdev.netdev == wdev->netdev) {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_NORMAL, IEEE80211_MSG_IOCTL,
                "%s: Radio Command\n", __func__);
        dev = wdev->netdev;
        if ((dev != NULL) && (data != NULL)){
            err = ic->ic_acfg_cmd(dev, (void *)data);
            if (!err) {
                err = cfg80211_reply_command(wiphy, sizeof(acfg_os_req_t), (void *)data, 0);
            }
        }
    } else {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_NORMAL, IEEE80211_MSG_IOCTL,
                "%s: VAP Command\n", __func__);
        dev = wdev->netdev;
        if ((dev != NULL) && (data != NULL)) {
            err = acfg_handle_vap_config(dev, (void *)data);
            if (!err) {
                err = cfg80211_reply_command(wiphy, sizeof(acfg_os_req_t), (void *)data, 0);
            }
        }
    }

    return err;
}
#endif

#ifdef WLAN_SUPPORT_RX_PROTOCOL_TYPE_TAG
#ifdef WLAN_SUPPORT_RX_TAG_STATISTICS
/*
 * wlan_cfg80211_dump_rx_pkt_protocol_tag_stats:
 * Get the protocol tag statistics for the given protocol type. If protocol
 * type is 255, dump tag statistics for all the supported protocol types.
 */
static int wlan_cfg80211_dump_rx_pkt_protocol_tag_stats(struct wiphy *wiphy, struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct net_device *dev = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int return_val = -EOPNOTSUPP;
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    qdf_info("Protocol Tag Stats: PKT_TYPE = %u\n", params->value);

    if (ic->ic_wdev.netdev == wdev->netdev) {
        dev = wdev->netdev;
        scn = get_radio_device_context(wiphy, dev);
        if (ic->ic_cfg80211_radio_handler.ic_dump_rx_pkt_protocol_tag_stats)
            return_val = ic->ic_cfg80211_radio_handler.ic_dump_rx_pkt_protocol_tag_stats((void*)scn, params->value);
    }
    else
        return_val = -EOPNOTSUPP;

    return return_val;

}
#endif /* WLAN_SUPPORT_RX_TAG_STATISTICS */

/*
 * wlan_cfg80211_rx_pkt_protocol_tag:
 * Add/delete given tag (or metadata) for the given protocol type. The
 * programmed metadata is tagged on the QDF packet if the received packet
 * type matches the programmed packet type.
 */
static int wlan_cfg80211_rx_pkt_protocol_tag(struct wiphy *wiphy, struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct net_device *dev = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct ieee80211_rx_pkt_protocol_tag protocol_tag_info;
    int return_val = -EOPNOTSUPP;
    uint32_t *data_ptr = (uint32_t *)params->data;
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    protocol_tag_info.op_code = params->value;
    protocol_tag_info.pkt_type = data_ptr[0];
    protocol_tag_info.pkt_type_metadata = params->length;

    qdf_info("Protocol Tag Info: OPCODE = %d, PKT_TYPE = %u, METADATA = %u\n",
            protocol_tag_info.op_code, protocol_tag_info.pkt_type, protocol_tag_info.pkt_type_metadata);

    if (ic->ic_wdev.netdev == wdev->netdev) {
        dev = wdev->netdev;
        scn = get_radio_device_context(wiphy, dev);
        if (ic->ic_cfg80211_radio_handler.ic_set_rx_pkt_protocol_tagging)
            return_val = ic->ic_cfg80211_radio_handler.ic_set_rx_pkt_protocol_tagging((void*)scn, &protocol_tag_info);
    }
    else
        return_val = -EOPNOTSUPP;

    return return_val;
}
#endif /* WLAN_SUPPORT_RX_PROTOCOL_TYPE_TAG */

/* wlan_cfg80211_wmistats - get wmi cp stats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @param:   config param
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_wmistats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    void *cmd;
    int cmd_type;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command is not on radio interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;

        if(ic->ic_cfg80211_radio_handler.get_cp_wmi_stats) {
            ic->ic_cfg80211_radio_handler.get_cp_wmi_stats((void*)scn, (void*)params->data, params->data_len);
        } else  {
            return -EOPNOTSUPP;
        }
    }

    return 0;
}

int wlan_cfg80211_halphystats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    void *cmd;
    int cmd_type;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command is not on radio interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;

        if(ic->ic_cfg80211_radio_handler.get_cp_halphy_stats) {
            ic->ic_cfg80211_radio_handler.get_cp_halphy_stats((void*)scn, (void*)params->data, params->data_len);
        } else  {
            return -EOPNOTSUPP;
        }
    }

    return 0;

}

/* wlan_cfg80211_get_target_pdevid - get target pdev id
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @param:   config param
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_get_target_pdevid(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    uint32_t val;
    void *cmd;
    int cmd_type;
    int ret_val = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command is not on radio interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
        if(ic->ic_cfg80211_radio_handler.get_target_pdev_id) {
            ret_val = ic->ic_cfg80211_radio_handler.get_target_pdev_id((void*)scn, &val);
            if (ret_val == 0) {
                cfg80211_reply_command(wiphy, sizeof(u_int32_t), &val, 0);
            }
        } else  {
            return -EOPNOTSUPP;
        }
    }

    return 0;
}

uint8_t compute_and_populate_chan_util(struct ieee80211com *ic,
                                       struct spl_vap_chan_util *chan_utils)
{
    struct channel_stats *chan_stats;
    uint8_t i, j = 0;

    if (!ic || !ic->ic_channel_stats.scan_chan_stats) {
        qdf_err("ic or chan_stats is NULL");
        return 0;
    }

    chan_stats = ic->ic_channel_stats.scan_chan_stats;
    qdf_spin_lock_bh(&ic->ic_channel_stats.lock);
    for (i = 0; i < NUM_CHANNELS; i++) {
        if (chan_stats[i].cycle_cnt) {
            chan_utils[j].freq = chan_stats[i].freq;
            chan_utils[j].chan_nf = chan_stats[i].chan_nf;
            chan_utils[j].chan_util = div64_u64(((chan_stats[i].clear_cnt) * 100),
                                                chan_stats[i].cycle_cnt);
            j++;
        }
    }
    qdf_spin_unlock_bh(&ic->ic_channel_stats.lock);
    return j;
}

int wlan_cfg80211_get_cur_chan_util(struct ieee80211com *ic)
{
    struct spl_vap_chan_util *chan_utils;
    uint8_t num_entry;

    chan_utils = (struct spl_vap_chan_util *)qdf_mem_malloc(sizeof(struct spl_vap_chan_util) * NUM_CHANNELS);
    if (!chan_utils) {
        qdf_err("Failed to allocate chan_utils");
        return -EINVAL;
    }

    num_entry = compute_and_populate_chan_util(ic, chan_utils);

    if (!num_entry) {
        qdf_err("no entry for channel utilization");
        qdf_mem_free(chan_utils);
        return -EINVAL;
    }

    cfg80211_reply_command(ic->ic_wiphy,
                           sizeof(struct spl_vap_chan_util) * num_entry,
                           chan_utils, 0);
    qdf_mem_free(chan_utils);
    return 0;
}

#if !(defined REMOVE_PKT_LOG) && (defined PKTLOG_DUMP_UPLOAD_SSR)
static int
wlan_cfg80211_set_pktlog_dump_ssr(struct wiphy *wiphy,
                                  struct wireless_dev *wdev,
                                  struct wlan_cfg8011_genric_params *params)
{
    struct ol_ath_softc_net80211 *scn = NULL;
    struct ieee80211com *ic = NULL;
    int cmd_type;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    scn->upload_pktlog = params->value;

    return 0;
}

static int
wlan_cfg80211_get_pktlog_dump_ssr(struct wiphy *wiphy,
                                  struct wireless_dev *wdev,
                                  struct wlan_cfg8011_genric_params *params)
{
    struct ol_ath_softc_net80211 *scn = NULL;

    scn = wlan_cfg80211_extract_radio_intf(wiphy, wdev);
    if (!scn) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    }

    cfg80211_reply_command(wiphy, sizeof(uint32_t), &(scn->upload_pktlog), 0);
    return 0;
}
#endif

/**
 * wlan_cfg80211_get_oper_reg_info: Dump operating regulatory information
 *                                  channel, freq, band, width, country,
 *                                  opclass
 *
 * @wiphy: pointer to wiphy object
 * @wdev: pointer to device
 * @params: command params
 *
 * Returns 0 on success and -ve value on failure
 */
static int wlan_cfg80211_get_oper_reg_info(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ol_ath_softc_net80211 *scn = NULL;
    struct ieee80211com *ic = NULL;
    int cmd_type;
    uint8_t chan, opclass;
    uint16_t chwidth, freq;
    enum wlan_band_id band_id;
    char buffer[100];
    char country[ISO_NAME_SIZE + 1];
    int ret = 0;

    qdf_mem_zero(country, sizeof(country));

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)extract_command(ic, wdev, &cmd_type, params->link_id);
    if (!cmd_type) {
        qdf_err("Command on invalid interface");
        ret = -EINVAL;
        goto exit;
    }

    if(!scn) {
        qdf_err("scn is NULL");
        ret = -EINVAL;
        goto exit;
    }

    chan = ic->ic_curchan->ic_ieee;
    freq = ic->ic_curchan->ic_freq;

    band_id = reg_wifi_band_to_wlan_band_id(wlan_reg_freq_to_band(freq));

    if (!IEEE80211_IS_CHAN_VALID(ic->ic_curchan) ||
            band_id < 0) {
        ret = -EINVAL;
        goto exit;
    }

    chwidth = ieee80211_get_chan_width(ic->ic_curchan);

    if (!ic->ic_cfg80211_radio_handler.getcountry) {
        ret = -EOPNOTSUPP;
        goto exit;
    }

    ic->ic_cfg80211_radio_handler.getcountry((void *)scn, country);
    opclass = regdmn_get_opclass(country, ic->ic_curchan);
    country[ISO_NAME_SIZE-1] = '\0';

    qdf_mem_zero(buffer, sizeof(buffer));
    snprintf(buffer, sizeof(buffer), "chan=%u, freq=%uMHz, band=%s,"
            " chwidth=%uMHz, country=%s, opclass=%u", chan, freq,
            get_wlan_band_id_to_string(band_id), chwidth, country, opclass);

    ret = cfg80211_reply_command(wiphy, sizeof(buffer), buffer, 0);

exit:
    return ret;
}

static int wlan_cfg80211_get_partial_bssid_bitmap(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define PARTIAL_BSSID_BITMAP_ARGS      2
#define PARTIAL_BSSID_BITMAP_STRING    20
    struct ieee80211com *ic = NULL;
    int ret = 0;
    uint32_t val[PARTIAL_BSSID_BITMAP_ARGS] = {0};
    char str[PARTIAL_BSSID_BITMAP_STRING];
    int cmd_type;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("IC is null");
        return -EINVAL;
    }

    extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd_type) {
        qdf_err("Command on Invalid interface");
        return -EINVAL;
    }

    ret = ieee80211_ucfg_get_partial_bssid_bitmap(ic, val);
    if (!ret) {
        snprintf(str, PARTIAL_BSSID_BITMAP_STRING,
                "0x%08X %08X", val[1], val[0]);

        cfg80211_reply_command(wiphy, sizeof(str), str, 0);
    }

    return ret;
}

static int
wlan_cfg80211_athkey_set_key(struct wiphy *wiphy, struct wireless_dev *wdev,
                             struct wlan_cfg8011_genric_params *params)
{
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    struct ieee80211req_key *ik = (struct ieee80211req_key *)params->data;
    ieee80211_keyval req_key;
    int error = -1;

    osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    if (!osifp) {
        qdf_err("NULL osifp");
        return -1;
    }

    vap = osifp->os_if;
    if (vap == NULL) {
        qdf_warn("%s: VAP is null ", __func__);
        return -1;
    }

    qdf_mem_zero(&req_key, sizeof(ieee80211_keyval));
    if (ik->ik_keylen > (WLAN_CRYPTO_KEYBUF_SIZE +
        WLAN_CRYPTO_MICBUF_SIZE)) {
        return -1;
    }
    req_key.keylen = ik->ik_keylen;
    req_key.keyrsc = ik->ik_keyrsc;
    req_key.keytsc = ik->ik_keytsc;
    req_key.keytype = ik->ik_type;
    req_key.flags = ik->ik_flags;
    req_key.macaddr = ik->ik_macaddr;
    req_key.keydata = ik->ik_keydata;

    error = wlan_set_key(vap, ik->ik_keyix, &req_key);
    /* Zero-out local key variables */
    qdf_mem_zero(&req_key, sizeof(ieee80211_keyval));
    return error;
}

static int
wlan_cfg80211_athkey_get_key(struct wiphy *wiphy, struct wireless_dev *wdev,
                             struct wlan_cfg8011_genric_params *params)
{
    wlan_if_t vap = NULL;
    struct ieee80211req_key *ik = (struct ieee80211req_key *)params->data;
    ieee80211_keyval req_key = {0};
    int error = -1;

    vap = wlan_cfg80211_extract_vap_intf(wiphy, wdev, params->link_id);
    if (vap == NULL) {
        qdf_warn("%s: VAP is null ", __func__);
        return -1;
    }
    req_key.keydata = ik->ik_keydata;
    if (wlan_get_key(vap, ik->ik_keyix, ik->ik_macaddr, &req_key,
                         IEEE80211_KEYBUF_SIZE+IEEE80211_MICBUF_SIZE,
                         GET_PN_ENABLE) != 0)
        return -1;

    ik->ik_type = req_key.keytype;
    ik->ik_keylen = req_key.keylen;
    ik->ik_keyix  = req_key.keyindex;
    ik->ik_keyrsc = req_key.keyrsc;
    ik->ik_keytsc = req_key.keytsc;
    qdf_mem_copy(ik->ik_keydata, req_key.keydata, ik->ik_keylen);
    error = cfg80211_reply_command(wiphy, params->data_len, ik, 0);

    /* Zero-out local key variables */
    qdf_mem_zero(&req_key, sizeof(ieee80211_keyval));
    return error;
}

static int
wlan_cfg80211_athkey_del_key(struct wiphy *wiphy, struct wireless_dev *wdev,
                             struct wlan_cfg8011_genric_params *params)
{
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    struct ieee80211req_del_key *ik = (struct ieee80211req_del_key *)params->data;

    osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    if (!osifp) {
        qdf_err("osifp NULL");
        return -1;
    }

    vap = osifp->os_if;
    if (vap == NULL) {
        qdf_warn("%s: VAP is null ", __func__);
        return -1;
    }
    return wlan_del_key(vap, ik->idk_keyix, ik->idk_macaddr);
}

#ifdef WLAN_FEATURE_11BE_MLO
static inline int
wlan_cfg80211_update_mctbl_mldev(struct wireless_dev *wdev,
                                 struct wlan_cfg8011_genric_params *params)
{
    struct osif_mldev *mldev;
    osif_dev *link_osifp = NULL;
    int i,j;

    mldev = osif_mld_get_mldev(wdev->netdev);
    if (!mldev)
        return -EINVAL;

    for (i = 0; i < MAX_MLO_CHIPS; i++) {
         for(j = 0; j < MAX_PDEV_PER_SOC; j++) {
             link_osifp = mldev->link_dev[i][j];
             if(!link_osifp)
                continue;

#ifdef WLAN_FEATURE_11BE_MLO
             if ((IEEE80211_M_HOSTAP == link_osifp->os_opmode) &&
                 (MLD_AP_HYBRID_NONBOND_MODE ==
                  cfg_get(wlan_vdev_get_psoc(link_osifp->os_if->vdev_obj),
                          CFG_OL_MLDEV_AP_MODE))) {
                 params->flags |= DP_ME_MCTBL_MLD_VDEV;
             }
#endif
             wlan_update_hifitbl(link_osifp->os_if->vdev_obj,
                                 params->data, params->data_len,
                                 params->flags);
       }
   }

    /* update the mctbl for bridge vap */
    for (i = 0; i < MAX_MLO_CHIPS; i++) {
         for(j = 0; j < MAX_PDEV_PER_SOC; j++) {
             link_osifp = mldev->bridge_dev[i][j];
             if(!link_osifp)
                continue;

#ifdef WLAN_FEATURE_11BE_MLO
             if ((IEEE80211_M_HOSTAP == link_osifp->os_opmode) &&
                 (MLD_AP_HYBRID_NONBOND_MODE ==
                  cfg_get(wlan_vdev_get_psoc(link_osifp->os_if->vdev_obj),
                          CFG_OL_MLDEV_AP_MODE))) {
                 params->flags |= DP_ME_MCTBL_MLD_VDEV;
             }
#endif
             wlan_update_hifitbl(link_osifp->os_if->vdev_obj,
                                 params->data, params->data_len,
                                 params->flags);
       }
   }

   return 0;
}

#ifdef WLAN_FEATURE_11BE_MLO
static bool inline
wlan_cfg80211_process_mld_vap_req(wlan_if_t vap)
{
    int mld_ap_mode =
            cfg_get(wlan_vdev_get_psoc(vap->vdev_obj), CFG_OL_MLDEV_AP_MODE);
    bool is_mlo_hybrid_nonbond = (vap->iv_opmode == IEEE80211_M_HOSTAP) &&
                                 (mld_ap_mode == MLD_AP_HYBRID_NONBOND_MODE);

    if (wlan_vdev_mlme_is_mlo_vdev(vap->vdev_obj) && !is_mlo_hybrid_nonbond) {
        return false;
    }
    return true;
}
#else
static bool inline
wlan_cfg80211_process_mld_vap_req(wlan_if_t vap)
{
        return true;
}
#endif

#ifndef ENABLE_CFG80211_BACKPORTS_MLO
static int
wlan_cfg80211_update_mctbl(struct wiphy *wiphy,
                           struct wireless_dev *wdev,
                           struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic;
    wlan_if_t vap;
    int cmd_type;
    void *cmd;

    if (!is_mld_phy(wiphy)) {
        ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

        if (!ic) {
            qdf_err("ic NULL");
            return -EINVAL;
        }
        cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

        if (!cmd) {
            qdf_err("%s: cmd is NULL\n", __func__);
            return -EINVAL;
        }

        if (cmd_type == VAP_CMD) {
            vap = (wlan_if_t)cmd;
        } else {
            qdf_err("Invalid interface");
            return -EINVAL;
        }
        /* If any vap request is recevied on mld device : reject the request */
        if (!wlan_cfg80211_process_mld_vap_req(vap)) {
                qdf_debug("MLD interface received a cmd on vap - Ignored");
                return -EINVAL;
        }
        wlan_update_hifitbl(vap->vdev_obj, params->data, params->data_len, params->flags);
    } else {
        /*
           struct wireless_dev *wdev - is MLD Netdev
           Extract link osifp for a given MLD
           For each osifp->vap->vdev_obj call
           wlan_update_hifitbl
         */

       if (wlan_cfg80211_update_mctbl_mldev(wdev, params) != 0)
            return -EINVAL;

        qdf_info("Command is on MLD Interface");
    }

    return 0;
}
#else
static int
wlan_cfg80211_update_mctbl(struct wiphy *wiphy,
                           struct wireless_dev *wdev,
                           struct wlan_cfg8011_genric_params *params)
{
    osif_dev *osifp = NULL;
    wlan_if_t vap;

    osifp = ath_netdev_priv(wdev->netdev);

    if (!osifp)
        return -EINVAL;

    if (osifp->dev_type == OSIF_NETDEV_TYPE_VAP) {
        vap = osifp->os_if;
        if (!vap)
            return -EINVAL;

        wlan_update_hifitbl(vap->vdev_obj, params->data, params->data_len, params->flags);
    } else if (osifp->dev_type == OSIF_NETDEV_TYPE_MLO) {

        /*
         * struct wireless_dev *wdev - is MLD Netdev
         * Extract link osifp for a given MLD
         * For each osifp->vap->vdev_obj call
         * wlan_update_hifitbl
         */

       if (wlan_cfg80211_update_mctbl_mldev(wdev, params) != 0)
            return -EINVAL;

       qdf_debug("Command is on MLD Interface");
   } else {
       qdf_info("Failed to update mctbl recevied invalid dev type");
       return -EINVAL;
   }

   return 0;
}
#endif

static wlan_if_t
wlan_cfg80211_get_mld_vap(struct wireless_dev *wdev)
{
    struct osif_mldev *mldev;
    osif_dev *link_osifp = NULL;
    int i,j;

    mldev = osif_mld_get_mldev(wdev->netdev);
    if (!mldev)
        return NULL;

    for (i = 0; i < MAX_MLO_CHIPS; i++) {
         for(j = 0; j < MAX_PDEV_PER_SOC; j++) {
             link_osifp = mldev->link_dev[i][j];
             if(!link_osifp)
                continue;
             return link_osifp->os_if;
       }
   }

   return NULL;
}

int osif_get_mldev_params(struct wiphy *wiphy, struct osif_mldev *mld_osdev);

static int
wlan_cfg80211_get_mldev_params(struct wiphy *wiphy,
                               struct wireless_dev *wdev,
                               struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic;
    int cmd_type;
    void *cmd;
    struct net_device *dev;
    osif_dev *osdev;
    struct cfg80211_mld_wiphy_context *mld_ctx;
    struct wiphy *mld_wiphy;
    struct cfg80211_mld_wiphy_priv *mld_wiphy_priv;
    struct osif_mldev *mldev;
    int i, j, ret;
    uint32_t val;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    if (cmd_type != VAP_CMD) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    }

    dev = wdev->netdev;
    osdev = get_vap_device_context(wiphy, dev, params->link_id);

    val = params->value;

    if (val != 0 && val != 1) {
        qdf_err("Invalid value %u", val);
        return -EINVAL;
    }

    if (!val) {
        if ((mldev = osdev->mldev)) {
            ret = osif_get_mldev_params(wiphy, mldev);
            if (ret)
                qdf_err("Failed to get mldev(%s) params",
                        mldev->mld_dev->name);
    }

        return 0;
    }

    for (i = 0; i < WLAN_MAX_MLO_GROUPS; i++) {
        mld_ctx = &mld_wiphy_ctx[i];
        if (!mld_ctx || !mld_ctx->mld_wiphy)
            continue;
        mld_wiphy = mld_ctx->mld_wiphy;
        mld_wiphy_priv = wiphy_priv(mld_wiphy);
        for (j = 0; j < MAX_OSIF_MLDEV; j++) {
             mldev = mld_wiphy_priv->mldev[j];
             if (mldev) {
                 ret = osif_get_mldev_params(wiphy, mldev);
                 if (ret)
                     qdf_err("Failed to get mldev(%s) params",
                             mldev->mld_dev->name);
             }
        }
    }

    return 0;
}
#else
static int
wlan_cfg80211_update_mctbl(struct wiphy *wiphy,
                           struct wireless_dev *wdev,
                           struct wlan_cfg8011_genric_params *params)
{
    return 0;
}
#endif

#ifdef WLAN_FEATURE_11BE
static int wlan_cfg80211_config_t2lm(struct wiphy *wiphy,
                                     struct wireless_dev *wdev,
                                     struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;

    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!is_mld_phy(wiphy)) {
            vap = (wlan_if_t)cmd;
    } else {
        qdf_info("Command is on Single Wiphy");
        /*
         * For a given MLD get link VAP;
         * From link VAP extract ic
         */
        vap = wlan_cfg80211_get_mld_vap(wdev);

        if (vap) {
            qdf_debug("VAP is not NULL");
            cmd_type = VAP_CMD;
            ic = vap->iv_ic;
        }
    }

    if(cmd_type == RADIO_CMD) {
        qdf_err("Invalid Radio command !");
        return -EINVAL;
    }

    if (!vap) {
        qdf_err("Vap is NULL !");
        return -EINVAL;
    }

    return ieee80211_ucfg_tid_to_link_mapping(ic, vap, config);
}

static int wlan_cfg80211_t2lm_link_map_config(struct wiphy *wiphy,
                                              struct wireless_dev *wdev,
                                              struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        vap = (wlan_if_t)cmd;
    }

    return ieee80211_ucfg_link_map_config(ic, vap, config);
}

static int wlan_cfg80211_config_epcs(struct wiphy *wiphy,
                                     struct wireless_dev *wdev,
                                     struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;

    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;
    if (!is_mld_phy(wiphy)) {
/** To check linkid **/
            ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

            if (!ic) {
                qdf_err("ic NULL");
                return -EINVAL;
            }
            cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

            if (!cmd) {
                qdf_err("%s: cmd is NULL\n", __func__);
                return -EINVAL;
            }
            vap = (wlan_if_t)cmd;
    } else {
        qdf_info("Command is on Single Wiphy");
        /*
         * For a given MLD get link VAP;
         * From link VAP extract ic
         */
        vap = wlan_cfg80211_get_mld_vap(wdev);

        if (vap) {
            qdf_debug("VAP is not NULL");
            cmd_type = VAP_CMD;
            ic = vap->iv_ic;
        } else {
            return -EINVAL;
        }
    }

    if(cmd_type == RADIO_CMD) {
        qdf_err("Invalid Radio command !");
        return -EINVAL;
    }

    if (!vap) {
        qdf_err("Vap is NULL !");
        return -EINVAL;
    }

    return ieee80211_ucfg_epcs(ic, vap, config);
}
#endif /* WLAN_FEATURE_11BE */

static int wlan_cfg80211_tdma_schedule(struct wiphy *wiphy,
                                       struct wireless_dev *wdev,
                                       struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("IC is NULL !");
        return -EINVAL;
    }

    ieee80211_parse_tdma_config(ic, &config->data.tdma_schedule_config);
    return 0;
}

#ifdef WLAN_FEATURE_11BE_MLO
bool wlan_cfg80211_is_valid_link_id_map(struct ieee80211vap *vap, uint16_t link_id_mask)
{
     uint8_t i = 0;
     uint16_t valid_link_mask = 0;
     struct wlan_objmgr_vdev *wlan_vdev_list[WLAN_UMAC_MLO_MAX_VDEVS] = {NULL};
     struct wlan_objmgr_pdev *pdev = NULL;
     struct wlan_objmgr_vdev *vdev = NULL;
     uint16_t vdev_count = 0;
     bool valid_link_id = false;

     mlo_get_ml_vdev_list(vap->vdev_obj, &vdev_count, wlan_vdev_list);
     if (!vdev_count) {
         qdf_err("Number of VDEVs under MLD is reported as 0");
         return false;
     }

     for (i = 0; i < vdev_count; i++) {
          vdev = wlan_vdev_list[i];
          if (!vdev) {
              qdf_err("vdev is null");
              continue;
          }

          pdev = wlan_vdev_get_pdev(vdev);
          if (!pdev) {
              qdf_err("pdev is null");
              continue;
          }

          valid_link_mask |= BIT(vdev->vdev_mlme.mlo_link_id);
     }

     if (vdev_count) {
         if (ieee80211_mlo_release_vdev_list_refs(wlan_vdev_list,
                     QDF_ARRAY_SIZE(wlan_vdev_list),
                     vdev_count, 0) != QDF_STATUS_SUCCESS) {
             qdf_err("failed to release mlo vdev ref");
             return valid_link_id;
         }
     }

     if((link_id_mask & valid_link_mask) == link_id_mask) {
         valid_link_id = true;
     }

     return valid_link_id;
}

static int wlan_cfg80211_set_link_recommendation(struct wiphy *wiphy,
                                       struct wireless_dev *wdev,
                                       struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap;
    uint32_t assoc_id;
    uint16_t link_bitmap_id = 0;
    osif_dev *osifp = NULL;

    if (!params || !params->data) {
        qdf_err("Params is NULL !");
        return -EINVAL;
    }

    osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    if (!osifp) {
        qdf_err("osifp NULL");
        return -EINVAL;
    }

    vap = osifp->os_if;
    if(!vap) {
       qdf_err("vap is NULL !");
       return -EINVAL;
    }

    ic = vap->iv_ic;
    assoc_id = params->value;
    if (!ieee80211_validate_aid(ic, assoc_id)) {
        qdf_err("Invalid sta assoc id !");
        return -EINVAL;
    }

    link_bitmap_id = (((uint16_t *)params->data)[0]);
    if (!wlan_cfg80211_is_valid_link_id_map(vap, link_bitmap_id)) {
        qdf_err("Invalid link map id provided by user !");
        return -EINVAL;
    }

    if (ic->ic_send_link_recommendation != NULL) {
        ic->ic_send_link_recommendation(vap, assoc_id, link_bitmap_id);
    } else {
        return -EINVAL;
    }

    return 0;
}
#endif

#if UMAC_SUPPORT_ACS
QDF_STATUS ieee80211_acs_get_6g_channel_list_by_mode(struct ieee80211vap *vap,
        enum ieee80211_phymode des_mode, enum supported_6g_pwr_types chanlist_type,
        struct acs_chanlist *r_chanlist, uint32_t *r_cnt);
#else
static inline
QDF_STATUS ieee80211_acs_get_6g_channel_list_by_mode(struct ieee80211vap *vap,
        enum ieee80211_phymode des_mode, enum supported_6g_pwr_types chanlist_type,
        struct acs_chanlist *r_chanlist, uint32_t *r_cnt)
{
    return QDF_STATUS_E_FAILURE;
}
#endif

static int wlan_cfg80211_get_6g_chan_list(struct wiphy *wiphy,
                               struct wireless_dev *wdev,
                               struct wlan_cfg8011_genric_params *params)
{
    osif_dev *osifp = NULL;
    wlan_if_t vap;
    struct wlan_chan_list_6g *list;
    struct acs_chanlist *r_chanlist;
    enum ieee80211_phymode phymode;
    enum supported_6g_pwr_types acs_pwr_type;
    uint32_t chan_cnt = 0;
    uint32_t type, bw, ix;
#ifdef WLAN_FEATURE_11BE
    enum phy_ch_width ch_width = CH_WIDTH_INVALID;
    enum reg_phymode r_phymode = REG_PHYMODE_INVALID;
    bool is_11be_supported = false;
    QDF_STATUS status;
#endif

    osifp = get_vap_device_context(wiphy, wdev->netdev, params->link_id);
    if (!osifp) {
        qdf_err("osifp NULL");
        return -1;
    }

    vap = osifp->os_if;
    if (vap == NULL) {
        qdf_warn("%s: VAP is null ", __func__);
        return -1;
    }

    /* Allocate random channel list */
    r_chanlist = qdf_mem_malloc(NUM_6GHZ_CHANS * sizeof(*r_chanlist));
    if (!r_chanlist) {
        qdf_err("Could not allocate memory for 6g r_chanlist");
        return -ENOMEM;
    }

    list = qdf_mem_malloc(AFC_POWER_TYPE_MAX * sizeof(*list));
    if (!list) {
        qdf_err("Could not allocate memory for 6g chanlist");
        qdf_mem_free(r_chanlist);
        return -ENOMEM;
    }

#ifdef WLAN_FEATURE_11BE
    status = wlan_reg_get_max_phymode_and_chwidth(vap->iv_ic->ic_pdev_obj,
            &r_phymode,
            &ch_width);

    if ((status == QDF_STATUS_SUCCESS) && (r_phymode >= REG_PHYMODE_11BE)) {
        is_11be_supported = true;
    }
#endif

    /* Iterate over power type and fill channels available per BW */
    for (type = AFC_POWER_TYPE_LP; type < AFC_POWER_TYPE_MAX; type++) {
        switch (type) {
            case AFC_POWER_TYPE_LP:
                qdf_info("Finding LP channels");
                acs_pwr_type = REG_AP_LPI;
                break;
#ifdef CONFIG_AFC_SUPPORT
            case AFC_POWER_TYPE_SP:
                qdf_info("Finding SP channels");
                acs_pwr_type = REG_AP_SP;
                break;
            case AFC_POWER_TYPE_VLP:
                qdf_info("Finding VLP channels");
                acs_pwr_type = REG_AP_VLP;
                break;
#endif
            default:
                continue;
        }
        for (bw = IEEE80211_CWM_WIDTH20; bw < IEEE80211_CWM_WIDTH_MAX; bw++) {
            switch (bw) {
                case IEEE80211_CWM_WIDTH20:
                    qdf_info("20MHz channels");
                    phymode = IEEE80211_MODE_11AXA_HE20;
                    break;
                case IEEE80211_CWM_WIDTH40:
                    qdf_info("40MHz channels");
                    phymode = IEEE80211_MODE_11AXA_HE40;
                    break;
                case IEEE80211_CWM_WIDTH80:
                    qdf_info("80MHz channels");
                    phymode =
#ifdef WLAN_FEATURE_11BE
                                is_11be_supported ? IEEE80211_MODE_11BEA_EHT80 :
#endif
                                IEEE80211_MODE_11AXA_HE80;
                    break;
                case IEEE80211_CWM_WIDTH160:
                    qdf_info("160MHz channels");
                    phymode =
#ifdef WLAN_FEATURE_11BE
                                is_11be_supported ? IEEE80211_MODE_11BEA_EHT160 :
#endif
                                IEEE80211_MODE_11AXA_HE160;
                    break;
                case IEEE80211_CWM_WIDTH80_80:
                    qdf_info("80_80MHz channels");
                    phymode = IEEE80211_MODE_11AXA_HE80_80;
                    break;
#ifdef WLAN_FEATURE_11BE
                case IEEE80211_CWM_WIDTH320:
                    qdf_info("320MHz channels");
                    phymode = IEEE80211_MODE_11BEA_EHT320;
                    break;
#endif
                default:
                    continue;
            }

            chan_cnt = 0;
            if (!ieee80211_acs_get_6g_channel_list_by_mode(vap, phymode, acs_pwr_type, r_chanlist, &chan_cnt)) {
                list[type].num_valid_chan[bw] = chan_cnt;
                for (ix = 0; ix < chan_cnt; ix++) {
                    list[type].chan[bw][ix].chan_idx = r_chanlist[ix].channel.ic_ieee;
                    if ((bw >= IEEE80211_CWM_WIDTH160))
                        list[type].chan[bw][ix].cfreq2 = r_chanlist[ix].channel.ic_vhtop_ch_num_seg2;
                    else
                        list[type].chan[bw][ix].cfreq2 = r_chanlist[ix].channel.ic_vhtop_ch_num_seg1;
                    list[type].chan[bw][ix].psd_pwr = r_chanlist[ix].psd_power;
                    list[type].chan[bw][ix].eirp_pwr = r_chanlist[ix].eirp_power;
#ifdef WLAN_FEATURE_11BE
                    list[type].chan[bw][ix].puncture_bitmap = r_chanlist[ix].channel.op_puncture_bitmap;
#else
                    list[type].chan[bw][ix].puncture_bitmap = 0;
#endif
                }
                qdf_info("Num channel entries in pwr type %d width %d is %d", type, bw, chan_cnt);
            }
        }
    }

    cfg80211_reply_command(wiphy, sizeof(*list) * AFC_POWER_TYPE_MAX, list, 0);

    qdf_mem_free(r_chanlist);
    qdf_mem_free(list);

    return 0;
}

#ifdef WLAN_MGMT_RX_REO_SUPPORT
static int
wlan_cfg80211_set_mgmt_rx_reo_simulation(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic;
    int ret = 0;
    int cmd_type;
    void *cmd;
    uint8_t value;
    struct ol_ath_softc_net80211 *scn;
    ol_ath_soc_softc_t *soc;
    uint8_t ml_grp_id;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("IC is null");
        return -EINVAL;
    }

    scn = OL_ATH_SOFTC_NET80211(ic);

    if (!scn) {
        qdf_err("SCN is null");
        return -EINVAL;
    }

    soc = scn->soc;
    if (!soc) {
        qdf_err("SOC is null");
        return -EINVAL;
    }

    if (!mlo_psoc_get_grp_id(soc->psoc_obj, &ml_grp_id)) {
         qdf_err("Invalid MLO Group id");
         return -EINVAL;
    }


    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command on Invalid interface");
        return -EINVAL;
    }

    value = (uint8_t)params->value;

    if (value > 1) {
        qdf_err("Invalid Input : Valid values-> (0:Disable, 1:Enable)");
        return -EINVAL;
    }

    if (value)
        ret = ucfg_wlan_mgmt_rx_reo_sim_start(ml_grp_id);
    else
        ret = ucfg_wlan_mgmt_rx_reo_sim_stop(ml_grp_id);

    return ret;
}

/**
 * wlan_cfg80211_get_mgmt_rx_reo_simulation : Dump the status of rx reo
 *                                            simulation feature
 *
 * @wiphy: pointer to wiphy object
 * @wdev: pointer to device
 * @params: command params
 *
 * Returns 0 in case of success, else failure.
 */
static int
wlan_cfg80211_get_mgmt_rx_reo_simulation(struct wiphy *wiphy,
                               struct wireless_dev *wdev,
                               struct wlan_cfg8011_genric_params *params)
{
#define SIMULATION_STATUS_STRING 30
    int simulation_status;
    char buffer[SIMULATION_STATUS_STRING];
    struct ol_ath_softc_net80211 *scn;
    ol_ath_soc_softc_t *soc;
    uint8_t ml_grp_id;
    struct ieee80211com *ic = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    scn = OL_ATH_SOFTC_NET80211(ic);

    if (!scn) {
        qdf_err("SCN is null");
        return -EINVAL;
    }

    soc = scn->soc;
    if (!soc) {
        qdf_err("SOC is null");
        return -EINVAL;
    }

    if (!mlo_psoc_get_grp_id(soc->psoc_obj, &ml_grp_id)) {
         qdf_err("Invalid MLO Group id");
         return -EINVAL;
    }


    simulation_status = ucfg_wlan_mgmt_rx_reo_is_simulation_in_progress(ml_grp_id);
    if (simulation_status)
        snprintf(buffer, sizeof(buffer),"Simulation is running");
    else
        snprintf(buffer, sizeof(buffer),"Simulation is not running");

    cfg80211_reply_command(wiphy, sizeof(buffer), buffer, 0);
    return 0;
}

static int
wlan_cfg80211_mgmt_rx_reo_ingress_frame_stats(struct wiphy *wiphy,
                                struct wireless_dev *wdev,
                                struct wlan_cfg8011_genric_params *params)
{
    QDF_STATUS status;
    int ret = 0;
    struct ol_ath_softc_net80211 *scn;
    ol_ath_soc_softc_t *soc;
    uint8_t ml_grp_id;
    struct ieee80211com *ic = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    scn = OL_ATH_SOFTC_NET80211(ic);

    if (!scn) {
        qdf_err("SCN is null");
        return -EINVAL;
    }

    soc = scn->soc;
    if (!soc) {
        qdf_err("SOC is null");
        return -EINVAL;
    }

    if (!mlo_psoc_get_grp_id(soc->psoc_obj, &ml_grp_id)) {
         qdf_err("Invalid MLO Group id");
         return -EINVAL;
    }


    status = wlan_mgmt_rx_reo_print_ingress_frame_stats(ml_grp_id);
    if (QDF_IS_STATUS_ERROR(status)) {
        qdf_err("Failed to print ingress frame stats");
        return -EINVAL;
    }

    return cfg80211_reply_command(wiphy, sizeof(uint32_t), &ret, 0);
}

static int
wlan_cfg80211_mgmt_rx_reo_ingress_frame_info(struct wiphy *wiphy,
                                struct wireless_dev *wdev,
                                struct wlan_cfg8011_genric_params *params)
{
    QDF_STATUS status;
    uint16_t num_frames;
    int ret = 0;
    struct ol_ath_softc_net80211 *scn;
    ol_ath_soc_softc_t *soc;
    uint8_t ml_grp_id;
    struct ieee80211com *ic = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    scn = OL_ATH_SOFTC_NET80211(ic);

    if (!scn) {
        qdf_err("SCN is null");
        return -EINVAL;
    }

    soc = scn->soc;
    if (!soc) {
        qdf_err("SOC is null");
        return -EINVAL;
    }

    if (!mlo_psoc_get_grp_id(soc->psoc_obj, &ml_grp_id)) {
         qdf_err("Invalid MLO Group id");
         return -EINVAL;
    }

    num_frames = params->value;
    status = wlan_mgmt_rx_reo_print_ingress_frame_info(ml_grp_id, num_frames);
    if (QDF_IS_STATUS_ERROR(status)) {
        qdf_err("Failed to print ingress frame info");
        return -EINVAL;
    }

    return cfg80211_reply_command(wiphy, sizeof(uint32_t), &ret, 0);
}

static int
wlan_cfg80211_mgmt_rx_reo_egress_frame_stats(struct wiphy *wiphy,
                                struct wireless_dev *wdev,
                                struct wlan_cfg8011_genric_params *params)
{
    QDF_STATUS status;
    int ret = 0;
    struct ol_ath_softc_net80211 *scn;
    ol_ath_soc_softc_t *soc;
    uint8_t ml_grp_id;
    struct ieee80211com *ic =NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    scn = OL_ATH_SOFTC_NET80211(ic);

    if (!scn) {
        qdf_err("SCN is null");
        return -EINVAL;
    }

    soc = scn->soc;
    if (!soc) {
        qdf_err("SOC is null");
        return -EINVAL;
    }

    if (!mlo_psoc_get_grp_id(soc->psoc_obj, &ml_grp_id)) {
         qdf_err("Invalid MLO Group id");
         return -EINVAL;
    }


    status = wlan_mgmt_rx_reo_print_egress_frame_stats(ml_grp_id);
    if (QDF_IS_STATUS_ERROR(status)) {
        qdf_err("Failed to print egress frame stats");
        return -EINVAL;
    }

    return cfg80211_reply_command(wiphy, sizeof(uint32_t), &ret, 0);
}

static int
wlan_cfg80211_mgmt_rx_reo_egress_frame_info(struct wiphy *wiphy,
                                struct wireless_dev *wdev,
                                struct wlan_cfg8011_genric_params *params)
{
    QDF_STATUS status;
    uint16_t num_frames;
    int ret = 0;
    struct ol_ath_softc_net80211 *scn;
    ol_ath_soc_softc_t *soc;
    uint8_t ml_grp_id;
    struct ieee80211com *ic = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    scn = OL_ATH_SOFTC_NET80211(ic);

    if (!scn) {
        qdf_err("SCN is null");
        return -EINVAL;
    }

    soc = scn->soc;
    if (!soc) {
        qdf_err("SOC is null");
        return -EINVAL;
    }

    if (!mlo_psoc_get_grp_id(soc->psoc_obj, &ml_grp_id)) {
         qdf_err("Invalid MLO Group id");
         return -EINVAL;
    }


    num_frames = params->value;
    status = wlan_mgmt_rx_reo_print_egress_frame_info(ml_grp_id, num_frames);
    if (QDF_IS_STATUS_ERROR(status)) {
        qdf_err("Failed to print egress frame info");
        return -EINVAL;
    }

    return cfg80211_reply_command(wiphy, sizeof(uint32_t), &ret, 0);
}
#endif /* WLAN_MGMT_RX_REO_SUPPORT */

#ifdef WLAN_MLO_GLOBAL_SHMEM_SUPPORT
static int
wlan_cfg80211_dump_mlo_global_h_shmem_arena(struct wiphy *wiphy,
                                struct wireless_dev *wdev,
                                struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int ret = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (ic->ic_wdev.netdev == wdev->netdev) {
        struct net_device *dev = NULL;
        struct ol_ath_softc_net80211 *scn = NULL;

        dev = wdev->netdev;
        scn = get_radio_device_context(wiphy, dev);

        if (ic->ic_cfg80211_radio_handler.dump_mlo_glb_h_shmem_arena) {
            uint16_t num_bytes;
            QDF_STATUS status;

            num_bytes = params->value;
            status = ic->ic_cfg80211_radio_handler.dump_mlo_glb_h_shmem_arena((void*)scn, num_bytes);
            if (QDF_IS_STATUS_ERROR(status)) {
                    qdf_err("Failed to print %u bytes of global h shmem arena", num_bytes);
                    return qdf_status_to_os_return(status);
            }

            ret = cfg80211_reply_command(wiphy, sizeof(uint32_t), &ret, 0);
        }
    } else {
        ret = -EOPNOTSUPP;
    }

    return ret;
}
#endif /* WLAN_MLO_GLOBAL_SHMEM_SUPPORT */

static int wlan_cfg80211_get_probe_wh(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    uint8_t mac[QDF_MAC_ADDR_SIZE];
    int cmd_type;
    int value;

    void *cmd;
    u_int32_t *data = (u_int32_t *) params->data;

    if(data == NULL) {
        qdf_err("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err(" Command on invalid interface");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if(params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_err("Invalid MAC Address!\n");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    value = ieee80211_acl_flag_check(vap, mac, IEEE80211_ACL_FLAG_PROBE_RESP_WH);
    IEEE80211_DPRINTF(vap, IEEE80211_MSG_CFG80211, "%s: probe wh: %d\n",
                      __func__, value);
    return cfg80211_reply_command(wiphy, sizeof(u_int32_t), &value, 0);
}

#ifdef DP_UMAC_HW_RESET_SUPPORT
/**
 * wlan_cfg80211_get_umac_reset_debug() - cfg80211 command to get umac reset
 *                                        debug commands
 * @wiphy: Pointer to wiphy structure
 * @wdev: Pointer to wdev structure
 * @params: Pointer to input params
 *
 * Return: Success or failure
 */
static int wlan_cfg80211_get_umac_reset_debug(
        struct wiphy *wiphy, struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err("Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if (ic->ic_cfg80211_radio_handler.get_umac_reset_debug)
        ret = ic->ic_cfg80211_radio_handler.get_umac_reset_debug(scn,
                                                                 params->value);
    else
        ret = -EOPNOTSUPP;

    return ret;
}
#endif

static int wlan_cfg80211_get_wificonfiguration(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    struct ieee80211com *ic = NULL;
    struct wlan_cfg8011_genric_params generic_params;
    osif_dev *osifp = NULL;
    int ret = 0;
    struct net_device *dev = NULL;
#if QCA_SUPPORT_SON
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    struct wlan_objmgr_vdev *vdev =NULL;
#endif
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_lmac_if_rx_ops *rx_ops = NULL;
#endif
    bool is_mld_command = false;

    if (wiphy == NULL) {
        qdf_err("NULL wiphy argument.");
        return -EINVAL;
    }

    if (wdev == NULL) {
        qdf_err("NULL wdev argument.");
        return -EINVAL;
    }

    dev = wdev->netdev;
    osifp = ath_netdev_priv(dev);

#ifdef QCA_SUPPORT_WDS_EXTENDED
    if (osifp->dev_type == OSIF_NETDEV_TYPE_WDS_EXT) {
       qdf_err("Command is not allowed on wds ext vap");
       return -EINVAL;
   }
#endif

    qdf_mem_zero(&generic_params, sizeof(generic_params));
    extract_generic_command_params(wiphy, data, data_len, &generic_params);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if (!is_mld_phy_radio_command(wiphy, dev) && is_mld_netdev(dev) &&
                 !is_valid_link_id(generic_params.link_id)) {
        /* If LinkID is 0xff, command is MLD command
         *  apply those paramters on all link_vifs or act accordingly
         */
        if (is_allowed_mld_command(generic_params.command)) {
            is_mld_command = true;
        } else {
            qdf_err("VAP command but link ID is invalid");
            return -EINVAL;
        }
    }
#endif

    /* If we get command on MLD interface with out link_id. IC is invalid */
    if (!is_mld_command) {
        ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, generic_params.link_id);

        if (!ic) {
            qdf_err("ic NULL");
            return -EINVAL;
        }

        if (!is_mld_phy(wiphy) && ic->recovery_in_progress) {
            return -1;
        }
    }

#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    if (is_mld_phy(wiphy)) {
        if(is_valid_sigle_phy_command(generic_params.command))
            qdf_err("Command is on Single Wiphy");
        else
            return -EINVAL;
    }
#endif

    /* call extract_generic_command_params */
    switch(generic_params.command) {
        case QCA_NL80211_VENDOR_SUBCMD_WIFI_PARAMS:
            wlan_cfg80211_get_params(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_WIRELESS_MODE:
            wlan_cfg80211_get_wirelessmode(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_WMM_PARAMS:
            wlan_cfg80211_get_wmm_params(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_BSSID:
            wlan_cfg80211_get_bssid(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_COUNTRY_CONFIG:
            wlan_cfg80211_get_country(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_NOISE_FLOOR:
            wlan_cfg80211_get_noise_floor(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_MGMT_RSSI_THR:
            wlan_cfg80211_get_mgmt_rssi_thr(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_HE_MESH_CONFIG:
            wlan_cfg80211_get_he_mesh_config(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_HE_BSS_COLOR:
            wlan_cfg80211_get_he_bss_color(wiphy, wdev, &generic_params);
            break;
#if OBSS_PD
        case QCA_NL80211_VENDOR_SUBCMD_HE_SR_CONFIG:
            wlan_cfg80211_get_he_sr_config(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_HE_SRG_BITMAP:
            wlan_cfg80211_get_he_srg_bitmap(wiphy, wdev, &generic_params);
            break;
#endif /* OBSS PD */
        case QCA_NL80211_VENDOR_SUBCMD_NAV_OVERRIDE_CONFIG:
            wlan_cfg80211_get_nav_config(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MU_EDCA_PARAMS:
            wlan_cfg80211_get_muedca_params(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_GET_SSID:
            wlan_cfg80211_get_ssid(wiphy, wdev, &generic_params);
            break;
#if UNIFIED_SMARTANTENNA
        case QCA_NL80211_VENDOR_SUBCMD_SA_PARAMS:
            ret = wlan_cfg80211_get_sa_params(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDORSUBCMD_DEFAULT_PCP_TID_MAP:
            wlan_cfg80211_get_def_pcp_tid_map(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_DEFAULT_TIDMAP_PRTY:
           wlan_cfg80211_get_def_tidmap_prty(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_PRI20_BLOCKCHANLIST:
            wlan_cfg80211_get_pri20_blockchanlist(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_CHAN_RF_CHARACTERIZATION_INFO:
            wlan_cfg80211_get_chan_rf_characterization_info(wiphy, wdev,
                    &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MUEDCA_MODE:
            wlan_cfg80211_get_muedca_mode(wiphy,wdev,&generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_NON_HT_DUP_EN:
            wlan_cfg80211_get_non_ht_dup_en(wiphy, wdev, &generic_params);
            break;
#if OBSS_PD
        case QCA_NL80211_VENDOR_SUBCMD_SR_SELF_CONFIG:
            ret = wlan_cfg80211_get_sr_self_config(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_GET_TARGET_PDEVID:
            ret = wlan_cfg80211_get_target_pdevid(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_ACS_PRECAC_SUPPORT:
            ret = wlan_cfg80211_get_acs_precac_status(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_RNR_6GHZ:
            ret = wlan_cfg80211_get_6ghz_rnr(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_WIDEBAND_SUPPORT:
	    ret = wlan_cfg80211_get_wideband_support(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_VDEV_TSF:
            ret = wlan_cfg80211_get_vdev_tsf(wiphy, wdev, &generic_params);
            break;
#if DBG_LVL_MAC_FILTERING
        case QCA_NL80211_VENDOR_SUBCMD_DBGLVLMAC:
            ret = wlan_cfg80211_get_dbglvlmac(wiphy, wdev, &generic_params);
            break;
#endif /* DBG_LVL_MAC_FILTERING */
#if QCA_SUPPORT_SON
        case QCA_NL80211_VENDOR_SUBCMD_MESH_CONFIGURATION:
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
            if (ic == NULL) {
                return -EINVAL;
            }

            psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
#else /* ENABLE_CFG80211_BACKPORTS_MLO */
            if (dev == NULL) {
                return -EINVAL;
            }
            vdev = wlan_get_vdev_from_netdev(dev);
            if (vdev == NULL) {
                return -EINVAL;
            }

            psoc= wlan_vdev_get_psoc(vdev);
#endif /* ENABLE_CFG80211_BACKPORTS_MLO */
            if (psoc) {
                rx_ops = wlan_psoc_get_lmac_if_rxops(psoc);
            }

            if (rx_ops && rx_ops->son_rx_ops.config_get) {
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
                ret = rx_ops->son_rx_ops.config_get(&generic_params, wiphy, wdev);
#else /* ENABLE_CFG80211_BACKPORTS_MLO */
                ret = rx_ops->son_rx_ops.config_get(vdev, &generic_params);
#endif /* ENABLE_CFG80211_BACKPORTS_MLO */
            }
            break;
#endif
#if !(defined REMOVE_PKT_LOG) && (defined PKTLOG_DUMP_UPLOAD_SSR)
        case QCA_NL80211_VENDOR_SUBCMD_PKTLOG_SSR:
            ret = wlan_cfg80211_get_pktlog_dump_ssr(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_EMA_CONFIG:
            ret = wlan_cfg80211_get_ema_config(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_OPMODE:
            ret = wlan_cfg80211_get_wirelessopmode(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_OPER_REG_INFO:
            ret = wlan_cfg80211_get_oper_reg_info(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_PARTIAL_BSSID_BITMAP:
            wlan_cfg80211_get_partial_bssid_bitmap(wiphy, wdev, &generic_params);
            break;
#ifdef WIFI_MONITOR_SUPPORT
#ifdef QCA_UNDECODED_METADATA_SUPPORT
        case QCA_NL80211_VENDOR_SUBCMD_GET_PHYRX_ERROR_MASK:
            monitor_cfg80211_get_phyrx_error_mask(wiphy, wdev, &generic_params);
            break;
#endif
#endif
        case QCA_NL80211_VENDOR_SUBCMD_GET_KEY:
            ret = wlan_cfg80211_athkey_get_key(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_6G_CHAN_LIST:
            ret = wlan_cfg80211_get_6g_chan_list(wiphy, wdev, &generic_params);
            break;
#ifdef WLAN_MGMT_RX_REO_SUPPORT
        case QCA_NL80211_VENDOR_SUBCMD_MGMT_RX_REO_SIMULATION:
            ret = wlan_cfg80211_get_mgmt_rx_reo_simulation(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MGMT_RX_REO_INGRESS_FRAME_STATS:
            ret = wlan_cfg80211_mgmt_rx_reo_ingress_frame_stats(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MGMT_RX_REO_INGRESS_PER_FRAME_INFO:
            ret = wlan_cfg80211_mgmt_rx_reo_ingress_frame_info(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MGMT_RX_REO_EGRESS_FRAME_STATS:
            ret = wlan_cfg80211_mgmt_rx_reo_egress_frame_stats(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MGMT_RX_REO_EGRESS_PER_FRAME_INFO:
            ret = wlan_cfg80211_mgmt_rx_reo_egress_frame_info(wiphy, wdev, &generic_params);
            break;
#endif /* WLAN_MGMT_RX_REO_SUPPORT */
#ifdef WLAN_MLO_GLOBAL_SHMEM_SUPPORT
        case QCA_NL80211_VENDOR_SUBCMD_DUMP_MLO_GLOBAL_H_SHMEM_ARENA:
            ret = wlan_cfg80211_dump_mlo_global_h_shmem_arena(wiphy, wdev, &generic_params);
            break;
#endif /* WLAN_MLO_GLOBAL_SHMEM_SUPPORT */
        case QCA_NL80211_VENDOR_SUBCMD_PROBE_WH_CONFIG:
            ret = wlan_cfg80211_get_probe_wh(wiphy, wdev, &generic_params);
            break;
#ifdef DP_UMAC_HW_RESET_SUPPORT
        case QCA_NL80211_VENDOR_SUBCMD_UMAC_RESET_DEBUG:
            return wlan_cfg80211_get_umac_reset_debug(wiphy, wdev,
                                                      &generic_params);
            break;
#endif
#ifdef QCA_BLOCK_EVENT_TO_USERSPACE
        case QCA_NL80211_VENDOR_SUBCMD_SET_EVENT_FILTER:
            ret = wlan_cfg80211_get_event_filter(wiphy, wdev, &generic_params);
            break;
#endif /* QCA_BLOCK_EVENT_TO_USERSPACE */
#ifdef WLAN_FEATURE_11BE_MLO
        case QCA_NL80211_VENDOR_SUBCMD_GET_LINK_ID_BPCC_VAL:
            ret = wlan_cfg80211_get_link_id_bpcc_val(wiphy, wdev, &generic_params);
            break;
#endif /* WLAN_FEATURE_11BE_MLO */
       default:
            qdf_print("%s: Unsuported Genric command: %d ", __func__, generic_params.command);
    }

    return ret;
}

/* wlan_cfg80211_list_bands - list supported bands
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_list_bands(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int ret = -EIO;
    struct wlan_supported_freq_bands supported_bands;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }
    supported_bands.band_2ghz = ic->ic_supported_freq_bands.band_2ghz;
    supported_bands.band_5ghz = ic->ic_supported_freq_bands.band_5ghz;
    supported_bands.band_6ghz = ic->ic_supported_freq_bands.band_6ghz;

    ret = cfg80211_reply_command(wiphy,
            sizeof(struct wlan_supported_freq_bands), &supported_bands, 0);

    return ret;
}

static int wlan_cfg80211_set_halphy_cal (struct wiphy *wiphy,
                                      struct wireless_dev *wdev,
                                      struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type, ret = 0;
    void *cmd;
    uint32_t value, *data = (uint32_t *)params->data, chan_sel;

    if(data == NULL) {
        qdf_err("Invalid Arguments ");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err(" Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    value = params->value;
    chan_sel = data[0];

    if (ic->ic_cfg80211_radio_handler.set_halphy_cal) {
        ret = ic->ic_cfg80211_radio_handler.set_halphy_cal((void *)scn,
                                                      value, chan_sel);
    }
    else {
        ret = -EOPNOTSUPP;
    }

    return ret;
}

/* wlan_cfg80211_mu_snif - set mu snif param
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_mu_snif(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    return ieee80211_ucfg_mu_snif(ic, vap, config);
}

#ifdef CONFIG_SAWF
static int
wlan_cfg80211_sawf_peer_msduq_map_report(struct wiphy *wiphy,
                                   struct wireless_dev *wdev,
                                   struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic;
    struct ol_ath_softc_net80211 *scn;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }
    if (cmd_type != RADIO_CMD) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_err("Invalid mac address");
        return -EINVAL;
    }

    return ic->ic_cfg80211_radio_handler.dp_sawf_peer_msduq_report((void*)scn,
                                                                   mac);
}
#endif

#if CONFIG_SAWF_DEF_QUEUES
static int
wlan_cfg80211_sawf_peer_svcid_map(struct wiphy *wiphy,
                                  struct wireless_dev *wdev,
                                  struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    uint8_t svc_id;

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }
    if (cmd_type != RADIO_CMD) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_err("Invalid mac address");
        return -EINVAL;
    }

    svc_id = params->value; /* attribute 18 holds svc_id value */
    qdf_info("%s svc_id:%u ", ether_sprintf(mac), svc_id);

    if (!wlan_service_id_valid(svc_id)) {
        qdf_err("Invalid service class ID %u", svc_id);
        return -EINVAL;
    }

    if (!wlan_service_id_configured(svc_id)) {
       qdf_err("Service class (id %u) doesn't exist", svc_id);
       return -EINVAL;
    }

    if (!ic->ic_cfg80211_radio_handler.dp_sawf_peer_svcid_map)
        return -EOPNOTSUPP;

    return ic->ic_cfg80211_radio_handler.dp_sawf_peer_svcid_map((void*)scn,
                                                                mac, svc_id);
}

static int
wlan_cfg80211_sawf_peer_svcid_unmap(struct wiphy *wiphy,
                                    struct wireless_dev *wdev,
                                    struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];
    uint8_t svc_id;

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }
    if (cmd_type != RADIO_CMD) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_err("Invalid mac address");
        return -EINVAL;
    }

    svc_id = params->value; /* attribute 18 holds svc_id value */
    qdf_info("%s svc_id:%u ", ether_sprintf(mac), svc_id);

    if (!wlan_service_id_valid(svc_id)) {
        qdf_err("Invalid service class ID %u", svc_id);
        return -EINVAL;
    }

    if (!wlan_service_id_configured(svc_id)) {
        qdf_err("Service class (id %u) doesn't exist", svc_id);
        return -EINVAL;
    }

    if (!ic->ic_cfg80211_radio_handler.dp_sawf_peer_svcid_unmap)
        return -EOPNOTSUPP;

    return ic->ic_cfg80211_radio_handler.dp_sawf_peer_svcid_unmap((void*)scn,
                                                                  mac, svc_id);
}

static int
wlan_cfg80211_sawf_peer_map_report(struct wiphy *wiphy,
                                   struct wireless_dev *wdev,
                                   struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    u_int8_t mac[QDF_MAC_ADDR_SIZE];

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }
    if (cmd_type != RADIO_CMD) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_err("Invalid mac address");
        return -EINVAL;
    }

    qdf_info("mac: %s", ether_sprintf(mac));

    if (!ic->ic_cfg80211_radio_handler.dp_sawf_peer_map_report)
        return -EOPNOTSUPP;

    return ic->ic_cfg80211_radio_handler.dp_sawf_peer_map_report((void*)scn,
                                                                 mac);
}

static uint8_t
get_max_mcs_supp(struct ieee80211com *ic)
{
    if (ic->ic_get_tgt_type(ic) == TARGET_TYPE_QCN9000 ||
        ic->ic_get_tgt_type(ic) == TARGET_TYPE_QCA5332 ||
        ic->ic_get_tgt_type(ic) == TARGET_TYPE_QCN9224 ||
        ic->ic_get_tgt_type(ic) == TARGET_TYPE_QCN6432) {
        return IEEE80211_HE_MCS_12_13_IDX_MAX;
    }
    return IEEE80211_HE_MCS_IDX_MAX;
}

#define RATE_UPPER_CAP_MIN_NSS		1
#define RATE_UPPER_CAP_MAX_NSS		8
#define RATE_UPPER_CAP_MIN_MCS		0
#define RATE_UPPER_CAP_MAX_MCS		15

static int
wlan_cfg80211_set_rate_upper_cap(struct wiphy *wiphy, struct wireless_dev *wdev,
                                 struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    uint32_t *data;
    uint32_t max_nss, max_mcs;
    uint8_t max_mcs_supp;

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    data = (u_int32_t *)params->data;

    if (!data) {
        qdf_err("Invalid Arguments");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;

    max_nss = params->value;
    max_mcs = data[0];

    qdf_info("max_nss:%u max_mcs:%u", max_nss, max_mcs);

    if (max_nss < RATE_UPPER_CAP_MIN_NSS || max_nss > RATE_UPPER_CAP_MAX_NSS) {
        qdf_err("Invalid max_nss. Valid range [%u %u]",
                RATE_UPPER_CAP_MIN_NSS, RATE_UPPER_CAP_MAX_NSS);
        return -EINVAL;
    }

    max_mcs_supp = get_max_mcs_supp(ic);
    if (max_mcs > max_mcs_supp) {
        qdf_err("Invalid max_mcs Valid range [%u %u]",
                RATE_UPPER_CAP_MIN_MCS, max_mcs_supp);
        return -EINVAL;
    }

    if (ic->ic_cfg80211_radio_handler.set_rate_upper_cap) {
        return ic->ic_cfg80211_radio_handler.set_rate_upper_cap((void *)scn,
                                                                max_nss,
                                                                max_mcs,
                                                                1, 1);
    }

    return 0;
}

#define RETRY_COLLISION_THRESHOLD_MIN	1
#define RETRY_COLLISION_THRESHOLD_MAX	255
#define NUM_MCS_DROP_MIN		1
#define NUM_MCS_DROP_MAX		15

static int
wlan_cfg80211_set_rate_retry_mcs_drop(struct wiphy *wiphy,
                                      struct wireless_dev *wdev,
                                      struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    uint32_t *data;
    uint32_t retry_thresh; /* retry collision threshold */
    uint32_t mcs_drop; /* number of mcs to be dropped */
    uint8_t max_mcs_supp;

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    data = (u_int32_t *)params->data;

    if (data == NULL) {
        qdf_err("Invalid Arguments");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;

    retry_thresh = params->value;
    mcs_drop = data[0];

    qdf_info("retry_thresh:%u mcs_drop:%u", retry_thresh, mcs_drop);
    if (retry_thresh < RETRY_COLLISION_THRESHOLD_MIN ||
            retry_thresh > RETRY_COLLISION_THRESHOLD_MAX) {
        qdf_err("Invalid retry_collision threshold. Valid range [%u %u]",
                RETRY_COLLISION_THRESHOLD_MIN, RETRY_COLLISION_THRESHOLD_MAX);
        return -EINVAL;
    }

    max_mcs_supp = get_max_mcs_supp(ic);
    if (mcs_drop < NUM_MCS_DROP_MIN || mcs_drop > max_mcs_supp) {
        qdf_err("Invalid number of MCS to be drop.  Valid range [%u %u]",
                NUM_MCS_DROP_MIN, max_mcs_supp);
        return -EINVAL;
    }

    if (ic->ic_cfg80211_radio_handler.set_rate_retry_mcs_drop) {
        return ic->ic_cfg80211_radio_handler.set_rate_retry_mcs_drop(
                (void*)scn, retry_thresh, mcs_drop,
                1, 1);
    }

    return 0;
}

#define MCS_PROBE_INTVL_MIN	1
#define MCS_PROBE_INTVL_MAX	65534

static int
wlan_cfg80211_set_mcs_probe_intvl(struct wiphy *wiphy,
                                  struct wireless_dev *wdev,
                                  struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    uint32_t *data;
    uint32_t min; /* min MCS probe interval */
    uint32_t max; /* max MCS probe interval */

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    data = (u_int32_t *)params->data;

    if (data == NULL) {
        qdf_err("Invalid Arguments");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;

    min = params->value;
    max = data[0];

    qdf_info("MCS probe interval [%u %u]", min, max);

    if (min < MCS_PROBE_INTVL_MIN || min > MCS_PROBE_INTVL_MAX) {
        qdf_err("Invalid min_MCS_probe_interval. Valid range [%u %u]",
                MCS_PROBE_INTVL_MIN, MCS_PROBE_INTVL_MAX);
        return -EINVAL;
    }

    if (max < MCS_PROBE_INTVL_MIN || max > MCS_PROBE_INTVL_MAX) {
        qdf_err("Invalid max_MCS_probe_interval. Valid range [%u %u]",
                MCS_PROBE_INTVL_MIN, MCS_PROBE_INTVL_MAX);
        return -EINVAL;
    }

    if (ic->ic_cfg80211_radio_handler.set_mcs_probe_intvl)
        return ic->ic_cfg80211_radio_handler.set_mcs_probe_intvl((void*)scn,
                                                                 min, max);
    return 0;
}

#define NSS_PROBE_INTVL_MIN	1
#define NSS_PROBE_INTVL_MAX	65534

static int
wlan_cfg80211_set_nss_probe_intvl(struct wiphy *wiphy,
                                  struct wireless_dev *wdev,
                                  struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    uint32_t *data;
    uint32_t min; /* min NSS probe interval */
    uint32_t max; /* max NSS probe interval */

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    data = (u_int32_t *)params->data;

    if (data == NULL) {
        qdf_err("Invalid Arguments");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Command on invalid interface");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;

    min = params->value;
    max = data[0];

    qdf_info("NSS probe interval [%u %u]", min, max);

    if (min < NSS_PROBE_INTVL_MIN || min > NSS_PROBE_INTVL_MAX) {
        qdf_err("Invalid min_NSS_probe_interval. Valid range [%u %u]",
                NSS_PROBE_INTVL_MIN, NSS_PROBE_INTVL_MAX);
        return -EINVAL;
    }

    if (max < NSS_PROBE_INTVL_MIN || max > NSS_PROBE_INTVL_MAX) {
        qdf_err("Invalid max_NSS_probe_interval. Valid range [%u %u]",
                NSS_PROBE_INTVL_MIN, NSS_PROBE_INTVL_MAX);
        return -EINVAL;
    }

    if (ic->ic_cfg80211_radio_handler.set_nss_probe_intvl)
        return ic->ic_cfg80211_radio_handler.set_nss_probe_intvl((void*)scn,
                                                                 min, max);

    return 0;
}
#endif

/*
 * wlan_cfg80211_config_probe_wh:
 * Enables/Disables probe response withhold for a particular mac
 */
static int wlan_cfg80211_config_probe_wh(struct wiphy *wiphy,
                struct wireless_dev *wdev,
                struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    uint8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Command on Invalid Interface\n");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if(params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_err("Invalid MAC Address!\n");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    if (params->value)
        return ieee80211_acl_set_flag(vap, mac, IEEE80211_ACL_FLAG_PROBE_RESP_WH);
    else
        return ieee80211_acl_clr_flag(vap, mac, IEEE80211_ACL_FLAG_PROBE_RESP_WH);
}

static const struct nla_policy
wlan_cfg80211_get_mu_params_policy[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_MAX + 1] = {
     [QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_VIF_ID] = {.type = NLA_U8 },
     [QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_HW_LINK_ID] = {.type = NLA_U8 },
     [QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_SCHED_MODE] = {.type = NLA_U8 },
     [QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_ACTIVE_DURATION] = {.type = NLA_U32 },
     [QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_INACTIVE_DURATION] = {.type = NLA_U32 },
     [QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_ACTIVE_TPUT] = {.type = NLA_U32 },
     [QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_INACTIVE_TPUT] = {.type = NLA_U32 },
};

#ifdef QCA_SUPPORT_EAPOL_OVER_CONTROL_PORT
static int wlan_cfg80211_set_vap_eapol_over_nl(struct wiphy *wiphy,
                                               struct wireless_dev *wdev,
                                               struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct wlan_objmgr_vdev *vdev = NULL;
    struct wlan_objmgr_psoc *psoc = NULL;
    cdp_config_param_type buf;
    int cmd_type;
    void *cmd;

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    vdev = wlan_get_vdev_from_netdev(wdev->netdev);
    if (!vdev)
        return -EINVAL;

    psoc = wlan_vdev_get_psoc(vdev);
    if (psoc) {
        buf.cdp_eapol_over_control_port_disable = params->value;
        if (cdp_txrx_set_vdev_param(wlan_psoc_get_dp_handle(psoc),
                                    wlan_vdev_get_id(vdev), CDP_EAPOL_OVER_CONTROL_PORT_DISABLE,
                                    buf) != QDF_STATUS_SUCCESS)
            return EINVAL;
    } else
        return -EINVAL;

    return 0;
}
static int wlan_cfg80211_set_eapol_over_nl(struct wiphy *wiphy,
                                           struct wireless_dev *wdev,
                                           struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;
    cdp_soc_set_param(wlan_psoc_get_dp_handle(scn->soc->psoc_obj),
                      DP_SOC_PARAM_EAPOL_OVER_CONTROL_PORT, params->value);

    return 0;
}
#endif

static int wlan_cfg80211_enable_disable_sched_modes(struct wiphy *wiphy,
                                                    struct wireless_dev *wdev,
                                                    const void *data,
                                                    int data_len)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_MAX + 1] = {0};
    struct wlan_mu_context mu_ctx = {0};
    int cmd_type;
    void *cmd;
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, 0);

    if (!cmd) {
        qdf_err("cmd is NULL");
        return -EINVAL;
    }

    if (cmd_type == RADIO_CMD) {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    } else {
        return -EINVAL;
    }

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_MAX,
                                data, data_len, wlan_cfg80211_get_mu_params_policy))
    {
        qdf_err("Failed Parsing request!");
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_VIF_ID])
        mu_ctx.vdev_id = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_VIF_ID]);

    if (attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_HW_LINK_ID])
        mu_ctx.hw_link_id = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_HW_LINK_ID]);

    if (attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_SCHED_MODE])
        mu_ctx.sched_mode_to_probe = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_SCHED_MODE]);

    if (attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_ACTIVE_DURATION])
        mu_ctx.mu_on_duration = nla_get_u32(attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_ACTIVE_DURATION]);

    if (attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_INACTIVE_DURATION])
        mu_ctx.mu_off_duration = nla_get_u32(attr[QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_INACTIVE_DURATION]);

    qdf_debug("Vdev id: %d, HW link id: %d, Sched mode: %d, MU ON: %d, MU OFF: %d ",
              mu_ctx.vdev_id, mu_ctx.hw_link_id, mu_ctx.sched_mode_to_probe,
              mu_ctx.mu_on_duration, mu_ctx.mu_off_duration);

    ic->ic_send_mu_param(scn, &mu_ctx);
    return 0;
}

static int wlan_cfg80211_disable_sched_modes(struct wiphy *wiphy,
					     struct wireless_dev *wdev,
					     struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    uint32_t disabled_modes;
    wlan_if_t vap = NULL;

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;
    disabled_modes = params->value;

    if (cmd_type == RADIO_CMD) {
        if (ic->ic_cfg80211_radio_handler.set_disable_mode)
            return ic->ic_cfg80211_radio_handler.set_disable_mode((void *)scn,
                                                                  disabled_modes);
    }

    if (cmd_type == VAP_CMD) {
        vap = (wlan_if_t)cmd;
        ic  = vap->iv_ic;
        return ieee80211_disabled_sched_mode(ic, vap, disabled_modes);
    }

    return 0;
}

static int wlan_cfg80211_peer_disable_sched_modes(struct wiphy *wiphy,
                                                  struct wireless_dev *wdev,
                                                  struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    uint8_t mac[QDF_MAC_ADDR_SIZE];
    uint32_t disabled_modes;

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)cmd;
    disabled_modes = params->value;
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    if (cmd_type == RADIO_CMD) {
        if (ic->ic_cfg80211_radio_handler.set_peer_disable_mode)
            return ic->ic_cfg80211_radio_handler.set_peer_disable_mode((void *)scn,
                                                                       mac,
                                                                       disabled_modes);
    }

    return 0;
}

#ifdef DP_UMAC_HW_RESET_SUPPORT
/**
 * wlan_cfg80211_set_umac_reset_debug() - cfg80211 command to set umac reset debug
 *                                    commands
 * @wiphy: Pointer to wiphy structure
 * @wdev: Pointer to wdev structure
 * @params: Pointer to input params
 *
 * Return: Success or failure
 */
static int wlan_cfg80211_set_umac_reset_debug(
        struct wiphy *wiphy, struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type ,ret = 0;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err("Command on Invalid interface");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if (ic->ic_cfg80211_radio_handler.set_umac_reset_debug)
        ret = ic->ic_cfg80211_radio_handler.set_umac_reset_debug(scn, params->value,
                                                             params->length);
    else
        ret = -EOPNOTSUPP;

    return ret;
}
#endif

static int wlan_cfg80211_set_fw_hang(struct wiphy *wiphy,
                                     struct wireless_dev *wdev,
                                     struct wlan_cfg8011_genric_params *params)
{

    struct ieee80211com *ic = NULL;
    struct wlan_objmgr_psoc *psoc = NULL;
    int cmd_type;
    void *cmd;
    uint32_t *data;
    struct ol_ath_softc_net80211 *scn = NULL;
    ol_ath_soc_softc_t *soc;
    uint32_t delay_in_ms;
    uint32_t assert_type;
    int ret = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    data = (u_int32_t *)params->data;

    if (data == NULL) {
        qdf_err("Invalid Arguments");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Command on Invalid Interface\n");
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_err("Invalid interface!");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    delay_in_ms = params->value;
    assert_type = data[0];
    soc = scn->soc;

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if (!psoc) {
        qdf_err("PSOC is NULL");
        return -EINVAL;
    }

    qdf_info("Inject intended Target Assert with type %d in %dms Recovery %s",
             assert_type, delay_in_ms, (soc->recovery_enable ? "is enabled" : "disabled"));

    ret = ic->ic_set_fw_hang(psoc, delay_in_ms, assert_type);

    return ret;

}

#ifdef QCA_SUPPORT_PRIMARY_LINK_MIGRATE
/*
 * wlan_cfg80211_set_peer_ptqm_migrate: Migrate PTQM of a given peer
 * @wiphy: pointer to wiphy object
 * @wdev: pointer to wireless dev
 * @params: user params
 *
 * Return: EOK in case of succuessful migration trigger, otherwise -EINVAL
 */
static int wlan_cfg80211_set_peer_ptqm_migrate(
        struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type, retval = 0;
    void *cmd;
    uint8_t mac[QDF_MAC_ADDR_SIZE];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Command on Invalid Interface");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    if(params->data_len != QDF_MAC_ADDR_SIZE) {
        qdf_err("Invalid MAC Address!");
        return -EINVAL;
    }
    qdf_mem_copy(mac, params->data, QDF_MAC_ADDR_SIZE);

    qdf_info("Mac: " QDF_MAC_ADDR_FMT " Val: %x",
             QDF_MAC_ADDR_REF(mac), params->value);

    retval = ieee80211_ucfg_set_peer_ptqm_migrate(vap, mac, params->value);

    return qdf_status_to_os_return(retval);
}

/*
 * wlan_cfg80211_set_link_ptqm_migrate: Migrate PTQM of peers of a given link
 *@wiphy: pointer to wiphy object
 * @wdev: pointer to wireless dev
 * @params: user params
 *
 * Return: EOK in case of succuessful migration trigger, otherwise -EINVAL
 */
static int wlan_cfg80211_set_link_ptqm_migrate(
        struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type, retval = 0;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Command on Invalid Interface");
        return -EINVAL;
    }
    vap = (wlan_if_t)cmd;

    qdf_info("Trigger Link PTQM Migration");

    retval = ieee80211_ucfg_set_link_ptqm_migrate(vap);
    return qdf_status_to_os_return(retval);
}
#else
static int wlan_cfg80211_set_peer_ptqm_migrate(
        struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    qdf_err("Primary TQM Migration Not Supported");
    return -EINVAL;
}

static int wlan_cfg80211_set_link_ptqm_migrate(
        struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    qdf_err("Primary TQM Migration Not Supported");
    return -EINVAL;
}
#endif /* QCA_SUPPORT_PRIMARY_LINK_MIGRATE */

#ifdef WLAN_FEATURE_11BE_MLO
static int
wlan_cfg80211_mld_link_add_del(struct wiphy *wiphy,
                               struct wireless_dev *wdev,
                               struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic;
    int cmd_type;
    void *cmd;
    uint8_t mld_mac[QDF_MAC_ADDR_SIZE];
    bool link_add;

    if (!params) {
        qdf_err("Invalid params");
        return -EINVAL;
    }

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    if (cmd_type != VAP_CMD) {
        qdf_err("command on invalid interface");
        return -EINVAL;
    }

    link_add = params->value;

    if (!link_add) {
        osif_mldev_reconfig_link_delete(wdev->netdev, params->link_id);
        return 0;
    }

    if (params->data_len == QDF_MAC_ADDR_SIZE) {
        qdf_mem_copy(mld_mac, params->data, QDF_MAC_ADDR_SIZE);
    } else {
        qdf_err("Invalid MLD mac address");
        return -EINVAL;
    }

    osif_mldev_reconfig_link_add(wdev->netdev, mld_mac, params->link_id);

    return 0;
}

static int wlan_cfg80211_enable_ol_stats(struct wiphy *wiphy,
                                         struct wireless_dev *wdev,
                                         struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;
    uint8_t ml_grp_id;
    struct cfg80211_mld_wiphy_context *mld_cfg_ctx;
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    struct cfg80211_mld_wiphy_priv *cfg_ctx_mld = NULL;
#else
    struct cfg80211_context *cfg_ctx_mld = NULL;
#endif
    struct cfg80211_context *cfg_ctx = NULL;
    struct ieee80211com *ic = NULL;
    uint8_t idx = 0, val;
    int cmd_type;
    void *cmd;

    val = config->data.enable_ol_val.value;

    if (is_mld_phy(wiphy)) {
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
        cfg_ctx_mld = (struct cfg80211_mld_wiphy_priv *)wiphy_priv(wiphy);
#else
        cfg_ctx_mld = (struct cfg80211_context *)wiphy_priv(wiphy);
#endif
        ml_grp_id = cfg_ctx_mld->ml_grp_id;
        mld_cfg_ctx = &mld_wiphy_ctx[ml_grp_id];

        for (idx = 0; idx < NUM_MAX_RADIOS; idx++) {
            ic = mld_cfg_ctx->ic[idx];
            if (ic) {
                if (ic->ic_ath_enable_ap_stats)
                    ic->ic_ath_enable_ap_stats(ic, val);
           }
       }
      return 0;
    }

    cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    if (cmd_type == VAP_CMD) {
        qdf_err("Invalid command");
        return -EINVAL;
    }

    if (cmd_type == RADIO_CMD) {
        if (ic->ic_ath_enable_ap_stats)
            ic->ic_ath_enable_ap_stats(ic, val);
    }

    return 0;
}
#else
static int wlan_cfg80211_enable_ol_stats(struct wiphy *wiphy,
                                         struct wireless_dev *wdev,
                                         struct wlan_cfg8011_genric_params *params)
{
    return 0;
}
#endif

static int wlan_cfg80211_set_wificonfiguration(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    struct ieee80211com *ic                = NULL;
    struct wlan_cfg8011_genric_params generic_params;
    struct wlan_cfg8011_vendor_params vendor_params;
    osif_dev *osifp = NULL;
    int return_value = 0;
    struct net_device *dev = NULL;
#if QCA_SUPPORT_SON
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    struct wlan_objmgr_vdev *vdev = NULL;
#endif
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_lmac_if_rx_ops *rx_ops = NULL;
#endif
   bool is_mld_command = false;
#ifdef QCA_DYNAMIC_STA_VAP_SUPPORT
   wlan_if_t tmpvap = NULL;
#endif

    if (wiphy == NULL) {
        qdf_err("NULL wiphy argument.");
        return -EINVAL;
    }

    if (wdev == NULL) {
        qdf_err("NULL wdev argument.");
        return -EINVAL;
    }

    dev = wdev->netdev;
    osifp = ath_netdev_priv(dev);
#ifdef QCA_SUPPORT_WDS_EXTENDED
    if (osifp->dev_type == OSIF_NETDEV_TYPE_WDS_EXT) {
       qdf_err("Command is not allowed on wds ext vap");
       return -EINVAL;
    }
#endif

    qdf_mem_zero(&generic_params, sizeof(generic_params));
    extract_generic_command_params(wiphy, data, data_len, &generic_params);
    qdf_mem_zero(&vendor_params, sizeof(vendor_params));
    extract_vendor_command_params(wiphy, data, data_len, &vendor_params);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    if (!is_mld_phy_radio_command(wiphy, dev) && is_mld_netdev(dev) &&
                 !is_valid_link_id(generic_params.link_id)) {

        /* If LinkID is 0xff, command is MLD command
	 *  apply those paramters on all link_vifs or act accordingly
	 */
	if (is_allowed_mld_command(generic_params.command)) {
		is_mld_command = true;
	} else {
		qdf_err("VAP command but link ID is invalid");
		return -EINVAL;
	}
    }
#endif

    /* If we get command on MLD interface with out link_id. IC is invalid */
    if (!is_mld_command) {
        ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, generic_params.link_id);
        if (!ic) {
            qdf_err("ic NULL");
            return -EINVAL;
        }

    /*
     * Incase we need to collected debug information and
     * send it to application, allow netlink messages
     */
        if (!is_mld_phy(wiphy)) {
            if (ic->recovery_in_progress &&
                    (generic_params.command !=QCA_NL80211_VENDOR_SUBCMD_GET_QLD_ENTRY)) {
                return -EBUSY;
            }
        }
    }
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    if (is_mld_phy(wiphy)) {
        if(is_valid_sigle_phy_command(generic_params.command))
            qdf_info("Command is on Single Wiphy");
        else
            return -EINVAL;
    }

#endif

#ifdef QCA_DYNAMIC_STA_VAP_SUPPORT
    TAILQ_FOREACH(tmpvap, &ic->ic_vaps, iv_next) {
        if (tmpvap && tmpvap->iv_opmode == IEEE80211_M_STA) {
            switch (generic_params.command) {
                case QCA_NL80211_VENDORSUBCMD_CHAN_SWITCH:
                case QCA_NL80211_VENDORSUBCMD_CHAN_WIDTHSWITCH:
                case QCA_NL80211_VENDORSUBCMD_CHANNEL_CONFIG:
                case QCA_NL80211_VENDORSUBCMD_WIRELESS_MODE:
                    qdf_err("Command is not allowed with STA created");
                    return -EINVAL;
                default:
                    break;
            }
        }
    }
#endif

    /* call extract_generic_command_params */
    switch(generic_params.command) {
        case QCA_NL80211_VENDOR_SUBCMD_WIFI_PARAMS:
            if (generic_params.data == NULL) {
                qdf_print("%s: Unsupported Arguments ", __func__);
                return -EINVAL;
            }
            return_value = wlan_cfg80211_set_params(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_NAWDS_PARAMS:
            return_value = wlan_cfg80211_nawds_params(wiphy, wdev, &generic_params);
            break;
#ifdef UMAC_SUPPORT_MLNAWDS
        case QCA_NL80211_VENDOR_SUBCMD_MLNAWDS_PARAMS:
            return_value = wlan_cfg80211_mlnawds_params(wiphy, wdev, &generic_params);
            break;
#endif
#if MESH_MODE_SUPPORT
#ifdef WLAN_FEATURE_11BE_MLO
        case QCA_NL80211_VENDOR_SUBCMD_MESH_PARAMS:
            return_value = wlan_cfg80211_mesh_params(wiphy, wdev, &generic_params);
            break;
#endif
#endif
        case QCA_NL80211_VENDOR_SUBCMD_HMWDS_PARAMS:
            return_value = wlan_cfg80211_hmwds_params(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_ALD_PARAMS:
            return_value = wlan_cfg80211_ald_params(wiphy, wdev, &generic_params);
            break;
#if QCA_AIRTIME_FAIRNESS
        case QCA_NL80211_VENDOR_SUBCMD_ATF:
            return_value = wlan_cfg80211_atf(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_WNM:
            return_value = wlan_cfg80211_wnm_params(wiphy, wdev, &generic_params);
            break;
#if ATH_SUPPORT_HYFI_ENHANCEMENTS
        case QCA_NL80211_VENDOR_SUBCMD_ME_LIST:
            return_value = wlan_cfg80211_me_list_params(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_SET_MAXRATE:
            return_value = wlan_cfg80211_set_maxrate(wiphy, wdev, &generic_params);
            break;
#if ATH_SUPPORT_DYNAMIC_VENDOR_IE
        case QCA_NL80211_VENDOR_SUBCMD_VENDORIE:
            return_value = wlan_cfg80211_vendorie_params(wiphy, wdev, &generic_params);
            break;
#endif
#if ATH_SUPPORT_NAC
        case QCA_NL80211_VENDOR_SUBCMD_NAC:
            return_value = wlan_cfg80211_nac_params(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_LIST_SCAN:
            return_value = wlan_cfg80211_list_scan(wiphy, wdev, &generic_params);
            break;
#if QLD
        case QCA_NL80211_VENDOR_SUBCMD_GET_QLD_ENTRY:
            return_value = wlan_cfg80211_get_qld_dump(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_LIST_CAP:
            return_value = wlan_cfg80211_list_cap(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_LIST_STA:
        case QCA_NL80211_VENDOR_SUBCMD_LIST_PASN_PEER:
            return_value = wlan_cfg80211_list_sta(wiphy, wdev, &generic_params, false);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_ACTIVECHANLIST:
            return_value = wlan_cfg80211_active_chan_list(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_LIST_CHAN:
#ifdef WLAN_FEATURE_11BE
            return_value = wlan_cfg80211_list_channels(wiphy, wdev, &generic_params);
#else
            return_value = wlan_cfg80211_list_chan(wiphy, wdev, &generic_params);
#endif
            break;
        case QCA_NL80211_VENDOR_SUBCMD_LIST_CHAN160:
            return_value = wlan_cfg80211_list_chan160(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_DBGREQ:
            return_value = wlan_cfg80211_dbgreq(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_PHYSTATS:
            return_value = wlan_cfg80211_phystats(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_ATHSTATS:
            return_value = wlan_cfg80211_athstats(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_EXTENDEDSTATS:
            return_value = wlan_cfg80211_extendedstats(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_80211STATS:
            return_value = wlan_cfg80211_80211stats(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_VAP_STATS:
            return_value = wlan_cfg80211_vap_stats(wiphy, wdev, &generic_params, false);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_RADIO_STATS:
            return_value = wlan_cfg80211_radio_stats(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_STA_STATS:
            return_value = wlan_cfg80211_sta_stats(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_CLONEPARAMS:
            return_value = wlan_cfg80211_cloneparams(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_ADDMAC:
            return_value = wlan_cfg80211_addmac(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_DELMAC:
            return_value = wlan_cfg80211_delmac(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_KICKMAC:
            return_value = wlan_cfg80211_kickmac(wiphy, wdev, &generic_params);
            break;
#if UMAC_SUPPORT_ACFG
        case QCA_NL80211_VENDOR_SUBCMD_VAP_VENDOR_PARAM:
            return_value = wlan_cfg80211_vap_vendor_param(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_SET_AP:
            return_value = wlan_cfg80211_set_bssid(wiphy, wdev, &generic_params);
            break;
#if WLAN_DFS_CHAN_HIDDEN_SSID
        case QCA_NL80211_VENDORSUBCMD_CONF_BSSID:
            return_value = wlan_cfg80211_conf_bssid(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_GET_CONF_BSSID:
            return_value = wlan_cfg80211_get_conf_bssid(wiphy, wdev, &generic_params);
            break;
#endif /* WLAN_DFS_CHAN_HIDDEN_SSID */
        case QCA_NL80211_VENDORSUBCMD_CHAN_SWITCH:
            return_value = wlan_cfg80211_chan_switch(wiphy, wdev, &generic_params, &vendor_params);
            /*Save the user configured channel*/
            if (!return_value) {
                ic->ic_userconfiguredchan_obj = *(ic->ic_chanchange_channel);
            }
            break;
        case QCA_NL80211_VENDORSUBCMD_CHAN_WIDTHSWITCH:
            if (generic_params.data == NULL) {
                qdf_err("Insufficient Arguments");
                qdf_err("doth_ch_chwidth requires channel, tbtt, width, and band if applicable");
                return -EINVAL;
            }
            return_value = wlan_cfg80211_chan_widthswitch(wiphy, wdev, &generic_params, &vendor_params);
            if (!return_value) {
                ic->ic_userconfiguredchan_obj = *(ic->ic_chanchange_channel);
            }
            break;
        case QCA_NL80211_VENDOR_SUBCMD_CHANNEL_TUPLE:
            return_value = wlan_cfg80211_chan_tuple_set(wiphy, wdev, &generic_params, &vendor_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_WIRELESS_MODE:
            return_value = wlan_cfg80211_set_wirelessmode(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_AC_PARAMS:
            return_value = wlan_cfg80211_set_acparams(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_RC_PARAMS_SETRTPARAMS:
            return_value = wlan_cfg80211_setrtparams(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_SETFILTER:
            return_value = wlan_cfg80211_set_filter(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_SEND_MGMT:
            return_value = wlan_cfg80211_send_mgmt(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_MAC_COMMANDS:
            return_value = wlan_cfg80211_mac_commands(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_WMM_PARAMS:
            return_value = wlan_cfg80211_set_wmm_params(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_COUNTRY_CONFIG:
            return_value = wlan_cfg80211_set_country(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_HWADDR_CONFIG:
            return_value = wlan_cfg80211_set_hwaddr(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_AGGR_BURST_CONFIG:
            return_value = wlan_cfg80211_set_aggr_burst(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_ATF_SCHED_DURATION_CONFIG:
            return_value = wlan_cfg80211_set_atf_sched_dur(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_TXRX_PEER_STATS:
            return_value = wlan_cfg80211_txrx_peer_stats(wiphy, wdev, &generic_params);
            break;
            /* channel configuration for propritery modes */
        case QCA_NL80211_VENDORSUBCMD_CHANNEL_CONFIG:
            return_value = wlan_cfg80211_set_channel(wiphy, wdev, &generic_params, &vendor_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_GET_CHANNEL:
            return_value = wlan_cfg80211_get_channel_config(wiphy, wdev,
                                                            &generic_params);
            break;
            /* ssid configuration for propritery modes */
        case QCA_NL80211_VENDORSUBCMD_SSID_CONFIG:
            return_value = wlan_cfg80211_set_ssid(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_MGMT_RSSI_THR:
            return_value = wlan_cfg80211_set_mgmt_rssi_thr(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_GET_SSID:
            return_value= wlan_cfg80211_get_ssid(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_ACLMAC:
            return_value = wlan_cfg80211_get_aclmac(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_DP_FW_PEER_STATS:
            return_value = wlan_cfg80211_txrx_dp_fw_peer_stats(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_SET_PEER_NEXTHOP:
            return_value = wlan_cfg80211_set_peer_nexthop(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_CHECK_11H:
            return_value = wlan_cfg80211_check_11hcap(wiphy, wdev, &generic_params);
			break;
        case QCA_NL80211_VENDORSUBCMD_GET_PEER_EXTD_RATE_LINK_STATS:
            return_value = wlan_cfg80211_get_peer_extd_rate_link_stats(wiphy, wdev, &generic_params);
            break;
#if ATH_SUPPORT_NAC_RSSI
        case QCA_NL80211_VENDOR_SUBCMD_NAC_RSSI:
            return_value = wlan_cfg80211_nac_rssi_params(wiphy, wdev, &generic_params);
            break;
#endif
#if QCA_SUPPORT_PEER_ISOLATION
        case QCA_NL80211_VENDOR_SUBCMD_PEER_ISOLATION:
            return_value = wlan_cfg80211_peer_isolation_params(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_HTTSTATS:
            return_value = wlan_cfg80211_httstats(wiphy, wdev, &generic_params);
            break;
#if ATH_ACL_SOFTBLOCKING
        case QCA_NL80211_VENDORSUBCMD_ADDMAC_SEC:
            return_value= wlan_cfg80211_addmac_sec(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_DELMAC_SEC:
            return_value = wlan_cfg80211_delmac_sec(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_GET_ACLMAC_SEC:
           return_value =  wlan_cfg80211_get_aclmac_sec(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_SET_SU_SOUNDING_INT:
            return_value = wlan_cfg80211_set_su_sounding_int(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_SET_MU_SOUNDING_INT:
            return_value = wlan_cfg80211_set_mu_sounding_int(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_ENABLE_SOUNDING_INT:
            return_value = wlan_cfg80211_enable_sounding_int(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_SCHED_MU_ENABLE:
            return_value = wlan_cfg80211_sched_mu_enable(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_SCHED_OFDMA_ENABLE:
            return_value = wlan_cfg80211_sched_ofdma_enable(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_HE_MESH_CONFIG:
            return_value = wlan_cfg80211_he_mesh_config(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_HE_BSS_COLOR:
            return_value = wlan_cfg80211_he_bss_color(wiphy, wdev, &generic_params);
            break;
	case QCA_NL80211_VENDOR_SUBCMD_HALPHY_CAL:
            return_value = wlan_cfg80211_set_halphy_cal(wiphy, wdev, &generic_params);
            break;
#if OBSS_PD
        case QCA_NL80211_VENDOR_SUBCMD_HE_SR_CONFIG:
            return_value = wlan_cfg80211_he_sr_config(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_HE_SRG_BITMAP:
            return_value = wlan_cfg80211_set_he_srg_bitmap(wiphy, wdev, &generic_params);
            break;
#endif /* OBSS PD */
        case QCA_NL80211_VENDOR_SUBCMD_NAV_OVERRIDE_CONFIG:
            return_value = wlan_cfg80211_nav_config(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_SET_BA_TIMEOUT:
            return_value = wlan_cfg80211_set_ba_timeout(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_BA_TIMEOUT:
            return_value = wlan_cfg80211_get_ba_timeout(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MU_EDCA_PARAMS:
            return_value = wlan_cfg80211_set_muedca_params(wiphy, wdev, &generic_params);
            break;
#if ATH_ACS_DEBUG_SUPPORT
        case QCA_NL80211_VENDOR_SUBCMD_ACSDBGTOOL_ADD_BCN:
            return_value = wlan_cfg80211_acsdbgtool_add_bcn(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_ACSDBGTOOL_ADD_CHAN:
            return_value = wlan_cfg80211_acsdbgtool_add_chanev(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDORSUBCMD_RC_PARAMS_SETRATEMASK:
            return_value = wlan_cfg80211_setratemask(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_SET_BLOCK_MGT:
            return_value = wlan_cfg80211_set_block_mgt(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_CLR_BLOCK_MGT:
            return_value = wlan_cfg80211_clr_block_mgt(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_GET_BLOCK_MGT:
            return_value = wlan_cfg80211_get_block_mgt(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_ADDIE:
            return_value = wlan_cfg80211_addie(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_SET_VLAN_TYPE:
            return_value = wlan_cfg80211_set_vlan_type(wiphy, wdev, &generic_params);
            break;
#if WLAN_CFR_ENABLE
        case QCA_NL80211_VENDOR_SUBCMD_CFR_CONFIG:
            return_value = wlan_cfg80211_cfr_params(wiphy, wdev, &generic_params);
            break;
#endif
#ifdef WLAN_WIFI_RADAR_ENABLE
        case QCA_NL80211_VENDOR_SUBCMD_WIFI_RADAR_CONFIG:
             return_value = wlan_cfg80211_wifi_radar_params(wiphy, wdev, &generic_params);
             break;
#endif
#ifdef CONFIG_SAWF_DEF_QUEUES
        case QCA_NL80211_VENDOR_SUBCMD_SAWF_CONFIG:
            return_value = wlan_cfg80211_sawf_params(wiphy, wdev, &generic_params);
            break;
#endif
#if UNIFIED_SMARTANTENNA
        case QCA_NL80211_VENDOR_SUBCMD_SA_PARAMS:
            return_value = wlan_cfg80211_set_sa_params(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDORSUBCMD_DEFAULT_PCP_TID_MAP:
            return_value = wlan_cfg80211_set_def_pcp_tid_map(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_DEFAULT_TIDMAP_PRTY:
            return_value = wlan_cfg80211_set_def_tidmap_prty(wiphy, wdev, &generic_params);
            break;
#if UMAC_SUPPORT_ACFG
        case QCA_NL80211_VENDOR_SUBCMD_ACFG:
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
            return_value = wlan_cfg80211_acfg(wiphy, wdev, generic_params.data, generic_params.data_len);
#endif
            break;
#endif
#ifdef WLAN_SUPPORT_RX_PROTOCOL_TYPE_TAG
        case QCA_NL80211_VENDOR_SUBCMD_RX_PKT_PROTOCOL_TAG:
            return_value = wlan_cfg80211_rx_pkt_protocol_tag(wiphy, wdev, &generic_params);
            break;
#ifdef WLAN_SUPPORT_RX_TAG_STATISTICS
        case QCA_NL80211_VENDOR_SUBCMD_RX_PKT_PROTOCOL_TAG_STATS:
            wlan_cfg80211_dump_rx_pkt_protocol_tag_stats(wiphy, wdev, &generic_params);
            break;
#endif /* WLAN_SUPPORT_RX_TAG_STATISTICS */
#endif /* WLAN_SUPPORT_RX_PROTOCOL_TYPE_TAG */
#if defined(WLAN_RX_PKT_CAPTURE_ENH) || defined(WLAN_TX_PKT_CAPTURE_ENH)
		case QCA_NL80211_VENDOR_SUBCMD_SET_PEER_PKT_CAPTURE_PARAMS:
            return_value = monitor_cfg80211_set_peer_pkt_capture_params(wiphy, wdev, &generic_params);
            break;
#endif /* WLAN_RX_PKT_CAPTURE_ENH || WLAN_TX_PKT_CAPTURE_ENH */
        case QCA_NL80211_VENDOR_SUBCMD_SET_BTCOEX_DUTY_CYCLE:
            wlan_cfg80211_set_btcoex_duty_cycle(wiphy, wdev, &generic_params);
            break;
#ifdef WLAN_SUPPORT_RX_FLOW_TAG
        case QCA_NL80211_VENDOR_SUBCMD_RX_FLOW_TAG_OP:
            return_value = wlan_cfg80211_rx_flow_tag_op(wiphy, wdev, &generic_params);
            break;
#endif /* WLAN_SUPPORT_RX_FLOW_TAG */
        case QCA_NL80211_VENDORSUBCMD_LIST_SUPPORTED_BANDS:
            return_value = wlan_cfg80211_list_bands(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MUEDCA_MODE:
            return_value = wlan_cfg80211_set_muedca_mode(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_NON_HT_DUP_EN:
            return_value = wlan_cfg80211_set_non_ht_dup_en(wiphy, wdev,
                                                            &generic_params);
            break;
#if OBSS_PD
        case QCA_NL80211_VENDOR_SUBCMD_SR_SELF_CONFIG:
            return_value = wlan_cfg80211_sr_self_config(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_WMISTATS:
            return_value = wlan_cfg80211_wmistats(wiphy, wdev, &generic_params);
            break;

        case QCA_NL80211_VENDOR_SUBCMD_HALPHY_STATS:
            return_value = wlan_cfg80211_halphystats(wiphy, wdev, &generic_params);
            break;

        case QCA_NL80211_VENDOR_SUBCMD_RNR_6GHZ:
            return_value = wlan_cfg80211_set_6ghz_rnr(wiphy, wdev, &generic_params);
            break;

#if DBG_LVL_MAC_FILTERING
        case QCA_NL80211_VENDOR_SUBCMD_DBGLVLMAC:
            return_value = wlan_cfg80211_set_dbglvlmac(wiphy, wdev, &generic_params);
            break;
#endif /* DBG_LVL_MAC_FILTERING */
        case QCA_NL80211_VENDOR_SUBCMD_RTT_CONFIG:
            return_value = wlan_cfg80211_rtt_params(
                    wiphy, wdev, &generic_params);
            break;
#if QCA_SUPPORT_SON
        case QCA_NL80211_VENDOR_SUBCMD_MESH_CONFIGURATION:
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
            if (ic == NULL) {
                return -EINVAL;
            }

            psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
#else /* ENABLE_CFG80211_BACKPORTS_MLO */
            if (dev == NULL) {
                return -EINVAL;
            }
            vdev = wlan_get_vdev_from_netdev(dev);
            if (vdev == NULL) {
                return -EINVAL;
            }

            psoc = wlan_vdev_get_psoc(vdev);
#endif /* ENABLE_CFG80211_BACKPORTS_MLO */

            if (psoc) {
                rx_ops = wlan_psoc_get_lmac_if_rxops(psoc);
            }

            if (rx_ops && rx_ops->son_rx_ops.config_set) {
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
                return_value = rx_ops->son_rx_ops.config_set(&generic_params,
                                wiphy, wdev);
#else /* ENABLE_CFG80211_BACKPORTS_MLO */
                return_value = rx_ops->son_rx_ops.config_set(vdev,
                                              &generic_params);
#endif /* ENABLE_CFG80211_BACKPORTS_MLO */
            }
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MESH_SET_GET_CONFIG:
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
            if (dev == NULL) {
                return -EINVAL;
            }
            vdev = wlan_get_vdev_from_netdev(dev);
            if (vdev == NULL) {
                return -EINVAL;
            }
#endif /* ENABLE_CFG80211_BACKPORTS_MLO */
            if (ic) {
                psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
            }

            if (psoc) {
                rx_ops = wlan_psoc_get_lmac_if_rxops(psoc);
            }

            if (rx_ops && rx_ops->son_rx_ops.config_ext_set_get) {
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
                return_value = rx_ops->son_rx_ops.config_ext_set_get(&generic_params,
                                NULL, wiphy, wdev);
#else /* ENABLE_CFG80211_BACKPORTS_MLO */
                return_value = rx_ops->son_rx_ops.config_ext_set_get(vdev,
                                &generic_params, NULL);
#endif /* ENABLE_CFG80211_BACKPORTS_MLO */
            }
            break;

#endif
#if !(defined REMOVE_PKT_LOG) && (defined PKTLOG_DUMP_UPLOAD_SSR)
        case QCA_NL80211_VENDOR_SUBCMD_PKTLOG_SSR:
            wlan_cfg80211_set_pktlog_dump_ssr(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_SET_KEY:
            return_value = wlan_cfg80211_athkey_set_key(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_DEL_KEY:
            return_value = wlan_cfg80211_athkey_del_key(wiphy, wdev, &generic_params);
            break;
#ifdef WIFI_MONITOR_SUPPORT
#ifdef QCA_UNDECODED_METADATA_SUPPORT
        case QCA_NL80211_VENDOR_SUBCMD_SET_PHYRX_ERROR_MASK:
            return_value = monitor_cfg80211_set_phyrx_error_mask(wiphy, wdev,
                                                            &generic_params);
            break;
#endif
#endif
        case QCA_NL80211_VENDOR_SUBCMD_MU_SNIF:
            return_value = wlan_cfg80211_mu_snif(
                    wiphy, wdev, &generic_params);
            break;
#ifdef CONFIG_AFC_SUPPORT
        case QCA_NL80211_VENDOR_SUBCMD_AFC_RESET:
            return_value = wlan_cfg80211_afc_reset(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_AFC_PAYLOAD_RESET:
            return_value = wlan_cfg80211_afc_payload_reset(wiphy, wdev, &generic_params);
            break;
#endif
#if CONFIG_SAWF_DEF_QUEUES
        case QCA_NL80211_VENDORSUBCMD_DP_SAWF_PEER_SVCID_MAP:
            return_value = wlan_cfg80211_sawf_peer_svcid_map(wiphy, wdev,
                                                             &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_DP_SAWF_PEER_SVCID_UNMAP:
            return_value = wlan_cfg80211_sawf_peer_svcid_unmap(wiphy, wdev,
                                                               &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_DP_SAWF_PEER_MAP_REPORT:
            return_value = wlan_cfg80211_sawf_peer_map_report(wiphy, wdev,
                                                              &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_SET_RC_PARAMS_RATE_UPPER_CAP:
            return_value = wlan_cfg80211_set_rate_upper_cap(wiphy, wdev,
                                                            &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_SET_RC_PARAMS_RATE_RETRY_MCS_DROP:
            return_value =
                wlan_cfg80211_set_rate_retry_mcs_drop(wiphy, wdev,
                                                      &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_SET_RC_PARAMS_MCS_PROBE_INTVL:
            return_value = wlan_cfg80211_set_mcs_probe_intvl(wiphy, wdev,
                                                             &generic_params);
            break;
        case QCA_NL80211_VENDORSUBCMD_SET_RC_PARAMS_NSS_PROBE_INTVL:
            return_value = wlan_cfg80211_set_nss_probe_intvl(wiphy, wdev,
                                                             &generic_params);
            break;
#endif
#ifdef CONFIG_SAWF
        case QCA_NL80211_VENDOR_SUBCMD_SAWF_PEER_MSDUQ_REPORT:
            return_value =
                wlan_cfg80211_sawf_peer_msduq_map_report(wiphy, wdev,
                                                         &generic_params);
            break;
#endif
#ifdef WLAN_MGMT_RX_REO_SUPPORT
        case QCA_NL80211_VENDOR_SUBCMD_MGMT_RX_REO_SIMULATION:
            return_value = wlan_cfg80211_set_mgmt_rx_reo_simulation(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_MCTBL_UPDATE:
            return_value = wlan_cfg80211_update_mctbl(wiphy, wdev, &generic_params);
            break;
#ifdef QCA_SUPPORT_LITE_MONITOR
        case QCA_NL80211_VENDOR_SUBCMD_LITE_MONITOR:
            return_value = monitor_cfg80211_lite_monitor_config(wiphy, wdev, &generic_params);
        break;
#endif
#ifdef WLAN_FEATURE_11BE
        case QCA_NL80211_VENDOR_SUBCMD_T2LM:
            return_value = wlan_cfg80211_config_t2lm(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_T2LM_LINK_MAP_CONFIG:
            return_value = wlan_cfg80211_t2lm_link_map_config(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_EPCS:
            return_value = wlan_cfg80211_config_epcs(wiphy, wdev, &generic_params);
            break;
#endif /* WLAN_FEATURE_11BE */
        case QCA_NL80211_VENDOR_SUBCMD_TDMA_SCHEDULE_CONFIG:
            return_value = wlan_cfg80211_tdma_schedule(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_PROBE_WH_CONFIG:
            return_value = wlan_cfg80211_config_probe_wh(wiphy, wdev, &generic_params);
            break;
#ifdef IPA_OFFLOAD
        case QCA_NL80211_VENDOR_SUBCMD_DELETE_WDS_AST:
            return_value = wlan_cfg80211_ipa_wds_delete_params(wiphy, wdev, &generic_params);
            break;
#endif
#ifdef WLAN_FEATURE_11BE_MLO
        case QCA_NL80211_VENDOR_SUBCMD_GET_MLDEV_PARAMS:
            return_value = wlan_cfg80211_get_mldev_params(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDORSUBCMD_DISABLE_SCHED_MODES:
            return_value = wlan_cfg80211_disable_sched_modes(wiphy, wdev,
                                                             &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_PEER_DISABLE_SCHED_MODES:
            return_value = wlan_cfg80211_peer_disable_sched_modes(wiphy, wdev,
                                                                  &generic_params);
            break;

#ifdef DP_UMAC_HW_RESET_SUPPORT
        case QCA_NL80211_VENDOR_SUBCMD_UMAC_RESET_DEBUG:
            return wlan_cfg80211_set_umac_reset_debug(wiphy, wdev, &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_SET_FW_HANG:
            return_value = wlan_cfg80211_set_fw_hang(wiphy, wdev, &generic_params);
            break;
#ifdef WLAN_FEATURE_11BE_MLO
        case QCN_NL80211_LINK_RECOMMENDATION_CMD:
            return_value = wlan_cfg80211_set_link_recommendation(wiphy, wdev, &generic_params);
            break;

        case QCA_NL80211_VENDOR_SUBCMD_PTQM_PEER_MIGRATE:
            return_value = wlan_cfg80211_set_peer_ptqm_migrate(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_PTQM_LINK_MIGRATE:
            return_value = wlan_cfg80211_set_link_ptqm_migrate(wiphy, wdev, &generic_params);
            break;
#endif
#ifdef WLAN_FEATURE_11BE_MLO
        case QCA_NL80211_VENDOR_SUBCMD_MLD_LINK_ADD_DEL:
            return_value = wlan_cfg80211_mld_link_add_del(wiphy, wdev,
                                                          &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_LINK_INFO:
            return_value = wlan_cfg80211_list_link_info(wiphy, wdev,
                           &generic_params);
            break;
#endif
        case QCA_NL80211_VENDOR_SUBCMD_ENABLE_OL_STATS:
            return_value = wlan_cfg80211_enable_ol_stats(wiphy, wdev,
                                                         &generic_params);
           break;
        case QCA_NL80211_VENDOR_SUBCMD_GET_BSS_PEER:
            return_value = wlan_cfg80211_list_sta(wiphy, wdev, &generic_params, true);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_STA_VAP_STATS:
            return_value = wlan_cfg80211_vap_stats(wiphy, wdev, &generic_params, true);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_DEAUTHMAC:
            return_value = wlan_cfg80211_deauthmac(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_ULOFDMA_RTD:
            return_value = wlan_cfg80211_set_ulofdma_rtd(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_MON_FCS_CAP:
            return_value = monitor_cfg80211_set_mon_fcs_cap((struct ol_ath_softc_net80211 *)ic, wiphy, wdev, &generic_params);
            break;
#ifdef QCA_BLOCK_EVENT_TO_USERSPACE
        case QCA_NL80211_VENDOR_SUBCMD_SET_EVENT_FILTER:
            return_value = wlan_cfg80211_set_event_filter(wiphy, wdev, &generic_params);
            break;
#endif /* QCA_BLOCK_EVENT_TO_USERSPACE */
#ifdef QCA_SUPPORT_EAPOL_OVER_CONTROL_PORT
        case QCA_NL80211_VENDOR_SUBCMD_EAPOL_OVER_NL:
            return_value = wlan_cfg80211_set_eapol_over_nl(wiphy, wdev, &generic_params);
            break;
        case QCA_NL80211_VENDOR_SUBCMD_VAP_EAPOL_OVER_NL:
            return_value = wlan_cfg80211_set_vap_eapol_over_nl(wiphy, wdev, &generic_params);
            break;
#endif
        default:
            qdf_err( "%s: Unsuported Genric command: %d ", __func__, generic_params.command);
            return_value = -EOPNOTSUPP;
    }

    return return_value;
}

static const struct nla_policy
wlan_cfg80211_set_params_policy[QCA_WLAN_VENDOR_ATTR_SETPARAM_MAX + 1] = {

    [QCA_WLAN_VENDOR_ATTR_SETPARAM_COMMAND] = {.type = NLA_U32 },
    [QCA_WLAN_VENDOR_ATTR_SETPARAM_VALUE] = {.type = NLA_U32 },
};

/*
 * ieee80211_modify_param_value_based_on_band() - Given channel IEEE number
 * and "band" flag, return the frequency in MHZ.
 * @param: Config param
 * @value: IEEE channel number
 * @params: Pointer to cfg80211 param.
 * Return: Frequency correponding to the channel number if band flag is given.
 *         Else return 0.
 */

static uint16_t
ieee80211_modify_param_value_based_on_band(struct ieee80211com *ic, int param,
                                           int value, struct wlan_cfg8011_genric_params *params)
{
    enum wlan_band_id band = WLAN_BAND_UNSPECIFIED;
    uint16_t freq = 0;

    if (param & OL_ATH_PARAM_SHIFT) {
        param -= OL_ATH_PARAM_SHIFT;
    }
    switch(param)
    {
#ifdef WLAN_DFS_PRECAC_AUTO_CHAN_SUPPORT
        case OL_ATH_PARAM_PRECAC_INTER_CHANNEL:
            if (value < wlan_reg_min_5ghz_chan_freq()) {
                band = params->length;
                freq = wlan_get_wlan_band_id_chan_to_freq(ic->ic_pdev_obj,value, band);
                if (!freq) {
                    qdf_err("invalid chan: %d and band: %d", value, band);
                    return -1;
                }
                return freq;
            }
#endif
        default:
            break;
    }
    IEEE80211_DPRINTF_IC_CATEGORY(ic, IEEE80211_MSG_IOCTL,
            "%s: chan: %d, band: %d and freq: %d", __func__, value, band, freq);
    return freq;
}

#ifdef WLAN_FEATURE_11BE_MLO
/*
 * configure the param in partner vdev
 */
void
ieee80211_ucfg_setparam_on_partner_vap(wlan_if_t vap, int param, int value, char *extra)
{
    struct wlan_objmgr_vdev *wlan_vdev_list[WLAN_UMAC_MLO_MAX_VDEVS] = {NULL};
    struct wlan_objmgr_vdev *vdev = NULL;
    struct ieee80211vap *link_vap = NULL;
    struct wlan_mlo_dev_context *mlo_dev_ctx = NULL;
    uint16_t vdev_count = 0;
    int i = 0;

    if (!wlan_vdev_mlme_is_mlo_vdev(vap->vdev_obj))
        return;

    switch (param)
    {
    case IEEE80211_PARAM_VAP_TX_ENCAP_TYPE:
    case IEEE80211_PARAM_VAP_RX_DECAP_TYPE:
    case IEEE80211_PARAM_ME:
    case IEEE80211_PARAM_IGMP_ME:
    case IEEE80211_PARAM_PROXYARP_CAP:
    case IEEE80211_FEATURE_APBRIDGE:
    case IEEE80211_PARAM_HLOS_TID_OVERRIDE:
    case IEEE80211_PARAM_DROP_3ADDR_MCAST:
#ifdef QCA_SUPPORT_WDS_EXTENDED
    case IEEE80211_PARAM_DROP_TX_MCAST:
    case IEEE80211_PARAM_WDS_EXT_AP_BRIDGE:
#endif
    case IEEE80211_PARAM_RAWMODE_PKT_SIM:
        break;

    default:
        return;
    }

    mlo_get_ml_vdev_list(vap->vdev_obj, &vdev_count, wlan_vdev_list);
    if (vdev_count) {
        for (i = 0; i < vdev_count; i++) {
            vdev = wlan_vdev_list[i];
            if (!vdev)
                return;

            link_vap = wlan_vdev_mlme_get_ext_hdl(vdev);
            if (!link_vap)
                break;
            /* for the self vap caller will trigger setparam */
            if (link_vap == vap)
                continue;

            ieee80211_ucfg_setparam(link_vap, param, value ,(char *) &extra);
        }
        if (ieee80211_mlo_release_vdev_list_refs( wlan_vdev_list,
                                                  QDF_ARRAY_SIZE(wlan_vdev_list),
                                                  vdev_count, 0) != QDF_STATUS_SUCCESS) {
            qdf_info("failed to release mlo vdev ref");
        }
    }

    mlo_dev_ctx = vap->vdev_obj->mlo_dev_ctx;
    if (!mlo_dev_ctx)
        return;

    /* update the param in bridge */
    for (i = 0; i < WLAN_UMAC_MLO_MAX_BRIDGE_VDEVS; i++) {
        if (mlo_dev_ctx->wlan_bridge_vdev_list[i]) {
            link_vap = wlan_vdev_get_vap(mlo_dev_ctx->wlan_bridge_vdev_list[i]);
            if (link_vap)
                ieee80211_ucfg_setparam(link_vap, param, value, (char *)&extra);
        }
    }
}
#else
void
ieee80211_ucfg_setparam_on_partner_vap(wlan_if_t vap, int param, int value, char *extra)
{
}
#endif

/**
 * wlan_cfg80211_set_params - get driver DFS capability
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_set_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
#define IWPRIV_PARAM_INDEX  0
#define IWPRIV_VALUE_INDEX  1
#define IWPRIV_LENGTH_INDEX 2
#define IWPRIV_FLAGS_INDEX  3
#define IWPRIV_MAX_INDEX    4
    struct ieee80211com *ic = NULL;
    struct net_device *dev = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    enum wlan_band_id band = WLAN_BAND_UNSPECIFIED;
    uint16_t freq;
    int param = params->value;
    u_int32_t *data = (u_int32_t *) params->data;
    int value = *data;
    int extra[IWPRIV_MAX_INDEX];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    extra[IWPRIV_PARAM_INDEX]  = param;
    extra[IWPRIV_VALUE_INDEX]  = value;
    extra[IWPRIV_LENGTH_INDEX] = (int)params->length;
    extra[IWPRIV_FLAGS_INDEX]  = (uint32_t)params->flags;

    switch (param) {
        case IEEE80211_PARAM_SECOND_CENTER_FREQ:
            if (value < wlan_reg_min_5ghz_chan_freq()) {
                band = params->length;
                freq = wlan_get_wlan_band_id_chan_to_freq(ic->ic_pdev_obj, value, band);
                if (!freq) {
                    qdf_err("invalid chan: %d and band: %d", value, band);
                    return -1;
                }
                value = freq;
            }
            break;
        default:
            break;
    }

#ifdef WLAN_FEATURE_11BE
    switch (param) {
        case IEEE80211_PARAM_EHT_BFME_SS:
        case IEEE80211_PARAM_EHT_NUM_SD:
            extra[IWPRIV_VALUE_INDEX+1] = params->length;
            extra[IWPRIV_VALUE_INDEX+2] = params->flags;
            break;
        default:
            break;
    }
#endif

    if (ic->ic_wdev.netdev == wdev->netdev) {
        dev = wdev->netdev;
        scn = get_radio_device_context(wiphy, dev);
        if (ic->ic_cfg80211_radio_handler.setparam) {
            int ret;
            ret = ieee80211_modify_param_value_based_on_band(ic, param, value,
                                                             params);
            if (ret != 0)
                value = ret;
            return ic->ic_cfg80211_radio_handler.setparam((void*)scn, param, value, (int *) &extra);
         } else {
            return -EOPNOTSUPP;
         }
    } else {
        dev = wdev->netdev;
        osifp = get_vap_device_context(wiphy, dev, params->link_id);
        if (!osifp) {
            qdf_err("%s: osifp NULL\n", __func__);
            return -EINVAL;
        }
        vap = osifp->os_if;
        if (vap == NULL) {
            qdf_print("%s: VAP is null ", __func__);
            return -1;
        }

        ieee80211_ucfg_setparam_on_partner_vap(vap, param, value, (char *) &extra);
        return ieee80211_ucfg_setparam(vap, param, value ,(char *) &extra);
    }

    return 0;
}

static const struct nla_policy
wlan_cfg80211_get_params_policy[QCA_WLAN_VENDOR_ATTR_SETPARAM_MAX + 1] = {
    [QCA_WLAN_VENDOR_ATTR_SETPARAM_COMMAND] = {.type = NLA_U32 },
};

#ifdef CONFIG_SAWF_DEF_QUEUES
/**
 * wlan_cfg80211_sawf_params - get SAWF params
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_sawf_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int ret = 0;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;
    struct sawf_rsp_param rsp_param = {0};

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic is NULL!");
        return -EINVAL;
    }

    ret = ieee80211_ucfg_sawf_params(ic, config, &rsp_param);

    if (!ret && (config->cmdtype == IEEE80211_WLANCONFIG_SVC_CREATE ||
                config->cmdtype == IEEE80211_WLANCONFIG_SVC_UPDATE)) {
        struct sawf_wlanconfig_svc_rsp rsp;
        rsp.svc_id = rsp_param.svc_id;
        ret = cfg80211_reply_command(wiphy, sizeof(rsp), &rsp, 0);
    }

    return ret;
}
#endif

#ifdef WLAN_WIFI_RADAR_ENABLE
/**
 * wlan_cfg80211_wifi_radar_params - configure wifi radar params
 * @wiphy: pointer to wireless wiphy structure.
 * @wdev: pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_wifi_radar_params(struct wiphy *wiphy,
                                    struct wireless_dev *wdev,
                                    struct wlan_cfg8011_genric_params *params)
{
   struct ieee80211com *ic = NULL;
   int cmd_type, length;
   void *cmd;
   int ret = 0;
   struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

   ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
   if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
   }

   cmd = extract_command(ic, wdev, &cmd_type, params->link_id);
   if (!cmd) {
       qdf_err("%s: cmd is NULL\n", __func__);
       return -EINVAL;
   }

   if (!cmd_type) {
        qdf_info("Invalid vap Command !");
        return -EINVAL;
   }
   ret = ieee80211_ucfg_wifi_radar_params(ic, config);

   if (config->cmdtype == IEEE80211_WLANCONFIG_WIFI_RADAR_GET_RX_CAL_STATUS) {
       length = sizeof(struct ieee80211_wlanconfig);
       /*
        * Allocate memory size of the data being sent + skb header length + u_32 for FLA + u_32
        * for the length of the data being sent
        */
       ret = cfg80211_reply_command(wiphy, length, config, 0);
   }

   return ret;
}
#endif

#if WLAN_CFR_ENABLE
/**
 * wlan_cfg80211_cfr_params - get cfr params
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_cfr_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    int ret = 0;

    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_info("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (vap == NULL) {
        qdf_err("Vap is NULL !");
        return -EINVAL;
    }

    ret = ieee80211_ucfg_cfr_params(ic, vap, config);

    return ret;
}
#endif

int wlan_cfg80211_rtt_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;

    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_info("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (!vap) {
        qdf_err("Vap is NULL !");
        return -EINVAL;
    }

    return ieee80211_ucfg_rtt_params(ic, vap, config);
}

/**
 * wlan_cfg80211_nawds_params - get nawds params
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_nawds_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int length, cmd_type;
    void *cmd;
    int ret = 0;

    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (vap == NULL) {
        qdf_err("Vap is NULL!");
        return -EINVAL;
    }

    /* NAWDS configs valid only for Host AP mode */
    if (vap->iv_opmode != IEEE80211_M_HOSTAP) {
        qdf_err("cmd not supported for this mode");
        return -EINVAL;
    }

    ret = ieee80211_ucfg_nawds(vap, config);
    if (config->cmdtype == IEEE80211_WLANCONFIG_NAWDS_GET) {
        length = sizeof(struct ieee80211_wlanconfig);
        /*
         * Allocate memory size of the data being sent + skb header length + u_32 for FLA + u_32
         * for the length of the data being sent
         */
        ret = cfg80211_reply_command(wiphy, length, config, 0);
    }
    return ret;
}

#ifdef UMAC_SUPPORT_MLNAWDS
/**
 * wlan_cfg80211_mlnawds_params - get mlnawds params
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_mlnawds_params(struct wiphy *wiphy,
                                 struct wireless_dev *wdev,
                                 struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int length, cmd_type;
    void *cmd;
    int ret = 0;

    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (vap == NULL) {
        qdf_err("Vap is NULL!");
        return -EINVAL;
    }

    /* NAWDS configs valid only for Host AP mode */
    if (vap->iv_opmode != IEEE80211_M_HOSTAP) {
        qdf_err("cmd not supported for this mode");
        return -EINVAL;
    }

    ret = ieee80211_ucfg_mlnawds(vap, config);
    if (config->cmdtype == IEEE80211_WLANCONFIG_MLNAWDS_GET) {
        length = sizeof(struct ieee80211_wlanconfig);
        /*
         * Allocate memory size of the data being sent + skb header length + u_32 for FLA + u_32
         * for the length of the data being sent
         */
        ret = cfg80211_reply_command(wiphy, length, config, 0);
    }
    return ret;
}
#endif /* UMAC_SUPPORT_MLNAWDS */

#if MESH_MODE_SUPPORT
#ifdef WLAN_FEATURE_11BE_MLO
/**
 * wlan_cfg80211_mesh_params - get mesh params
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_mesh_params(struct wiphy *wiphy,
                              struct wireless_dev *wdev,
                              struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    int ret = 0;

    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (vap == NULL) {
        qdf_err("Vap is NULL!");
        return -EINVAL;
    }

    /* MESH configs valid only for Host AP mode */
    if (vap->iv_opmode != IEEE80211_M_HOSTAP) {
        qdf_err("cmd not supported for this mode");
        return -EINVAL;
    }

    ret = ieee80211_ucfg_mesh(vap, config);
    return ret;
}
#endif
#endif

/* wlan_cfg80211_get_params - hmwds param
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_get_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct net_device *dev = NULL;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int param = 0, value = 0, return_val = 0, len = 0;
    int char_value[32] = {0};
    int *data = (int*) params->data;
    int  get_param[2] = {0};

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    param = params->value;
    if(data)
    {
        get_param[0] = param;
        get_param[1] = *data;
    }
    if (ic->ic_wdev.netdev == wdev->netdev) {
        dev = wdev->netdev;
        scn = get_radio_device_context(wiphy, dev);
        if (ic->ic_cfg80211_radio_handler.getparam)
            return_val = ic->ic_cfg80211_radio_handler.getparam((void*)scn, param, &value);
        else
            return_val = -EOPNOTSUPP;
        if (return_val == 0) {
            cfg80211_reply_command(wiphy, sizeof(u_int32_t), &value, 0);
        }
    } else {
        dev = wdev->netdev;
        osifp = get_vap_device_context(wiphy, dev, params->link_id);

        if (!osifp) {
            qdf_err("%s: osifp NULL\n", __func__);
            return -EINVAL;
        }
        vap = osifp->os_if;

        /* special case to handle commands that are defined as char types
           which require different reply length based on return value */
        switch(param)
        {
            case IEEE80211_PARAM_DBG_LVL:
            case IEEE80211_PARAM_HE_SUBFEE_STS_SUPRT:
            case IEEE80211_PARAM_UPTIME:
            case IEEE80211_PARAM_MLD_NETDEV_NAME:
                return_val = ieee80211_ucfg_getparam(vap, param, char_value);
                if (return_val == 0) {
                    len = qdf_str_nlen((char *)char_value, sizeof(char_value));
                    cfg80211_reply_command(wiphy, len, char_value, 0);
                }
                break;
            default:
                /* Use get_param[0] for return value and param[1] for sending the
                   set value for commands that send value while get call.
                */
                return_val = ieee80211_ucfg_getparam(vap, param, get_param);
                value=get_param[0];
                if (return_val == 0)
                    cfg80211_reply_command(wiphy, sizeof(u_int32_t), &value, 0);
        }
    }
    qdf_debug("returning %d", return_val);
    return return_val;
}

/* wlan_cfg80211_hmwds_params - hmwds param
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 * Return: 0 on success, negative errno on failure
 */

int wlan_cfg80211_hmwds_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret = 0;
    int cmd_type;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ret = ieee80211_ucfg_hmwds(vap, config, params->data_len);
    if ((config->cmdtype == IEEE80211_WLANCONFIG_HMWDS_READ_TABLE) || (config->cmdtype == IEEE80211_WLANCONFIG_HMWDS_READ_ADDR)) {
        ret = cfg80211_reply_command(wiphy, params->data_len, config, 0);
    }

    return ret;
}

#ifdef IPA_OFFLOAD
/* wlan_cfg80211_ipa_wds_delete_params - Delete wds type ast entry
 * @wiphy:    pointer to wireless wiphy structure.
 * @wdev:     pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_ipa_wds_delete_params(struct wiphy *wiphy,
                                 struct wireless_dev *wdev,
                                 struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret = 0;
    int cmd_type;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ret = ieee80211_ucfg_ipa_wds(vap, config, params->data_len);

    return ret;
}
#endif

/* TODO: Vikram - remove this and use IEEE80211_DRIVER_CAPS get param in application */
/* wlan_cfg80211_list_cap - get driver  capability
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_list_cap(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret;
    int cmd_type;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ret = wlan_get_param(vap, IEEE80211_DRIVER_CAPS);
    ret = cfg80211_reply_command(wiphy, sizeof(u_int8_t), &ret, 0);
    return ret;
}

/* wlan_cfg80211_list_channels - list channel
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
#ifdef WLAN_FEATURE_11BE
int wlan_cfg80211_list_channels(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret;
    int cmd_type;
    void *cmd;
    struct ieee80211req_chaninfo *chanlist = NULL;
    struct ieee80211_channel_list_info *channel = NULL;
    uint32_t length;
    int nchans_max = ((IEEE80211_CHANINFO_MAX - 1) * sizeof(__u32))/
        sizeof(struct ieee80211_channel_params);

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    chanlist = (struct ieee80211req_chaninfo *)qdf_mem_malloc(sizeof(*chanlist));
    if (!chanlist) {
        qdf_err("NULL chanlist");
        return -ENOMEM;
    }

    channel = (struct ieee80211_channel_list_info *)qdf_mem_malloc(sizeof(*channel));
    if (!channel) {
        qdf_err("NULL channel");
        qdf_mem_free(chanlist);
        return -ENOMEM;
    }

    wlan_get_chan_info(vap, chanlist->ic_chans, channel->chans, &channel->nchans);

    if (channel->nchans > nchans_max) {
        channel->nchans = nchans_max;
    }

    length = (sizeof(struct ieee80211_channel_params) * channel->nchans) +
             (sizeof(struct ieee80211_channel_list_info) -
                   (sizeof(struct ieee80211_channel_params) * IEEE80211_CHAN_MAX));

    if ((length <= 0) || (length > sizeof(struct ieee80211_channel_list_info)))
    {
        qdf_err("Size of the channel structure is invalid ");
        ret = -EINVAL;
    } else {
        ret = cfg80211_reply_command(wiphy, length, channel, 0);
    }

    qdf_mem_free(channel);
    qdf_mem_free(chanlist);

    return ret;
}
#endif

int wlan_cfg80211_list_chan(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret;
    int cmd_type;
    void *cmd;
    struct ieee80211req_chaninfo *chanlist = NULL;
    struct ieee80211req_channel_list *channel = NULL;
    uint32_t length;
    int nchans_max = ((IEEE80211_CHANINFO_MAX - 1) * sizeof(__u32))/
        sizeof(struct ieee80211_channel_info);

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    chanlist = (struct ieee80211req_chaninfo *)qdf_mem_malloc(sizeof(*chanlist));
    if (!chanlist) {
        qdf_err("NULL chanlist");
        return -ENOMEM;
    }

    channel = (struct ieee80211req_channel_list *)qdf_mem_malloc(sizeof(*channel));
    if (!channel) {
        qdf_err("NULL channel");
        qdf_mem_free(chanlist);
        return -ENOMEM;
    }

    wlan_get_chaninfo(vap, false, chanlist->ic_chans, channel->chans, &channel->nchans);

    if (channel->nchans > nchans_max) {
        channel->nchans = nchans_max;
    }

    length = (sizeof(struct ieee80211_channel_info) * channel->nchans) +
             (sizeof(struct ieee80211req_channel_list)-
                   (sizeof(struct ieee80211_channel_info) * IEEE80211_CHAN_MAX));

    if ((length <= 0) || (length > sizeof(struct ieee80211req_channel_list)))
    {
        qdf_err("Size of the channel structure is invalid ");
        ret = -EINVAL;
    } else {
        ret = cfg80211_reply_command(wiphy, length, channel, 0);
    }

    qdf_mem_free(channel);
    qdf_mem_free(chanlist);

    return ret;
}

/* wlan_cfg80211_active_chan_list - get active chan list
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_active_chan_list(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret;
    int cmd_type;
    void *cmd;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }
    ret = cfg80211_reply_command(wiphy, sizeof(ic->ic_chan_active_2g_5g), ic->ic_chan_active_2g_5g, 0);

    return ret;
}

/* wlan_cfg80211_list_chan160 - get chan 160 list
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_list_chan160(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    struct net_device *dev = NULL;
    u_int8_t ret;
    void *cmd;
    int cmd_type;
    struct ieee80211req_chaninfo *chanlist = NULL;
    struct ieee80211req_channel_list *channel = NULL;
    uint32_t length;
    int nchans_max = ((IEEE80211_CHANINFO_MAX - 1) * sizeof(__u32))/
        sizeof(struct ieee80211_channel_info);

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    dev = wdev->netdev;

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    chanlist = (struct ieee80211req_chaninfo *)qdf_mem_malloc(sizeof(*chanlist));
    if (!chanlist) {
        qdf_err("NULL chanlist");
        return -ENOMEM;
    }

    channel = (struct ieee80211req_channel_list *)qdf_mem_malloc(sizeof(*channel));
    if (!channel) {
        qdf_err("NULL channel");
        qdf_mem_free(chanlist);
        return -ENOMEM;
    }

    wlan_get_chaninfo(vap, true, chanlist->ic_chans, channel->chans, &channel->nchans);

    if (channel->nchans > nchans_max) {
        channel->nchans = nchans_max;
    }

    length = (sizeof(struct ieee80211_channel_info) * channel->nchans) +
             (sizeof(struct ieee80211req_channel_list)-
                   (sizeof(struct ieee80211_channel_info) * IEEE80211_CHAN_MAX));

    if ((length <= 0) || (length > sizeof(struct ieee80211req_channel_list)))
    {
        qdf_err("Size of the channel structure is invalid ");
        ret = -EINVAL;
    } else {
        ret = cfg80211_reply_command(wiphy, length, channel, 0);
    }

    qdf_mem_free(channel);
    qdf_mem_free(chanlist);

    return ret;
}


/* wlan_cfg80211_wnm_params - wnm param
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_wnm_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int ret;
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ret = ieee80211_ucfg_wnm(vap, config);
    return ret;
}


#if ATH_SUPPORT_DYNAMIC_VENDOR_IE
/* wlan_cfg80211_vendorie_params - vendorie params
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_vendorie_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret;
    u_int8_t *ie_buf;
    u_int32_t ie_len = 0, ftype = 0;
    u_int8_t temp_buf[QDF_MAC_ADDR_SIZE];
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig_vendorie *vie = (struct ieee80211_wlanconfig_vendorie *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ret = ieee80211_ucfg_vendorie(vap, vie);
    if(vie->cmdtype == IEEE80211_WLANCONFIG_VENDOR_IE_LIST) {
        /*
         * List command searches all the frames and returns the IEs matching
         * the given OUI type. A simple list command will return all the IEs
         * whereas a list command followed by the OUI type will return only those
         * IEs matching the OUI. A temp_buf is used to store the OUI type recieved
         * as the iwr.u.data.pointer will be written with IE data to be returned.
         */
        ie_buf = (u_int8_t *)&vie->ie;
        memcpy(temp_buf, ie_buf, 5);
#if ATH_SUPPORT_DYNAMIC_VENDOR_IE
        for (ftype = 0; ftype < IEEE80211_FRAME_TYPE_MAX; ftype++)
        {
            ret = wlan_get_vendorie(vap, vie, ftype, &ie_len, temp_buf);
        }
#endif
        ret = cfg80211_reply_command(wiphy,ie_len + 12, vie, 0);

    }
    return ret;
}
#endif

/* wlan_cfg80211_set_max_rate - set max rate
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_set_maxrate(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;
    struct ieee80211_wlanconfig_setmaxrate *smr = &(config->smr);

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }
    /* Now iterate through the node table */
    wlan_iterate_station_list(vap, ieee80211_ucfg_setmaxrate_per_client, (void *)smr);
    return 0;
}

#if ATH_SUPPORT_NAC_RSSI
/* wlan_cfg80211_nac_rssi_params - set nac param
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_nac_rssi_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret;
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ret = ieee80211_ucfg_nac_rssi(vap, config);
    if (config->cmdtype == IEEE80211_WLANCONFIG_NAC_RSSI_ADDR_LIST) {
        ret = cfg80211_reply_command(wiphy, sizeof(struct ieee80211_wlanconfig), config, 0);
    }
    return ret;
}
#endif

#if QCA_SUPPORT_PEER_ISOLATION
int wlan_cfg80211_peer_isolation_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret;
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_err("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ret = ieee80211_ucfg_isolation(vap, config);
    if ((config->cmdtype == IEEE80211_WLANCONFIG_PEER_ISOLATION_ADDR_LIST) ||
        (config->cmdtype == IEEE80211_WLANCONFIG_PEER_ISOLATION_NUM_CLIENT)) {
        ret = cfg80211_reply_command(wiphy, params->data_len, config, 0);
    }
    return ret;
}
#endif

#if ATH_SUPPORT_NAC
/* wlan_cfg80211_nac_params - set nac param
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_nac_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret;
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (!IEEE80211_IS_SMART_MON_VAP(vap) &&
            !(IEEE80211_IS_SPECIAL_VAP(vap) && vap->iv_ic->ic_mon_mac_filter)) {
        qdf_err("Nac commands not supported in non smart monitor vap!");
        qdf_err("Smart mon:%u Special vap:%u mac_filter:%u",
                IEEE80211_IS_SMART_MON_VAP(vap), IEEE80211_IS_SPECIAL_VAP(vap),
                vap->iv_ic->ic_mon_mac_filter);
        return -EPERM;
    }

    ret = ieee80211_ucfg_nac(vap, config);
    if(config->cmdtype == IEEE80211_WLANCONFIG_NAC_ADDR_LIST) {
        ret = cfg80211_reply_command(wiphy, sizeof(struct ieee80211_wlanconfig), config, 0);
    }
    return ret;
}
#endif

#if QCA_AIRTIME_FAIRNESS
QDF_STATUS
wlan_cfg80211_atf_resp(struct wiphy *wiphy, void *at, int total_len)
{
    int index = 0, len = 0;

    while ((index < total_len)) {
        if ((total_len - index) / MAX_CFG80211_BUF_LEN)
            len = MAX_CFG80211_BUF_LEN;
        else
            len = total_len - index;
        if (cfg80211_reply_command(wiphy, len, ((u_int8_t *)at) + index, 0)) {
            return QDF_STATUS_E_INVAL;
        }
        index += len;
    }

    return QDF_STATUS_SUCCESS;
}

/* wlan_cfg80211_atf_setssid - set atf ssid
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_atf(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    struct atf_subtype *buf = (struct atf_subtype *)params->data;
    struct ssid_val ssidval;
    struct atf_data *atfdata;
    int ret = 0;
    int cmd_type;
    void *cmd;
    struct atftable  *at = 0;
    struct atfgrouptable *at_grp = NULL;
    struct atfgrouplist_table *at_grplist = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    qdf_mem_zero(&ssidval, sizeof(struct ssid_val));
    memcpy(&ssidval, params->data, sizeof(struct ssid_val));
    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }
    if (vap == NULL) {
        qdf_print("Vap is NULL !");
        return -EINVAL;
    }

    switch (buf->id_type) {
        case IEEE80211_IOCTL_ATF_ADDSSID:
            ret = ucfg_atf_set_ssid(vap->vdev_obj, &ssidval);
            break;
        case IEEE80211_IOCTL_ATF_DELSSID:
            ret = ucfg_atf_delete_ssid(vap->vdev_obj, (struct ssid_val *)params->data);
            break;
        case IEEE80211_IOCTL_ATF_ADDSTA:
            ret = ucfg_atf_set_sta(vap->vdev_obj, (struct sta_val *)params->data);
            break;
        case IEEE80211_IOCTL_ATF_DELSTA:
            ret = ucfg_atf_delete_sta(vap->vdev_obj, (struct sta_val *)params->data);
            break;
        case IEEE80211_IOCTL_ATF_SHOWATFTBL:
            atfdata = (struct atf_data  *) params->data;
            at = (struct atftable *)qdf_mem_malloc(sizeof(struct atftable));
            if (!at) {
                atf_err("atf table memory not allocated");
                return -EFAULT;
            }
            qdf_mem_zero(at, sizeof(struct atftable));
            if (copy_from_user(at, (struct atftable *)atfdata->buf,
                               sizeof(struct atftable))) {
                atf_err("atf table could not be copied from user space");
                qdf_mem_free(at);
                return -EFAULT;
            }
            at->id_type = IEEE80211_IOCTL_ATF_SHOWATFTBL;
            ret = ucfg_atf_show_table(vap->vdev_obj, at);
            if (ret) {
                atf_err("atf table could not be fetched");
                qdf_mem_free(at);
                return -EINVAL;
            }
            if (copy_to_user((struct atftable*)atfdata->buf, at,
                             sizeof(struct atftable))) {
                atf_err("atf table could not be copied to user space");
                qdf_mem_free(at);
                return -EFAULT;
            }
            if (wlan_cfg80211_atf_resp(wiphy, at, sizeof(struct atftable)) !=
                                       QDF_STATUS_SUCCESS) {
                atf_err("reply failed for showatftable command");
                qdf_mem_free(at);
                return -EINVAL;
            }
            qdf_mem_free(at);
            break;
        case IEEE80211_IOCTL_ATF_SHOWAIRTIME:
            atfdata = (struct atf_data  *) params->data;
            at = (struct atftable *)qdf_mem_malloc(sizeof(struct atftable));
            if (!at) {
                atf_err("atf table memory not allocated");
                return -EFAULT;
            }
            qdf_mem_zero(at, sizeof(struct atftable));
            ret = ucfg_atf_show_airtime(vap->vdev_obj, at);
            if (ret) {
                atf_err("atf airtime allocation could not be fetched");
                qdf_mem_free(at);
                return -EINVAL;
            }
            if (wlan_cfg80211_atf_resp(wiphy, at, sizeof(struct atftable)) !=
                                       QDF_STATUS_SUCCESS) {
                atf_err("reply failed for showairtime command");
                qdf_mem_free(at);
                return -EINVAL;
            }
            qdf_mem_free(at);
            break;
        case IEEE80211_IOCTL_ATF_FLUSHTABLE:
            ret = ucfg_atf_flush_table(vap->vdev_obj);
            break;
        case IEEE80211_IOCTL_ATF_ADDGROUP:
            ret = ucfg_atf_add_group(vap->vdev_obj, (struct atf_group *)params->data);
            break;
        case IEEE80211_IOCTL_ATF_CONFIGGROUP:
            ret = ucfg_atf_config_group(vap->vdev_obj, (struct atf_group *)params->data);
            break;
        case IEEE80211_IOCTL_ATF_GROUPSCHED:
            ret = ucfg_atf_group_sched(vap->vdev_obj, (struct atf_group *)params->data);
            break;
        case IEEE80211_IOCTL_ATF_DELGROUP:
            ret = ucfg_atf_delete_group(vap->vdev_obj, (struct atf_group *)params->data);
            break;
        case IEEE80211_IOCTL_ATF_SHOWGROUP:
            atfdata = (struct atf_data  *) params->data;
            at_grp = (struct atfgrouptable *)qdf_mem_malloc(sizeof(struct atfgrouptable));
            if (!at_grp) {
                atf_err("atf group table memory not allocated");
                return -EFAULT;
            }
            qdf_mem_zero(at_grp, sizeof(struct atfgrouptable));
            ret = ucfg_atf_show_group(vap->vdev_obj, at_grp);
            if (ret) {
                atf_err("atf group details could not be fetched");
                qdf_mem_free(at_grp);
                return -EINVAL;
            }
            if (wlan_cfg80211_atf_resp(wiphy, at_grp,
                                       sizeof(struct atfgrouptable)) !=
                                       QDF_STATUS_SUCCESS) {
                atf_err("reply failed for showatfgroup command");
                qdf_mem_free(at_grp);
                return -EINVAL;
            }
            qdf_mem_free(at_grp);
            break;
        case IEEE80211_IOCTL_ATF_SHOWSUBGROUP:
            atfdata = (struct atf_data  *) params->data;
            at_grplist = (struct atfgrouplist_table *)qdf_mem_malloc(sizeof(struct atfgrouplist_table));
            if (!at_grplist) {
                atf_err("atf group table memory not allocated");
                return -EFAULT;
            }
            qdf_mem_zero(at_grplist, sizeof(struct atfgrouplist_table));
            at_grplist->id_type = IEEE80211_IOCTL_ATF_SHOWSUBGROUP;
            ret = ucfg_atf_show_subgroup(vap->vdev_obj, at_grplist);
            if (ret) {
                atf_err("atf subgroup details could not be fetched");
                qdf_mem_free(at_grplist);
                return -EINVAL;
            }
            if (wlan_cfg80211_atf_resp(wiphy, at_grplist,
                                       sizeof(struct atfgrouplist_table)) !=
                                       QDF_STATUS_SUCCESS) {
                atf_err("reply failed for showatfsubgroup command");
                qdf_mem_free(at_grplist);
                return -EINVAL;
            }
            qdf_mem_free(at_grplist);
            break;
        case IEEE80211_IOCTL_ATF_ADDAC:
            ret = ucfg_atf_add_ac(vap->vdev_obj, (struct atf_ac *)params->data);
            break;
        case IEEE80211_IOCTL_ATF_DELAC:
            ret = ucfg_atf_del_ac(vap->vdev_obj, (struct atf_ac *)params->data);
            break;
        case IEEE80211_IOCTL_ATF_ADDSTA_TPUT:
            ret = ucfg_atf_add_sta_tput(vap->vdev_obj, (struct sta_val*)params->data);
            break;
        case IEEE80211_IOCTL_ATF_DELSTA_TPUT:
            ret = ucfg_atf_delete_sta_tput(vap->vdev_obj, (struct sta_val*)params->data);
            break;
        case IEEE80211_IOCTL_ATF_SHOW_TPUT:
            ret = ucfg_atf_show_tput(vap->vdev_obj);
            break;
#if QCA_SUPPORT_ATF_STATS
        case IEEE80211_IOCTL_ATF_GET_STATS:
            atfdata = (struct atf_data  *) params->data;
            at = (struct atftable *)qdf_mem_malloc(sizeof(struct atftable));
            if (!at) {
                atf_err("atf table memory not allocated");
                return -EFAULT;
            }
            qdf_mem_zero(at, sizeof(struct atftable));
            at->id_type = IEEE80211_IOCTL_ATF_GET_STATS;
            ret = ucfg_atf_get_stats(vap->vdev_obj, at);
            if (ret) {
                atf_err("atf stats could not be fetched");
                qdf_mem_free(at);
                return -EINVAL;
            }
            if (copy_to_user((struct atftable*)atfdata->buf, at,
                             sizeof(struct atftable))) {
                atf_err("atf table could not be copied to user space");
                qdf_mem_free(at);
                return -EFAULT;
            }
            if (wlan_cfg80211_atf_resp(wiphy, at, sizeof(struct atftable)) !=
                                       QDF_STATUS_SUCCESS) {
                atf_err("reply failed for showatfstats command");
                qdf_mem_free(at);
                return -EINVAL;
            }
            qdf_mem_free(at);
            break;
        case IEEE80211_IOCTL_ATF_GET_AC_STATS:
            atfdata = (struct atf_data  *) params->data;
            at_grplist = (struct atfgrouplist_table *)qdf_mem_malloc(sizeof(struct atfgrouplist_table));
            if (!at_grplist) {
                atf_err("atf group table memory not allocated");
                return -EFAULT;
            }
            qdf_mem_zero(at_grplist, sizeof(struct atfgrouplist_table));
            at_grplist->id_type = IEEE80211_IOCTL_ATF_GET_AC_STATS;
            ret = ucfg_atf_get_ac_stats(vap->vdev_obj, at_grplist);
            if (ret) {
                atf_err("atf subgroup details could not be fetched");
                qdf_mem_free(at_grplist);
                return -EINVAL;
            }
            if (wlan_cfg80211_atf_resp(wiphy, at_grplist,
                                       sizeof(struct atfgrouplist_table)) !=
                                       QDF_STATUS_SUCCESS) {
                atf_err("reply failed for showatfsubgroup command");
                qdf_mem_free(at_grplist);
                return -EINVAL;
            }
            qdf_mem_free(at_grplist);
            break;
#endif /* QCA_SUPPORT_ATF_STATS */
        default:
            break;
    }

    return ret;
}
#endif

/* wlan_cfg80211_list_sta - list sta
 * @wiphy:         Pointer to wireless wiphy structure.
 * @wdev:          Pointer to wireless_dev structure.
 * @params:        Pointer to the data to be passed via vendor interface
 * @query_for_sta: If requested list is for wdev which is sta
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_list_sta(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params, bool query_for_sta)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret = 0;
    int cmd_type;
    struct stainforeq req;
    u_int32_t length = 0;
    void *cmd;
    struct net_device *dev = NULL;
    osif_dev *osifp = NULL;
    sta_info_req_t *ptr = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    dev = wdev->netdev;

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

#ifdef QCA_SUPPORT_WDS_EXTENDED
    if (wdev->iftype == NL80211_IFTYPE_AP_VLAN &&
        wlan_psoc_nif_feat_cap_get(wlan_pdev_get_psoc(ic->ic_pdev_obj),
                                   WLAN_SOC_F_WDS_EXTENDED)) {
        qdf_err("Invalid command for %s", dev->name);
        return -EINVAL;
    }
#endif

    osifp = get_vap_device_context(wiphy, dev, params->link_id);

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if ((params->command != QCA_NL80211_VENDOR_SUBCMD_LIST_PASN_PEER) &&
         osifp->os_opmode == IEEE80211_M_STA && !query_for_sta) {
        return -EPERM;
    }

    ptr = (sta_info_req_t *)params->data;
    req.space = 0;
    req.vap = vap;

    if (params->command == QCA_NL80211_VENDOR_SUBCMD_LIST_PASN_PEER) {
        wlan_iterate_pasn_peer_list(vap, get_sta_space, &req);
    } else {
        wlan_iterate_station_list(vap, get_sta_space, &req);
    }

    if(req.space == 0) {
        if (params->flags == NO_CHUNKS_COPY) {
            ret = copy_to_user(ptr->addr, &length, sizeof(int));
            return ret;
        } else {
            ret = cfg80211_reply_command(wiphy, 0 , NULL, 0);
            return ret;
        }
    }

    if (req.space > 0) {
        void *si_data;
        int space;
        void *send_msg, *msg;
        int send_length = LIST_STATION_CFG_ALLOC_SIZE;
        int len, total_len;
        space = req.space;
        si_data = (void *)qdf_mem_malloc(space);
        if (si_data == NULL) {
            return -ENOMEM;
        }

        req.si = si_data;
        if (params->command == QCA_NL80211_VENDOR_SUBCMD_LIST_PASN_PEER) {
            wlan_iterate_pasn_peer_list(vap, get_sta_info, &req);
        } else {
            wlan_iterate_station_list(vap, get_sta_info, &req);
        }

        length = space - req.space;
        send_msg = si_data;

        if (params->flags == NO_CHUNKS_COPY) {
            if (ptr->len > length)
                ptr->len = length;

            if (copy_to_user(ptr->addr, &length, sizeof(int))) {
                qdf_err ("Unable to copy sta_info blocklen to userspace");
                ret = -EFAULT;
            }

            if (copy_to_user(ptr->info, send_msg, ptr->len)) {
                qdf_err ("Unable to copy sta_info blocks to userspace");
                ret = -EFAULT;
            }

        } else {
            len = 0;
            total_len = 0;
            msg = send_msg;

            while (total_len < length) {
                struct ieee80211req_sta_info *si;
                si = (struct ieee80211req_sta_info *) send_msg;

                if(((len + si->isi_len) < send_length)) {

                    len +=  si->isi_len;
                    total_len += si->isi_len;
                    send_msg += si->isi_len;
                } else {
                    ret = cfg80211_reply_command(wiphy, len, msg, 0);
                    msg = send_msg;
                    len = 0;
                }
            }

            /* Send Remaining data!*/

            if(len != 0) {
                ret = cfg80211_reply_command(wiphy, len, msg, 0);
            }
        }

        qdf_mem_free(si_data);
    }
    return ret;
}

#ifdef WLAN_FEATURE_11BE_MLO
/* wlan_cfg80211_list_link_info - list link info
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_list_link_info(struct wiphy *wiphy,
                                    struct wireless_dev *wdev,
                                    struct wlan_cfg8011_genric_params *params)
{
    uint8_t i = 0;
    struct wlan_objmgr_vdev *wlan_vdev_list[WLAN_UMAC_MLO_MAX_VDEVS] = {NULL};
    struct wlan_objmgr_vdev *vdev = NULL;
    uint16_t vdev_count = 0;
    wlan_if_t vap = NULL;
    struct ieee80211vap *link_vap = NULL;
    u_int8_t total_links = 0;
    struct partner_mlo_info mld_link_info = {0};
    u_int8_t ret = 0;
    struct net_device *vap_dev;
    osif_dev *osifp;
    struct cfg80211_mld_wiphy_priv *mld_wiphy_priv;

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    vap_dev = wdev->netdev;
    if (!is_mld_netdev(vap_dev)) {
        mld_link_info.total_links = total_links;
        mld_link_info.is_mld = 0;
    } else if (params->link_id == INVALID_LINK_ID) {
        mld_wiphy_priv = (struct cfg80211_mld_wiphy_priv *)wiphy_priv(wiphy);
        if (mld_wiphy_priv->mld_netdev == wdev->netdev) {
            qdf_err("Command is on Radio\n");
            cfg80211_reply_command(wiphy, sizeof(mld_link_info), &mld_link_info, 0);
            return 0;
        }

        qdf_debug("Command is on Single Wiphy\n");

        mld_link_info.is_mld = 1;

         /* List of VDEVs(Active) in this MLD*/
	 /* wdev is MLD0 */
	 /* get VAP object from MLD's wdev */
         vap = wlan_cfg80211_get_mld_vap(wdev);

         if (!vap) {
             qdf_info("VAP is NULL\n");
             /* Send buffer to user space */
             cfg80211_reply_command(wiphy, sizeof(mld_link_info), &mld_link_info, 0);
             return 0;
         }

         mlo_get_ml_vdev_list(vap->vdev_obj, &vdev_count, wlan_vdev_list);

         if (!vdev_count) {
             qdf_err("No Link VAPs on MLD\n");
             /* Send buffer to user space */
             cfg80211_reply_command(wiphy, sizeof(mld_link_info), &mld_link_info, 0);
             return 0;
         }

         for (i = 0; i < vdev_count; i++) {
             vdev = wlan_vdev_list[i];
             if (!vdev) {
                 qdf_err("vdev is null\n");
                 continue;
             }

             if (!wlan_vdev_mlme_is_mlo_vdev(vdev)) {
                 qdf_err("Non-MLO vap under MLD is not allowed\n");
                 return -EINVAL;
             }

             link_vap = wlan_vdev_mlme_get_ext_hdl(vdev);
             if (!link_vap) {
                 qdf_err("link_vap is not present\n");
                 /* Release list */
                 ieee80211_mlo_release_vdev_list_refs(wlan_vdev_list,
                                      QDF_ARRAY_SIZE(wlan_vdev_list),
                                      vdev_count, 0);
                 return -EINVAL;
             }

             osifp = (osif_dev *)link_vap->iv_ifp;
             vap_dev = get_cfg80211_notification_ndev(osifp);

             OS_MEMCPY(mld_link_info.link_info[total_links].link_ifname, link_vap->iv_netdev_name, IFNAMSIZ-1);
             OS_MEMCPY(mld_link_info.link_info[total_links].link_addr, link_vap->iv_myaddr, QDF_MAC_ADDR_SIZE);
             mld_link_info.link_info[total_links].link_id = vdev->vdev_mlme.mlo_link_id;
             mld_link_info.link_info[total_links].link_if_index = vap_dev->ifindex;

             if (IS_UP(vap_dev))
                 mld_link_info.link_info[total_links].link_status = 1;
             else
                 mld_link_info.link_info[total_links].link_status = 0;

             total_links++;
         }

         mld_link_info.total_links = total_links;

         /* Release list */
         if (ieee80211_mlo_release_vdev_list_refs(wlan_vdev_list,
                                    QDF_ARRAY_SIZE(wlan_vdev_list),
                                    vdev_count, 0) != QDF_STATUS_SUCCESS) {
             qdf_err("failed to release mlo vdev ref");
         }
    } else {
        mld_link_info.is_mld = 0;
        mld_link_info.total_links = total_links;
    }
#else
    if (!is_mld_phy(wiphy)) {
        mld_link_info.total_links = total_links;
        mld_link_info.is_mld = 0;
    } else {
        mld_wiphy_priv = (struct cfg80211_mld_wiphy_priv *)wiphy_priv(wiphy);
        if (mld_wiphy_priv->mld_netdev == wdev->netdev) {
            qdf_err("Command is on Radio\n");
            cfg80211_reply_command(wiphy, sizeof(mld_link_info), &mld_link_info, 0);
            return 0;
        }

        qdf_debug("Command is on Single Wiphy\n");

        mld_link_info.is_mld = 1;

         /* List of VDEVs(Active) in this MLD*/
         vap = wlan_cfg80211_get_mld_vap(wdev);

         if (!vap) {
             qdf_info("VAP is NULL\n");
             /* Send buffer to user space */
             cfg80211_reply_command(wiphy, sizeof(mld_link_info), &mld_link_info, 0);
             return 0;
         }

         mlo_get_ml_vdev_list(vap->vdev_obj, &vdev_count, wlan_vdev_list);

         if (!vdev_count) {
             qdf_err("No Link VAPs on MLD\n");
             /* Send buffer to user space */
             cfg80211_reply_command(wiphy, sizeof(mld_link_info), &mld_link_info, 0);
             return 0;
         }

         for (i = 0; i < vdev_count; i++) {
             vdev = wlan_vdev_list[i];
             if (!vdev) {
                 qdf_err("vdev is null\n");
                 continue;
             }

             if (!wlan_vdev_mlme_is_mlo_vdev(vdev)) {
                 qdf_err("Non-MLO vap under MLD is not allowed\n");
                 return -EINVAL;
             }

             link_vap = wlan_vdev_mlme_get_ext_hdl(vdev);
             if (!link_vap) {
                 qdf_err("link_vap is not present\n");
                 /* Release list */
                 ieee80211_mlo_release_vdev_list_refs(wlan_vdev_list,
                                      QDF_ARRAY_SIZE(wlan_vdev_list),
                                      vdev_count, 0);
                 return -EINVAL;
             }

             osifp = (osif_dev *)link_vap->iv_ifp;
             vap_dev = osifp->netdev;

             OS_MEMCPY(mld_link_info.link_info[total_links].link_ifname, link_vap->iv_netdev_name, IFNAMSIZ-1);
             OS_MEMCPY(mld_link_info.link_info[total_links].link_addr, link_vap->iv_myaddr, QDF_MAC_ADDR_SIZE);
             mld_link_info.link_info[total_links].link_id = vdev->vdev_mlme.mlo_link_id;
             mld_link_info.link_info[total_links].link_if_index = vap_dev->ifindex;

             if (IS_UP(vap_dev))
                 mld_link_info.link_info[total_links].link_status = 1;
             else
                 mld_link_info.link_info[total_links].link_status = 0;

             total_links++;
         }

         mld_link_info.total_links = total_links;

         /* Release list */
         if (ieee80211_mlo_release_vdev_list_refs(wlan_vdev_list,
                                    QDF_ARRAY_SIZE(wlan_vdev_list),
                                    vdev_count, 0) != QDF_STATUS_SUCCESS) {
             qdf_err("failed to release mlo vdev ref");
         }
    }
#endif
    /* Send buffer to user space */
    cfg80211_reply_command(wiphy, sizeof(mld_link_info), &mld_link_info, 0);

    return ret;
}
#endif

#if QLD
/* wlan_cfg80211_get_qld_dump - copy memory dump to userspace
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_get_qld_dump(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    struct qld_userentry *q_entry = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    uint32_t  u_32_addr, k_32_addr;
    int ret = 0;
    int cmd_type;
    void *cmd;

    if (!params->data) {
        qdf_err("QLD:Cfg Data is NULL !\n");
        return -EINVAL;
    }
    if (!is_qld_enable()) {
        qdf_err("QLD:Feature is disabled return!\n");
        return -EINVAL;
    }

    q_entry = (struct qld_userentry *)params->data;
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_err("Invalid VAP Command !");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    if (!scn || !scn->soc) {
        qdf_err("QLD: scn or soc is NULL\n");
        return -EINVAL;
    }
    qdf_err("QLD: current flag is %u\n",params->flags);
    if (params->flags == QLD_DATA_END_FLAG) {
        qdf_event_set(&scn->soc->qld_wait);
    }

    if (!q_entry->entry.addr) {
        qdf_err("QLD Memory is NULL for given structure");
        return -EFAULT;
    }
    qdf_err("QLD copying to user address %llx size of %d\n", q_entry->u_addr,q_entry->entry.size);
    u_32_addr = q_entry->u_addr;
    k_32_addr = q_entry->entry.addr;
    /* Call appropriate types based on arch type */
#ifdef __LP64__
    ret = (copy_to_user((void *)(q_entry->u_addr), (void *)q_entry->entry.addr, q_entry->entry.size));
#else
    ret = (copy_to_user((void *)u_32_addr, (void *)k_32_addr, q_entry->entry.size));
#endif
    if (ret) {
        qdf_err("QLD table could not be copied to user space");
        return -EFAULT;
    }
    if (cfg80211_reply_command(wiphy, 0,NULL, 0)) {
            return QDF_STATUS_E_INVAL;
    }
    qdf_err("QLD: Data copied to user memory\n !");
    return ret;
 }
#endif

/* wlan_cfg80211_list_scan - list scan
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_list_scan(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    u_int8_t ret = 0;
    struct scanreq req;
    int time_elapsed = OS_SIWSCAN_TIMEOUT;
    u_int32_t length, cmd_type;
    struct net_device *dev = NULL;
    osif_dev *osifp = NULL;
    void *cmd;
    struct wlan_objmgr_pdev *pdev = NULL;

    dev = wdev->netdev;
    osifp = get_vap_device_context(wiphy, dev, params->link_id);
    if (!osifp) {
        qdf_err("%s: osifp NULL\n", __func__);
        return -EINVAL;
    }
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    if (!(dev->flags & IFF_UP)) {
        return -EINVAL;
    }

    pdev = wlan_vap_get_pdev(vap);
    /* Increase timeout value for EIR since a rpt scan itself takes 12 seconds */
    if (wlan_rptr_pdev_is_eir(pdev)) {
        time_elapsed = OS_SIWSCAN_TIMEOUT * SIWSCAN_TIME_ENH_IND_RPT;
    }

    if (osifp->os_opmode != IEEE80211_M_STA ||
            osifp->os_opmode != IEEE80211_M_P2P_DEVICE ||
            osifp->os_opmode != IEEE80211_M_P2P_CLIENT) {
        /* For station mode - umac connection sm always runs SCAN */
        if (wlan_scan_in_progress(vap) &&
                (time_after(osifp->os_last_siwscan + time_elapsed, OS_GET_TICKS())))
        {
            osifp->os_giwscan_count++;
            return -EAGAIN;
        }
    }
    req.space = 0;
    req.vap = vap;

    ucfg_scan_db_iterate(pdev, get_scan_space, (void *) &req);
    if (req.space > 0) {
        size_t space;
        void *sc_data;
        void *send_msg, *msg;
        int send_length = 3*1024;
        int len, total_len;
        space = req.space;
        sc_data = (void *)qdf_mem_malloc(space);
        if (sc_data == NULL) {
            return -ENOMEM;
        }
        req.sr = sc_data;
        ucfg_scan_db_iterate(pdev, get_scan_result,(void *) &req);
        length = space - req.space;
        send_msg = sc_data;
        len = 0;
        total_len = 0;
        msg = send_msg;

        while (total_len < length) {
            struct ieee80211req_scan_result *sr;
            sr = (struct ieee80211req_scan_result *) send_msg;
            if(((len + sr->isr_len) < send_length)) {
                len +=  sr->isr_len;
                total_len += sr->isr_len;
                send_msg += sr->isr_len;
            } else {
                ret = cfg80211_reply_command(wiphy, len, msg, 0);
                msg = send_msg;
                len = 0;
            }

        }
        if(len != 0) {
            ret = cfg80211_reply_command(wiphy, len, msg, 0);
        }

        ret = ieee80211_ucfg_scanlist(vap);

        qdf_mem_free(sc_data);
    }

    return ret;
}

#if ATH_SUPPORT_HYFI_ENHANCEMENTS
/* wlan_cfg80211_me_list_params - list me hmmc/deny list param
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_me_list_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    u_int8_t ret;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    struct ieee80211_wlanconfig *config = (struct ieee80211_wlanconfig *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    ret = ieee80211_ucfg_me_list(vap, config);

    return ret;
}
#endif


extern int wlan_update_vdev_cp_stats(struct ieee80211vap *vap,
                              struct ieee80211_stats *vap_stats_usr,
                              struct ieee80211_mac_stats *ucast_stats_usr,
                              struct ieee80211_mac_stats *mcast_stats_usr);

extern int wlan_update_pdev_cp_stats(struct ieee80211com *ic,
                              struct ol_ath_radiostats *scn_stats_user);
extern int
wlan_get_vdev_dp_stats(struct ieee80211vap *vap,
                       struct ieee80211_stats *vap_stats_usr,
                       struct ieee80211_mac_stats *ucast_stats_usr,
                       struct ieee80211_mac_stats *mcast_stats_usr);
extern int
wlan_get_pdev_dp_stats(struct ieee80211com *ic,
                       struct ol_ath_radiostats *scn_stats_user);

#if UMAC_SUPPORT_STA_STATS
/* wlan_cfg80211_sta_stats - list sta stats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_sta_stats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    u_int8_t error;
    wlan_if_t vap = NULL;
    struct ieee80211_node *ni;
    u_int8_t macaddr[QDF_MAC_ADDR_SIZE];
    int cmd_type;
    void *cmd;
    struct ieee80211req_sta_stats *stats = (struct ieee80211req_sta_stats *)params->data;
    struct ieee80211req_sta_stats *stats_user;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }
    memcpy(macaddr, stats->is_u.macaddr,
            QDF_MAC_ADDR_SIZE);
    stats_user = (struct ieee80211req_sta_stats *)qdf_mem_malloc(sizeof(struct ieee80211req_sta_stats));
    qdf_mem_zero(stats_user, sizeof(struct ieee80211req_sta_stats));
    if (!stats_user)
        return -EINVAL;

    memcpy(stats_user->is_u.macaddr, stats->is_u.macaddr,
            QDF_MAC_ADDR_SIZE);
    ni = ieee80211_vap_find_node(vap, macaddr, WLAN_MLME_SB_ID);

    if (ni == NULL) {
        qdf_mem_free(stats_user);
        return -EINVAL;
    }

#ifdef QCA_SUPPORT_CP_STATS
    if(wlan_update_peer_cp_stats(ni, &stats_user->is_stats) != 0) {
        ieee80211_free_node(ni, WLAN_MLME_SB_ID);
        qdf_mem_free(stats_user);
        return -EFAULT;
    }
#endif
    if (wlan_get_peer_dp_stats(ic,
                               ni->peer_obj,
                               &stats_user->is_stats, NULL, false) != 0) {
        ieee80211_free_node(ni, WLAN_MLME_SB_ID);
        qdf_mem_free(stats_user);
        return -EFAULT;
    }
    stats_user->is_stats.ns_rssi = ni->ni_snr;
    stats_user->is_stats.ns_max_rate = ic->ic_get_maxphyrate(ic, ni);
    error = cfg80211_reply_command(wiphy, sizeof(struct ieee80211req_sta_stats),
                                   stats_user, 0);
    ieee80211_free_node(ni, WLAN_MLME_SB_ID);
    qdf_mem_free(stats_user);
    return error;
}
#endif

/* wlan_cfg80211_80211stats - list 80211 stats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_80211stats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    int error;
    wlan_if_t vap = NULL;
    wlan_if_t val_vap = NULL;
    int cmd_type;
    void *cmd;
    struct ieee80211_stats *stats = NULL;
    struct ieee80211_mac_stats *ucaststats = NULL;
    struct ieee80211_mac_stats *mcaststats = NULL;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (ic == NULL) {
        qdf_print("%s: ic is NULL",__func__);
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
        val_vap = vap;
    }

    if (val_vap == NULL){
        qdf_err("vap is NULL!");
        return -EINVAL;
    }

    if (ic->is_mbssid_enabled) {
        if (IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap)) {
            val_vap = ic->ic_mbss_ctx->ic_mbss[vap->iv_mbss.group_id].transmit_vap;
        }
    }

    if (CONVERT_SYSTEM_TIME_TO_MS(OS_GET_TICKS() - vap->vap_bcn_stats_time) > 2000) {
        qdf_event_reset(&vap->wait_for_bcn_stats);
        if(vap->get_vdev_bcn_stats) {
            vap->get_vdev_bcn_stats(vap, -1UL);
#define BCN_STATS_TIMEOUT 50 /* 50 ms*/
/* give enough delay to get the result */
            qdf_wait_single_event(&vap->wait_for_bcn_stats, BCN_STATS_TIMEOUT);

            if (qdf_atomic_read(&(vap->vap_bcn_event)) != 1) {
                IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL,
                                  "%s: VAP BCN STATS FAILED\n", __func__);
            }
        }
    }

    if(vap->get_vdev_prb_fils_stats) {
        qdf_event_reset(&vap->wait_for_prbfils_stats);
        qdf_atomic_init(&(vap->vap_prb_fils_event));
        vap->get_vdev_prb_fils_stats(vap);
#define PRB_FILS_STATS_TIMEOUT 50 /* 50 ms*/
                /* give enough delay to get the result */
        qdf_wait_single_event(&vap->wait_for_prbfils_stats, PRB_FILS_STATS_TIMEOUT);

        if (qdf_atomic_read(&(vap->vap_prb_fils_event)) != 1) {
            IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL,
                              "%s: VAP PRB and FILS STATS FAILED\n", __func__);
        }
    }

    stats = (struct ieee80211_stats *)qdf_mem_malloc(sizeof(struct ieee80211_stats) +
                               (2*sizeof(struct ieee80211_mac_stats)));
    if (!stats) {
        qdf_print("no memory for stats_user!");
        return -ENOMEM;
    }

    ucaststats = (struct ieee80211_mac_stats*)((unsigned char *)stats +
                                               sizeof(struct ieee80211_stats));
    mcaststats = (struct ieee80211_mac_stats*)((unsigned char *)ucaststats +
                                            sizeof(struct ieee80211_mac_stats));
#ifdef QCA_SUPPORT_CP_STATS
    if (wlan_update_vdev_cp_stats(vap, stats, ucaststats,
                                  mcaststats) != 0) {
        qdf_mem_free(stats);
        return -EFAULT;
    }
#endif
    if (wlan_get_vdev_dp_stats(vap, stats, ucaststats,
                               mcaststats) != 0) {
        qdf_mem_free(stats);
        return -EFAULT;
    }

    error = cfg80211_reply_command(wiphy, sizeof (struct ieee80211_stats) +
            sizeof(struct ieee80211_mac_stats) +
            sizeof(struct ieee80211_mac_stats), stats, 0);

    qdf_mem_free(stats);

    return error;
}

/* Struct used to store and accumulate vap level stats from per peer */
struct wlan_vap_level_stats {
    vaplevel_stats_t *vapstats;
    struct ieee80211com *ic;
    u_int16_t total_per_numrtr;
    u_int16_t total_per_denomntr;
    u_int16_t txrx_rate_denomntr;
    bool firstchild;
};

static void wlan_get_peer_level_stats(void *arg, struct ieee80211_node *ni)
{
    struct ieee80211req_sta_stats *stats;
    const struct ieee80211_nodestats *ns;
    int i;

    struct wlan_vap_level_stats *args_param =
                  (struct wlan_vap_level_stats *)arg;

    if (!ni) {
        return;
    }

    stats = (struct ieee80211req_sta_stats *)qdf_mem_malloc(sizeof(struct ieee80211req_sta_stats));
    if (!stats)
        return;

    qdf_mem_zero(stats, sizeof(struct ieee80211req_sta_stats));

    ns = &(stats->is_stats);

#ifdef QCA_SUPPORT_CP_STATS
    if(wlan_update_peer_cp_stats(ni, &(stats->is_stats)) != 0) {
        qdf_mem_free(stats);
        return;
    }
#endif

    if (wlan_get_peer_dp_stats(args_param->ic, ni->peer_obj,
                               &(stats->is_stats), NULL, false) != 0) {
        qdf_mem_free(stats);
        return;
    }

    args_param->total_per_numrtr += ns->ns_last_per;
    args_param->total_per_denomntr++;
    args_param->txrx_rate_denomntr++;
    args_param->vapstats->txrx_rate_available = 1;

    for (i = 0;i < WME_NUM_AC;i++) {
        args_param->vapstats->excretries[i] +=
            ns->ns_excretries[i];
    }

    args_param->vapstats->rx_mgmt += ns->ns_rx_mgmt;
    args_param->vapstats->tx_mgmt += ns->ns_tx_mgmt;

    if (!(args_param->firstchild))
        args_param->firstchild = 1;
    qdf_mem_free(stats);
}

void wlan_cfg80211_gather_pure_vaplevel_stats(vaplevel_stats_t *vapstats,
          struct ieee80211_stats *stats, bool is_mbssid_enabled,
          struct ieee80211com *ic, struct ieee80211vap *tx_vap, wlan_if_t vap)
{
    struct ieee80211_mac_stats *ucaststats;
    struct ieee80211_mac_stats *mcaststats;
    struct mbssid_context *mbss_ctx;
    struct mbssid_info *ic_mbss;
    int i;

    if (is_mbssid_enabled) {
        if (!ic->ic_mbss_ctx) {
            mbss_err("mbss_ctx is null!!!");
            return;
        }
        mbss_ctx = ic->ic_mbss_ctx;
        ic_mbss  = &mbss_ctx->ic_mbss[vap->iv_mbss.group_id];
    }

    ucaststats = (struct ieee80211_mac_stats*)((unsigned char *)stats +
                                               sizeof(struct ieee80211_stats));
    mcaststats = (struct ieee80211_mac_stats*)((unsigned char *)ucaststats +
                                            sizeof(struct ieee80211_mac_stats));

    vapstats->tx_offer_packets = stats->tx_offer_pkt_cnt;
    vapstats->tx_offer_packets_bytes = stats->tx_offer_pkt_bytes_cnt;
    vapstats->mgmt_tx_fail = stats->mgmt_tx_fail;
    vapstats->tx_data_packets = ucaststats->ims_tx_data_packets +
        mcaststats->ims_tx_data_packets;
    vapstats->tx_data_bytes   = ucaststats->ims_tx_data_bytes +
                                mcaststats->ims_tx_data_bytes;
    vapstats->tx_eapol_packets = ucaststats->ims_tx_eapol_packets;
    vapstats->rx_data_packets = stats->total_rx_packets;
    vapstats->rx_data_bytes   = stats->total_rx_bytes;

    vapstats->tx_datapyld_bytes   = ucaststats->ims_tx_datapyld_bytes +
        mcaststats->ims_tx_datapyld_bytes;
    vapstats->rx_datapyld_bytes   = ucaststats->ims_rx_datapyld_bytes +
        mcaststats->ims_rx_datapyld_bytes;

    for (i = 0;i < WME_NUM_AC; i++) {
        vapstats->tx_data_wme[i] = ucaststats->ims_tx_wme[i] +
            mcaststats->ims_tx_wme[i];
        vapstats->rx_data_wme[i] = ucaststats->ims_rx_wme[i] +
            mcaststats->ims_rx_wme[i];
    }

    vapstats->tx_ucast_data_packets  = ucaststats->ims_tx_data_packets;
    vapstats->rx_ucast_data_packets  = ucaststats->ims_rx_data_packets;
    vapstats->tx_mbcast_data_packets = mcaststats->ims_tx_data_packets;
    vapstats->rx_mbcast_data_packets = mcaststats->ims_rx_data_packets;
    vapstats->tx_bcast_data_packets = mcaststats->ims_tx_bcast_data_packets;
    vapstats->tx_bcast_data_bytes = mcaststats->ims_tx_bcast_data_bytes;
    vapstats->rx_bcast_data_packets = mcaststats->ims_rx_bcast_data_packets;

    vapstats->rx_micerr       = ucaststats->ims_rx_tkipmic +
        ucaststats->ims_rx_ccmpmic +
        ucaststats->ims_rx_wpimic  +
        mcaststats->ims_rx_tkipmic +
        mcaststats->ims_rx_ccmpmic +
        mcaststats->ims_rx_wpimic;

    vapstats->rx_decrypterr   = ucaststats->ims_rx_decryptcrc +
        mcaststats->ims_rx_decryptcrc;
    vapstats->rx_pnerr = ucaststats->ims_rx_pnerr + mcaststats->ims_rx_pnerr;

    /*
     * There are various definitions possible for Rx error count.
     * We use the pre-existing, standard definition for
     * compatibility.
     */
    vapstats->rx_err          = stats->is_rx_tooshort +
        stats->is_rx_decap +
        stats->is_rx_nobuf +
        vapstats->rx_decrypterr +
        vapstats->rx_micerr +
        ucaststats->ims_rx_tkipicv +
        mcaststats->ims_rx_tkipicv +
        ucaststats->ims_rx_wepfail +
        mcaststats->ims_rx_wepfail +
        ucaststats->ims_rx_fcserr +
        mcaststats->ims_rx_fcserr +
        ucaststats->ims_rx_tkipmic +
        mcaststats->ims_rx_tkipmic +
        ucaststats->ims_rx_decryptcrc +
        mcaststats->ims_rx_decryptcrc +
        vapstats->rx_pnerr;

    vapstats->tx_discard      = ucaststats->ims_tx_discard +
        mcaststats->ims_tx_discard+
        stats->is_tx_nobuf;
    vapstats->host_discard    = stats->is_tx_nobuf;
    vapstats->tx_err          = stats->is_tx_not_ok ;
    vapstats->total_num_offchan_tx_mgmt = stats->total_num_offchan_tx_mgmt;
    vapstats->total_num_offchan_tx_data = stats->total_num_offchan_tx_data;
    vapstats->num_offchan_tx_failed = stats->num_offchan_tx_failed;
    vapstats->tx_beacon_swba_cnt = stats->tx_beacon_swba_cnt;
    vapstats->tx_mgmt         = ucaststats->ims_tx_mgmt;
    vapstats->rx_mgmt         = ucaststats->ims_rx_mgmt;
    vapstats->sta_xceed_rlim  = stats->sta_xceed_rlim;
    vapstats->sta_xceed_vlim  = stats->sta_xceed_vlim;
    vapstats->mlme_auth_attempt  = stats->mlme_auth_attempt;
    vapstats->mlme_auth_success  = stats->mlme_auth_success;

    vapstats->authorize_attempt  = stats->authorize_attempt;
    vapstats->authorize_success  = stats->authorize_success;
    vapstats->peer_delete_req    = stats->peer_delete_req;
    vapstats->peer_delete_resp   = stats->peer_delete_resp;
    vapstats->peer_delete_all_req    = stats->peer_delete_all_req;
    vapstats->peer_delete_all_resp   = stats->peer_delete_all_resp;
    vapstats->prob_req_drops  = stats->prob_req_drops;
    vapstats->oob_probe_req_count    = stats->oob_probe_req_count;
    vapstats->oob_probe_resp_count = stats->oob_probe_resp_count;
    vapstats->wc_probe_req_drops    = stats->wc_probe_req_drops;

    if (!is_mbssid_enabled) {
        vapstats->current_pp = 0;
        vapstats->ntx_pfl_rollback_stats = 0;
        vapstats->ie_overflow_stats = 0;
        vapstats->no_act_vaps = ieee80211_get_num_ap_vaps_up(ic);
    } else {
        vapstats->current_pp = ic_mbss->current_pp;
        vapstats->ntx_pfl_rollback_stats = vap->iv_mbss.ntx_pfl_rollback_stats;
        vapstats->ie_overflow_stats = vap->iv_mbss.ie_overflow_stats;
        tx_vap = ic_mbss->transmit_vap;
        vapstats->no_act_vaps = ieee80211_mbssid_get_num_beaconing_ap_vaps_up(ic, vap->iv_mbss.group_id);
    }

#ifdef QCA_SUPPORT_EAPOL_OVER_CONTROL_PORT
    if (ic->enable_eapol_over_nl) {
        vapstats->m1_packet_cnt = vap->iv_m1_packet_cnt;
        vapstats->m2_packet_cnt = vap->iv_m2_packet_cnt;
        vapstats->m3_packet_cnt = vap->iv_m3_packet_cnt;
        vapstats->m4_packet_cnt = vap->iv_m4_packet_cnt;
        vapstats->g1_packet_cnt = vap->iv_g1_packet_cnt;
        vapstats->g2_packet_cnt = vap->iv_g2_packet_cnt;
    }
#endif

    if (tx_vap) {
        vapstats->tx_vap = wlan_vdev_get_id(tx_vap->vdev_obj);
    } else {
        vapstats->tx_vap = NO_TX_VAP;
    }
    vapstats->fils_frames_sent   = stats->fils_frames_sent;
    vapstats->fils_frames_sent_fail   = stats->fils_frames_sent_fail;

#if WLAN_SUPPORT_FILS
    tx_vap = vap;
    if (is_mbssid_enabled) {
        if (IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap)) {
            tx_vap = ic_mbss->transmit_vap;
        }
    }

    if (tx_vap)
        vapstats->fils_enable = wlan_fils_is_enable(tx_vap->vdev_obj);
    else
        vapstats->fils_enable = 0;
#endif

    if (!vap->iv_dpp_vap_mode) {
        vapstats->total_num_offchan_tx_dpp_queued = 0;
        vapstats->total_num_offchan_tx_dpp_completion = 0;
    } else {
        vapstats->total_num_offchan_tx_dpp_queued = vap->num_offchan_tx_dpp_queued;
        vapstats->total_num_offchan_tx_dpp_completion = vap->num_offchan_tx_dpp_completion;
    }

#if UMAC_SUPPORT_CHANUTIL_MEASUREMENT
    vapstats->chan_util_enab  = wlan_get_param(vap, IEEE80211_CHAN_UTIL_ENAB);

    if (vapstats->chan_util_enab) {
        vapstats->chan_util = wlan_get_param(vap, IEEE80211_CHAN_UTIL);
    }
#else
    vapstats->chan_util_enab = 0;
#endif /* UMAC_SUPPORT_CHANUTIL_MEASUREMENT */
    vapstats->u_last_tx_rate  = ucaststats->ims_last_tx_rate;
    vapstats->m_last_tx_rate  = mcaststats->ims_last_tx_rate;
    vapstats->u_last_tx_rate_mcs  = ucaststats->ims_last_tx_rate_mcs;
    vapstats->m_last_tx_rate_mcs  = mcaststats->ims_last_tx_rate_mcs;
    vapstats->retries = ucaststats->ims_retries;
    vapstats->tx_bcn_succ_cnt = stats->tx_bcn_succ_cnt;
    vapstats->tx_bcn_outage_cnt = stats->tx_bcn_outage_cnt;

    vapstats->tx_offload_prb_resp_succ_cnt =
                    stats->tx_offload_prb_resp_succ_cnt;
    vapstats->tx_offload_prb_resp_fail_cnt =
                    stats->tx_offload_prb_resp_fail_cnt;
    vapstats->tx_20TU_prb_resp = stats->tx_20TU_prb_resp;
    vapstats->tx_20TU_prb_interval = stats->tx_20TU_prb_interval;
}

int wlan_cfg80211_gather_vaplevel_stats(vaplevel_stats_t **vapstats,
    struct ieee80211com *ic, wlan_if_t vap, bool sta_vap)
{
    struct ieee80211vap *tx_vap = NULL;
    wlan_if_t val_vap = vap;
    bool is_mbssid_enabled;
    struct ieee80211_stats *stats;
    struct ieee80211_mac_stats *ucaststats;
    struct ieee80211_mac_stats *mcaststats;
    struct wlan_vap_level_stats args_param;

    is_mbssid_enabled = wlan_pdev_nif_feat_cap_get(ic->ic_pdev_obj,
                                                   WLAN_PDEV_F_MBSS_IE_ENABLE);

    if (val_vap == NULL){
        qdf_err("vap is NULL!");
        return -EINVAL;
    }

    if (is_mbssid_enabled) {
        if (IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap)) {
            val_vap = ic->ic_mbss_ctx->ic_mbss[vap->iv_mbss.group_id].transmit_vap;
        }
    }

    qdf_event_reset(&vap->wait_for_bcn_stats);
    if (CONVERT_SYSTEM_TIME_TO_MS(OS_GET_TICKS() - vap->vap_bcn_stats_time) > 2000) {
        if(vap->get_vdev_bcn_stats) {
            vap->get_vdev_bcn_stats(vap, -1UL);
#define BCN_STATS_TIMEOUT 50 /* 50 ms*/
/* give enough delay to get the result */
            qdf_wait_single_event(&vap->wait_for_bcn_stats, BCN_STATS_TIMEOUT);

            if (qdf_atomic_read(&(vap->vap_bcn_event)) != 1) {
                IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL,
                                  "%s: VAP BCN STATS FAILED\n", __func__);
            }
        }
    }

    qdf_event_reset(&vap->wait_for_prbfils_stats);
    if(vap->get_vdev_prb_fils_stats) {
        qdf_atomic_init(&(vap->vap_prb_fils_event));
        vap->get_vdev_prb_fils_stats(vap);
#define PRB_FILS_STATS_TIMEOUT 50 /* 50 ms*/
                /* give enough delay to get the result */
        qdf_wait_single_event(&vap->wait_for_prbfils_stats, PRB_FILS_STATS_TIMEOUT);

        if (qdf_atomic_read(&(vap->vap_prb_fils_event)) != 1) {
            IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL,
                              "%s: VAP PRB and FILS STATS FAILED\n", __func__);
        }
    }

    stats = (struct ieee80211_stats *)qdf_mem_malloc(sizeof(struct ieee80211_stats) +
                               (2*sizeof(struct ieee80211_mac_stats)));
    if (!stats) {
        qdf_print("no memory for stats_user!");
        return -ENOMEM;
    }

    ucaststats = (struct ieee80211_mac_stats*)((unsigned char *)stats +
                                               sizeof(struct ieee80211_stats));
    mcaststats = (struct ieee80211_mac_stats*)((unsigned char *)ucaststats +
                                            sizeof(struct ieee80211_mac_stats));

#ifdef QCA_SUPPORT_CP_STATS
    if (wlan_update_vdev_cp_stats(vap, stats, ucaststats,
                                  mcaststats) != 0) {
        qdf_mem_free(stats);
        return -EFAULT;
    }
#endif

    if (wlan_get_vdev_dp_stats(vap, stats, ucaststats,
                               mcaststats) != 0) {
        qdf_mem_free(stats);
        return -EFAULT;
    }

    /* Update pure vap level stats to vapstats */
    wlan_cfg80211_gather_pure_vaplevel_stats(*vapstats, stats, is_mbssid_enabled, ic, tx_vap, vap);

    /* Free stats as stats are updated to vapstats */
    qdf_mem_free(stats);

    qdf_mem_zero(&args_param, sizeof(args_param));
    args_param.vapstats = *vapstats;
    args_param.ic = ic;

    /*
     * Consider nodes for stats only when vap is AP vap and only
     * take associated stations into consideration i.e skip self
     * and temp nodes
     * If the query is for STA vap, get associated peer i.e. AP stats.
     */
    if (vap->iv_opmode == IEEE80211_M_HOSTAP || sta_vap)
        wlan_iterate_station_list(vap, wlan_get_peer_level_stats,
                                  (void *)&args_param);

    if (args_param.firstchild) {
         (args_param.vapstats)->last_per = (args_param.total_per_numrtr)/(args_param.total_per_denomntr);
    }
    return 0;
}

/* wlan_cfg80211_vap_stats - list vap stats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 * @sta_vap: If query type is for sta vap
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_vap_stats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params, bool sta_vap)
{
    struct ieee80211com *ic;
    wlan_if_t vap;
    int cmd_type;
    void *cmd;
    vaplevel_stats_t *vapstats;
    int error = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (ic == NULL) {
        qdf_print("%s: ic is NULL",__func__);
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        qdf_print("Invalid Radio Command !");
        return -EINVAL;
    } else {
        vap = (wlan_if_t)cmd;
    }

    vapstats = (vaplevel_stats_t *)qdf_mem_malloc(sizeof(vaplevel_stats_t));
    if (!vapstats) {
        qdf_print("Memory allocation for vapstats failed!");
        return -ENOMEM;
    }
    qdf_mem_zero(vapstats, sizeof(vaplevel_stats_t));
    error = wlan_cfg80211_gather_vaplevel_stats(&vapstats, ic, vap, sta_vap);
    if (error) {
        qdf_mem_free(vapstats);
        return error;
    }

    error = cfg80211_reply_command(wiphy, sizeof(vaplevel_stats_t), vapstats, 0);
    qdf_mem_free(vapstats);
    return error;
}

void wlan_cfg80211_gather_pure_radiolevel_stats(radiolevel_stats_t *radiostats, struct ol_ath_radiostats *ol_stats)
{

    radiostats->rx_phyerr = ol_stats->rx_phyerr;
    radiostats->rx_phyerr += ol_stats->phy_err_count;
    radiostats->tx_beacon_frames = ol_stats->tx_beacon;
    radiostats->tx_mgmt_frames = (long unsigned int)ol_stats->tx_mgmt;
    radiostats->rx_mgmt_frames = (long unsigned int)(ol_stats->rx_mgmt + ol_stats->rx_num_mgmt);
    radiostats->rx_mgmt_frames_rssi_drop = (long unsigned int)ol_stats->rx_mgmt_rssi_drop;

    radiostats->rx_rssi = ol_stats->rx_rssi_comb;
    radiostats->rx_crcerr = ol_stats->rx_crcerr;
    radiostats->tx_ctl_frames = ol_stats->rtsgood;
    radiostats->rx_ctl_frames = ol_stats->rx_num_ctl;
    radiostats->chan_nf = ol_stats->chan_nf;
    radiostats->tx_frame_count = ol_stats->tx_frame_count;
    radiostats->rx_frame_count = ol_stats->rx_frame_count;
    radiostats->rx_clear_count = ol_stats->rx_clear_count;
    radiostats->cycle_count = ol_stats->cycle_count;
    radiostats->phy_err_count = ol_stats->phy_err_count;
    radiostats->chan_tx_pwr = ol_stats->chan_tx_pwr;

    radiostats->self_bss_util = ol_stats->self_bss_util;
    radiostats->obss_util     = ol_stats->obss_util;

    radiostats->created_vap = ol_stats->created_vap;
    radiostats->active_vap = ol_stats->active_vap;
    radiostats->rnr_count = ol_stats->rnr_count;
    radiostats->soc_status_6ghz = ol_stats->soc_status_6ghz;
}

/* wlan_cfg80211_radio_stats - list radio stats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_radio_stats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic;
    struct ol_ath_softc_net80211 *scn;
    int cmd_type;
    void *cmd;
    radiolevel_stats_t *radiostats = (radiolevel_stats_t *)params->data;
    uint32_t target_type;
    int32_t target_ol_flag = -1;
    struct ol_ath_radiostats scn_stats;
    int tx_beacon_flag = 0;
    struct ieee80211vap *vap;
    vaplevel_stats_t *vapstats;
    int i;
    int error = 0;
    u_int32_t chan_util_numrtr = 0;
    u_int16_t chan_util_denomntr = 0;
    u_int16_t total_per_numrtr = 0;
    u_int16_t total_per_denomntr = 0;
    u_int64_t tx_rate_numrtr = 0;
    u_int64_t rx_rate_numrtr = 0;
    u_int16_t txrx_rate_denomntr = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print("Invalid VAP Command !");
        return -EINVAL;
    }
    scn = (struct ol_ath_softc_net80211 *)cmd;

#if ATH_PERF_PWR_OFFLOAD
    target_type = ic->ic_get_tgt_type(ic);
    switch (target_type) {
        case TARGET_TYPE_QCA8074:
        case TARGET_TYPE_QCA8074V2:
        case TARGET_TYPE_QCA9574:
        case TARGET_TYPE_QCA6018:
        case TARGET_TYPE_QCA5332:
        case TARGET_TYPE_QCA5018:
        case TARGET_TYPE_QCN9000:
        case TARGET_TYPE_QCN9224:
        case TARGET_TYPE_QCN6122:
        case TARGET_TYPE_QCN9160:
        case TARGET_TYPE_QCN6432:
            target_ol_flag = 2;
        break;
        default:
            target_ol_flag = 1;
    }

    qdf_mem_zero(&scn_stats, sizeof(struct ol_ath_radiostats));
#ifdef QCA_SUPPORT_CP_STATS
    if (wlan_update_pdev_cp_stats(ic, &scn_stats) != 0) {
        qdf_print("Invalid VAP Command !");
        return -EFAULT;
    }
#endif
    if (wlan_get_pdev_dp_stats(ic, &scn_stats) != 0) {
        qdf_print("Invalid VAP Command !");
        return -EFAULT;
    }

    radiostats = (radiolevel_stats_t *)qdf_mem_malloc(sizeof(radiolevel_stats_t));
    if (!radiostats) {
        qdf_print("Memory allocation for radiostats failed!");
        return -ENOMEM;
    }
    qdf_mem_zero(radiostats, sizeof(radiolevel_stats_t));

    /* UMAC_SUPPORT_PERIODIC_PERFSTATS not defined */
    radiostats->thrput_enab = 0;
    radiostats->prdic_per_enab = 0;

    wlan_cfg80211_gather_pure_radiolevel_stats(radiostats, &scn_stats);

    if (target_ol_flag == 1)
        radiostats->total_per = ic->ic_get_tx_hw_retries(ic);
    if (radiostats->tx_beacon_frames == 0)
        tx_beacon_flag = 1;

    vapstats = (vaplevel_stats_t *)qdf_mem_malloc(sizeof(vaplevel_stats_t));
    if (!vapstats) {
        qdf_mem_free(radiostats);
        qdf_print("Memory allocation for vapstats failed!");
        return -ENOMEM;
    }

    TAILQ_FOREACH(vap, &ic->ic_vaps, iv_next) {
        qdf_mem_zero(vapstats, sizeof(vaplevel_stats_t));

        error = wlan_cfg80211_gather_vaplevel_stats(&vapstats, ic, vap, false);
        if (error) {
            qdf_mem_free(vapstats);
            qdf_mem_free(radiostats);
            return error;
        }
        radiostats->is_mbssid_enabled = ic->is_mbssid_enabled;

        if (ic->is_mbssid_enabled && ic->ic_mbss_ctx) {
            uint8_t grp_id = vap->iv_mbss.group_id;
            if (vap == ic->ic_mbss_ctx->ic_mbss[grp_id].transmit_vap) {
                radiostats->n_groups = ic->ic_mbss_ctx->max_ngroups;
                radiostats->current_pp[grp_id] = vapstats->current_pp;
                radiostats->no_act_vaps[grp_id] = vapstats->no_act_vaps;
                radiostats->tx_vap[grp_id] = vapstats->tx_vap;
                if (tx_beacon_flag == 1) {
                    radiostats->tx_beacon_frames += vapstats->tx_bcn_succ_cnt;
                    radiostats->tx_beacon_frames += vapstats->tx_bcn_outage_cnt;
                }
            }
        } else {
                radiostats->no_act_vaps[vap->iv_mbss.group_id] = vapstats->no_act_vaps;
                if (tx_beacon_flag == 1) {
                    radiostats->tx_beacon_frames += vapstats->tx_bcn_succ_cnt;
                    radiostats->tx_beacon_frames += vapstats->tx_bcn_outage_cnt;
                }
        }
        radiostats->tx_data_packets += vapstats->tx_data_packets;
        radiostats->tx_data_bytes   += vapstats->tx_data_bytes;
        radiostats->rx_data_packets += vapstats->rx_data_packets;
        radiostats->rx_data_bytes   += vapstats->rx_data_bytes;
        radiostats->rx_mgmt_frames  += vapstats->rx_mgmt;
        radiostats->tx_mgmt_frames  += vapstats->tx_mgmt;

        radiostats->tx_ucast_data_packets  +=
            vapstats->tx_ucast_data_packets;
        radiostats->tx_mbcast_data_packets +=
            vapstats->tx_mbcast_data_packets;

        for (i = 0;i < WME_NUM_AC; i++) {
            radiostats->tx_data_wme[i] += vapstats->tx_data_wme[i];
            radiostats->rx_data_wme[i] += vapstats->rx_data_wme[i];
        }

        radiostats->rx_micerr       += vapstats->rx_micerr;
        radiostats->rx_decrypterr   += vapstats->rx_decrypterr;
        radiostats->rx_pnerr        += vapstats->rx_pnerr;
        radiostats->rx_err          += vapstats->rx_err;

        radiostats->tx_discard      += vapstats->tx_discard;
        radiostats->tx_err          += vapstats->tx_err;


        radiostats->chan_util_enab   |= vapstats->chan_util_enab;

        if (vapstats->chan_util_enab) {
            chan_util_numrtr            += vapstats->chan_util;
            chan_util_denomntr++;
        }

        if (vapstats->txrx_rate_available) {
            radiostats->txrx_rate_available = 1;
            txrx_rate_denomntr++;
            tx_rate_numrtr += vapstats->tx_rate;
            rx_rate_numrtr += vapstats->rx_rate;
        }
        total_per_numrtr += vapstats->last_per;
        total_per_denomntr++;

        radiostats->sta_xceed_rlim += vapstats->sta_xceed_rlim;
        radiostats->sta_xceed_vlim += vapstats->sta_xceed_vlim;
        radiostats->mlme_auth_attempt += vapstats->mlme_auth_attempt;
        radiostats->mlme_auth_success += vapstats->mlme_auth_success;
        radiostats->authorize_attempt += vapstats->authorize_attempt;
        radiostats->authorize_success += vapstats->authorize_success;
    }
    /* Restore total_per_denomntr in tx_rate to calculate tx_rate in usr spc */
    radiostats->tx_rate = txrx_rate_denomntr;

    /* Take the average of channel utilization values across VAPs */
    if (radiostats->chan_util_enab)
        radiostats->chan_util = chan_util_numrtr/chan_util_denomntr;

    error = cfg80211_reply_command(wiphy, sizeof(radiolevel_stats_t), radiostats, 0);
    qdf_mem_free(vapstats);
    qdf_mem_free(radiostats);
#endif
    return error;
}

#if WLAN_SUPPORT_TELEMETRY
static void extract_telemetric_data(struct nlattr **attr,
                                    struct stats_config *cfg,
                                    uint8_t *mac)
{
    uint8_t telemetric_info = 0;

    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_LEVEL]) {
        cfg->lvl = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_LEVEL]);
    }
    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_OBJECT]) {
        cfg->obj = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_OBJECT]);
    }
    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_TYPE]) {
        cfg->type = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_TYPE]);
    }
    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_INFO]) {
        telemetric_info = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_INFO]);
        if (telemetric_info & STATS_INFO_AGGREGATE)
            cfg->aggregate = true;
        if (telemetric_info & STATS_INFO_ASYNC_REQ)
            cfg->async_req = true;
        if (telemetric_info & STATS_INFO_RESOLVE_STA)
            cfg->resolve_sta = true;
        if (telemetric_info & STATS_INFO_MLD_REQ)
            cfg->mld_req = true;
    }
    if (cfg->async_req && attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_REQUEST_ID]) {
        cfg->request_id = nla_get_u64(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_REQUEST_ID]);
    }
    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_FEATURE_FLAG]) {
        cfg->feat = nla_get_u64(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_FEATURE_FLAG]);
    }
    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_STA_MAC] &&
        (nla_len(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_STA_MAC]) == QDF_MAC_ADDR_SIZE)) {
        qdf_mem_copy(mac, nla_data(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_STA_MAC]), QDF_MAC_ADDR_SIZE);
    }
    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_SERVICEID]) {
        cfg->serviceid = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_SERVICEID]);
    }
    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MLD_LINK]) {
        cfg->mld_link = nla_get_flag(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MLD_LINK]);
    }
    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_PEER_TYPE]) {
       cfg->peer_type = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_PEER_TYPE]);
    }
    if (attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_LINK_ID]) {
        cfg->link_id = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_LINK_ID]);
    } else {
        cfg->link_id = INVALID_LINK_ID;
    }
}

static QDF_STATUS
setup_stats_buffer(struct sk_buff *reply_skb, struct stats_config *cfg,
                   enum stats_object_e obj_type, char *if_name, char *p_if_name,
                   struct unified_stats *stats, struct multi_reply_ctx *mr_ctx)
{
    struct nlattr *attr = NULL;
    bool multi_reply = false;
    uint8_t inx;
    uint32_t total = 0;
    bool break_now = false;
    size_t attr_data_len;
    void *attr_data;

    if (nla_put_u8(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_LEVEL, cfg->lvl)) {
        qdf_err("Unable to put Stats level");
        return QDF_STATUS_E_FAILURE;
    }
    if (nla_put_u8(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_OBJECT, obj_type)) {
        qdf_err("Unable to put Object %d", obj_type);
        return QDF_STATUS_E_FAILURE;
    }
    if (!cfg->mld_req && cfg->link_id != INVALID_LINK_ID &&
        nla_put_u8(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_LINK_ID, cfg->link_id)) {
        qdf_err("Unable to put link_id %d", cfg->link_id);
        return QDF_STATUS_E_FAILURE;
    }
    if (obj_type == STATS_OBJ_STA) {
        if (nla_put(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_OBJ_ID, QDF_MAC_ADDR_SIZE,
            if_name)) {
            qdf_err("Unable to put STA MAC %s", if_name);
            return QDF_STATUS_E_FAILURE;
        }
        if(nla_put_u8(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_SERVICEID,
            cfg->serviceid)) {
            qdf_err("Unable to put Serviceid");
            return QDF_STATUS_E_FAILURE;
        }
    } else {
        if (nla_put_string(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_OBJ_ID, if_name)) {
            qdf_err("Unable to put Object Interface %s", if_name);
            return QDF_STATUS_E_FAILURE;
        }
    }
    if (cfg->async_req &&
        wlan_nla_put_u64(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_REQUEST_ID,
                         cfg->request_id)) {
        qdf_err("Unable to put Request ID for Async Response");
        return QDF_STATUS_E_FAILURE;
    }
    if (!cfg->mld_req && p_if_name &&
        nla_put_string(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_PARENT_IF, p_if_name)) {
        qdf_err("Unable to put Parent Object Interface %s", p_if_name);
        return QDF_STATUS_E_FAILURE;
    }
    if (nla_put_u8(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_TYPE, cfg->type)) {
        qdf_err("Unable to put stats type");
        return QDF_STATUS_E_FAILURE;
    }
    attr = nla_nest_start(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_RECURSIVE);
    if (!attr) {
        qdf_err("Unable to start Nested attribute for peers!");
        return QDF_STATUS_E_FAILURE;
    }
    if (mr_ctx->pending) {
        mr_ctx->pending = false;
        multi_reply = true;
    }
    for (inx = mr_ctx->start_inx; inx < INX_FEAT_MAX; inx++) {
        if (!stats->feat[inx] || !stats->size[inx])
            continue;

        if (!cfg->async_req && ((stats->size[inx] > MAX_CFG80211_BUF_LEN) ||
            ((total + stats->size[inx]) > MAX_CFG80211_BUF_LEN))) {
            attr_data_len = MAX_CFG80211_BUF_LEN - total;
            stats->size[inx] -= attr_data_len;
            attr_data = (uint8_t *)stats->feat[inx] + mr_ctx->next_copy_from;
            mr_ctx->next_copy_from += attr_data_len;
            mr_ctx->start_inx = inx;
            mr_ctx->pending = true;
            break_now = true;
        } else {
            attr_data_len = stats->size[inx];
            attr_data = (uint8_t *)stats->feat[inx] + mr_ctx->next_copy_from;
            mr_ctx->next_copy_from = 0;
        }

        total += attr_data_len;
        if (nla_put(reply_skb, GET_ATTR(inx), attr_data_len, attr_data)) {
            qdf_err("Unable to put attr %d", GET_ATTR(inx));
            return QDF_STATUS_E_FAILURE;
        }

        if (break_now)
            break;
    }

    nla_nest_end(reply_skb, attr);

    if (multi_reply &&
        nla_put_flag(reply_skb, QCA_WLAN_VENDOR_ATTR_STATS_MULTI_REPLY)) {
        qdf_err("Unable to put multi reply flag");
        return QDF_STATUS_E_FAILURE;
    }

    return QDF_STATUS_SUCCESS;
}

static int
wlan_cfg80211_calculate_stats_response_size(struct unified_stats *stats)
{
    uint32_t total_len = 0;
    uint8_t tlv_count = 0;

    total_len = wlan_stats_get_tlv_counts_and_total_length(stats, &tlv_count);
    tlv_count += QCA_WLAN_VENDOR_ATTR_STATS_MAX;

    total_len += NLMSG_HDRLEN + (tlv_count * sizeof(uint32_t));

    return total_len;
}

static QDF_STATUS wlan_stats_response(struct stats_config *cfg,
                                      struct unified_stats *stats,
                                      enum stats_object_e obj_type,
                                      char *if_name, char *p_if_name)
{
    struct multi_reply_ctx mr_ctx;
    struct sk_buff *reply_skb = NULL;
    QDF_STATUS status = QDF_STATUS_SUCCESS;

    qdf_mem_zero(&mr_ctx, sizeof(struct multi_reply_ctx));
    do {
        reply_skb = wlan_cfg80211_vendor_cmd_alloc_reply_skb(cfg->wiphy,
                                                             MAX_CFG80211_BUF_LEN);
        if (!reply_skb) {
            qdf_err("Unable to Allocate!");
            status = QDF_STATUS_E_NOMEM;
            goto nla_put_failed;
        }

        status = setup_stats_buffer(reply_skb, cfg, obj_type, if_name,
                                    p_if_name, stats, &mr_ctx);
        if (status != QDF_STATUS_SUCCESS)
            goto nla_put_failed;

        status = wlan_cfg80211_qal_devcfg_send_response((qdf_nbuf_t)reply_skb);
        if (status != QDF_STATUS_SUCCESS) {
            qdf_err("cannot send reply for obj %d!", obj_type);
            goto nla_resp_failed;
        }

    } while (mr_ctx.pending);

nla_put_failed:
    if ((status != QDF_STATUS_SUCCESS) && reply_skb) {
        qdf_err("cannot setup reply for %s!", if_name);
        wlan_cfg80211_vendor_free_skb(reply_skb);
    }

nla_resp_failed:
    return status;
}

static QDF_STATUS wlan_stats_event(struct ieee80211com *ic,
                                   struct stats_config *cfg,
                                   struct unified_stats *stats,
                                   enum stats_object_e obj_type,
                                   char *if_name, char *p_if_name)
{
    struct multi_reply_ctx mr_ctx;
    struct sk_buff *reply_skb = NULL;
    QDF_STATUS status = QDF_STATUS_SUCCESS;
    uint32_t stats_len;
    struct net_device *dev;

    if (!ic) {
        qdf_err("Invalid ic!");
        return QDF_STATUS_E_INVAL;
    }

    dev = ic->ic_netdev;
    stats_len = wlan_cfg80211_calculate_stats_response_size(stats);
    reply_skb = wlan_cfg80211_vendor_event_alloc(cfg->wiphy,
                                                 dev->ieee80211_ptr,
                                                 stats_len,
                                                 QCA_NL80211_VENDOR_SUBCMD_TELEMETRY_STATS_INDEX,
                                                 GFP_ATOMIC);
    qdf_mem_zero(&mr_ctx, sizeof(struct multi_reply_ctx));

    if (!reply_skb) {
        qdf_err("Unable to Allocate!");
        status = QDF_STATUS_E_NOMEM;
        goto nla_put_failed;
    }

    status = setup_stats_buffer(reply_skb, cfg, obj_type, if_name,
                                p_if_name, stats, &mr_ctx);
    if (status != QDF_STATUS_SUCCESS)
        goto nla_put_failed;

    wlan_cfg80211_vendor_event(reply_skb, GFP_ATOMIC);

nla_put_failed:
    if ((status != QDF_STATUS_SUCCESS) && reply_skb) {
        qdf_err("cannot setup reply for %s!", if_name);
        wlan_cfg80211_vendor_free_skb(reply_skb);
    }

    return status;
}

static QDF_STATUS stats_peer_setup(struct wlan_objmgr_vdev *vdev,
                                   uint8_t *mac, struct stats_config *cfg)
{
    struct ieee80211vap *vap = NULL;
    struct unified_stats stats;
    QDF_STATUS status = QDF_STATUS_SUCCESS;

    if (!vdev || !cfg || !mac) {
        qdf_err("Invalid Input!");
        return QDF_STATUS_E_INVAL;
    }
    vap = wlan_vdev_get_mlme_ext_obj(vdev);
    if (!vap) {
        qdf_err("Invalid Vap!");
        return QDF_STATUS_E_INVAL;
    }

    qdf_mem_zero(&stats, sizeof(struct unified_stats));

    if (wlan_stats_get_peer_stats(vdev, mac, cfg, &stats)) {
        qdf_err("Unable to get peer stats!");
        status = QDF_STATUS_E_FAILURE;
        goto peer_get_stats_failed;
    }

    if (cfg->async_req)
        status = wlan_stats_event(vap->iv_ic, cfg, &stats, STATS_OBJ_STA,
                                  mac, vap->iv_netdev_name);
    else
        status = wlan_stats_response(cfg, &stats, STATS_OBJ_STA, mac,
                                     vap->iv_netdev_name);

peer_get_stats_failed:
    wlan_stats_free_unified_stats(&stats);

    return status;
}

static void get_pdev_if_name(struct wlan_objmgr_pdev *pdev, char *if_name)
{
    struct ol_ath_softc_net80211 *scn = NULL;
    struct pdev_osif_priv *osif_priv = NULL;
    struct ieee80211com * ic = NULL;

    if (!pdev)
        return;

    osif_priv = wlan_pdev_get_ospriv(pdev);
    if (!osif_priv) {
        qdf_err("Unable to get pdev ospriv object");
        return;
    }
    scn = (struct ol_ath_softc_net80211 *)osif_priv->legacy_osif_priv;
    if (!scn) {
        qdf_err("Unable to get scn object");
        return;
    }
    ic = &scn->sc_ic;
    snprintf(if_name, RADIO_IF_LEN, "wifi%d", ic->interface_id);
}

static QDF_STATUS stats_vdev_setup(struct wlan_objmgr_vdev *vdev,
                                   struct stats_config *cfg)
{
    struct wlan_objmgr_psoc *psoc = NULL;
    struct ieee80211vap *vap = NULL;
    struct unified_stats stats;
    char p_if_name[RADIO_IF_LEN] = {0};
    QDF_STATUS status = QDF_STATUS_SUCCESS;

    if (!vdev || !cfg) {
        qdf_err("Invalid Input!");
        return QDF_STATUS_E_INVAL;
    }

    psoc = wlan_vdev_get_psoc(vdev);
    if (!psoc) {
        qdf_err("Invalid Psoc");
        return QDF_STATUS_E_INVAL;
    }
    vap = wlan_vdev_get_mlme_ext_obj(vdev);
    if (!vap) {
        qdf_err("Invalid Vap!");
        return QDF_STATUS_E_INVAL;
    }

    qdf_mem_zero(&stats, sizeof(struct unified_stats));

    if (wlan_stats_get_vdev_stats(psoc, vdev, cfg, &stats)) {
        qdf_err("Unable to get vdev stats!");
        status = QDF_STATUS_E_FAILURE;
        goto vdev_get_stats_failed;
    }

    get_pdev_if_name(wlan_vdev_get_pdev(vdev), p_if_name);

    if (cfg->async_req)
        status = wlan_stats_event(vap->iv_ic, cfg, &stats, STATS_OBJ_VAP,
                                  cfg->intf_name, p_if_name);
    else
        status = wlan_stats_response(cfg, &stats, STATS_OBJ_VAP,
                                     cfg->intf_name, p_if_name);

vdev_get_stats_failed:
    wlan_stats_free_unified_stats(&stats);

    return status;
}

static QDF_STATUS stats_pdev_setup(struct wlan_objmgr_pdev *pdev,
                                   struct stats_config *cfg)
{
    struct wlan_objmgr_psoc *psoc = NULL;
    struct unified_stats stats;
    char if_name[RADIO_IF_LEN] = {0};
    char p_if_name[SOC_IF_LEN] = {0};
    QDF_STATUS status = QDF_STATUS_SUCCESS;
    struct ieee80211com *ic = NULL;

    if (!pdev || !cfg) {
        qdf_err("Invalid Input!");
        return QDF_STATUS_E_INVAL;
    }

    psoc = wlan_pdev_get_psoc(pdev);
    if (!psoc) {
        qdf_err("Invalid Psoc!");
        return QDF_STATUS_E_INVAL;
    }

    qdf_mem_zero(&stats, sizeof(struct unified_stats));

    if (wlan_stats_get_pdev_stats(psoc, pdev, cfg, &stats)) {
        qdf_err("Unable to get pdev stats!");
        status = QDF_STATUS_E_FAILURE;
        goto pdev_get_stats_failed;
    }
    get_pdev_if_name(pdev, if_name);
    snprintf(p_if_name, SOC_IF_LEN, "soc%d", wlan_psoc_get_id(psoc));

    if (cfg->async_req) {
        ic = wlan_pdev_get_mlme_ext_obj(pdev);
        status = wlan_stats_event(ic, cfg, &stats, STATS_OBJ_RADIO,
                                  cfg->intf_name, p_if_name);
    } else {
        status = wlan_stats_response(cfg, &stats, STATS_OBJ_RADIO, if_name,
                                     p_if_name);
    }

pdev_get_stats_failed:
    wlan_stats_free_unified_stats(&stats);

    return status;
}

static QDF_STATUS stats_psoc_setup(struct wlan_objmgr_pdev *pdev,
                                   struct stats_config *cfg)
{
    struct unified_stats stats;
    char if_name[SOC_IF_LEN] = {0};
    QDF_STATUS status = QDF_STATUS_SUCCESS;
    struct ieee80211com *ic = NULL;
    struct wlan_objmgr_psoc *psoc = wlan_pdev_get_psoc(pdev);

    if (!psoc || !cfg) {
        qdf_err("Invalid Input!");
        return QDF_STATUS_E_INVAL;
    }

    qdf_mem_zero(&stats, sizeof(struct unified_stats));
    if (wlan_stats_get_psoc_stats(psoc, cfg, &stats)) {
        qdf_err("Unable to get psoc stats!");
        status = QDF_STATUS_E_FAILURE;
        goto psoc_get_stats_failed;
    }
    snprintf(if_name, SOC_IF_LEN, "soc%d", wlan_psoc_get_id(psoc));
    if (cfg->async_req) {
        ic = wlan_pdev_get_mlme_ext_obj(pdev);
        status = wlan_stats_event(ic, cfg, &stats, STATS_OBJ_AP,
                                  cfg->intf_name, NULL);
    } else {
        status = wlan_stats_response(cfg, &stats, STATS_OBJ_AP, if_name, NULL);
    }

psoc_get_stats_failed:
    wlan_stats_free_unified_stats(&stats);

    return status;
}

static QDF_STATUS async_telemetric_reply_setup(struct wlan_objmgr_pdev *pdev,
                                               struct wlan_objmgr_vdev *vdev,
                                               struct stats_config *cfg,
                                               uint8_t *mac)
{
    if (!pdev) {
        qdf_err("Invalid pdev!");
        return QDF_STATUS_E_INVAL;
    }

    return wlan_stats_schedule_nb_stats_work(pdev, vdev, cfg, mac);
}

QDF_STATUS telemetric_reply_setup(struct wlan_objmgr_pdev *pdev,
                                  struct wlan_objmgr_vdev *vdev,
                                  struct stats_config *cfg,
                                  uint8_t *mac)
{
    QDF_STATUS status = QDF_STATUS_SUCCESS;

    if (!pdev) {
        qdf_err("Invalid pdev!");
        return QDF_STATUS_E_INVAL;
    }

    switch (cfg->obj) {
    case STATS_OBJ_STA:
        status = stats_peer_setup(vdev, mac, cfg);
        break;
    case STATS_OBJ_VAP:
        status = stats_vdev_setup(vdev, cfg);
        break;
    case STATS_OBJ_RADIO:
        status = stats_pdev_setup(pdev, cfg);
        break;
    case STATS_OBJ_AP:
        status = stats_psoc_setup(pdev, cfg);
        break;
    default:
        qdf_err("Invalid object input!");
        status = QDF_STATUS_E_FAILURE;
    }

    return status;
}

static int wlan_cfg80211_telemetric_reply(struct wiphy *wiphy,
                                          struct wireless_dev *wdev,
                                          struct nlattr **attr)
{
    struct stats_config cfg;
    struct ieee80211com *ic = NULL;
    struct wlan_objmgr_vdev *vdev = NULL;
    struct wlan_objmgr_psoc *psoc = NULL;
    wlan_if_t vap = NULL;
    void *cmd = NULL;
    uint8_t mac[QDF_MAC_ADDR_SIZE] = {0};
    int cmd_type = 0;
    int ret = 0;
    QDF_STATUS status = QDF_STATUS_SUCCESS;
    char intf_name[IFNAMSIZ] = {0};
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    osif_dev *osifp = NULL;
#endif

    qdf_mem_zero(&cfg, sizeof(struct stats_config));
    cfg.wiphy = wiphy;
    extract_telemetric_data(attr, &cfg, mac);

    if (!is_mld_phy(wiphy)) {
/** To check linkid **/
        ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
        if (!ic) {
            qdf_err("Invalid ic!");
            return -EINVAL;
        }
        cmd = extract_command(ic, wdev, &cmd_type, 0);

        if (!cmd) {
            qdf_err("%s: cmd is NULL\n", __func__);
            return -EINVAL;
        }

        if (!cmd_type) {
            vap = (wlan_if_t)cmd;
            vdev = vap->vdev_obj;
            strlcpy(intf_name, vap->iv_netdev_name, IFNAMSIZ);
        }
    }
#if defined(CONFIG_MLO_SINGLE_DEV) && !defined(ENABLE_CFG80211_BACKPORTS_MLO)
    else {
        uint8_t i,j;
        struct osif_mldev *mldev;
        osif_dev *link_osifp = NULL;

        mldev = osif_mld_get_mldev(wdev->netdev);
        if (!mldev)
            return -EINVAL;

        for (i = 0; i < MAX_MLO_CHIPS; i++) {
            for(j = 0; j < MAX_PDEV_PER_SOC; j++) {
                link_osifp = mldev->link_dev[i][j];
                if (link_osifp) {
                    ic = link_osifp->os_if->iv_ic;
                    vdev = link_osifp->os_if->vdev_obj;
                    break;
                }
            }
        }
        cfg.mld_req = true;
        strlcpy(intf_name, mldev->mld_dev->name, IFNAMSIZ);
    }
#elif defined(ENABLE_CFG80211_BACKPORTS_MLO)
    else {
        ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, cfg.link_id);
        if (!ic) {
            qdf_err("Invalid ic!");
            return -EINVAL;
        }

        cmd = extract_command(ic, wdev, &cmd_type, cfg.link_id);
        if (!cmd) {
            qdf_err("cmd is NULL");
            return -EINVAL;
        }

        if (!cmd_type) {
            osifp = get_vap_device_context(wiphy, wdev->netdev, cfg.link_id);
            if (!osifp) {
                qdf_err("osifp is NULL");
                return -EINVAL;
            }
            vap = osifp->os_if;
            if (!vap) {
                qdf_err("VAP is null");
                return -EINVAL;
            }
            vdev = vap->vdev_obj;
            strlcpy(intf_name, vap->iv_netdev_name, IFNAMSIZ);
        }
    }
#endif

    if (!ic || !ic->ic_pdev_obj) {
        qdf_err("Invalid ic or pdev!");
        return -EINVAL;
    }
    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if (!psoc) {
        qdf_err("Invalid psoc!");
        return -EINVAL;
    }
    if (!ic->ic_is_target_lithium(psoc)) {
        qdf_err("Feature Not supported!");
        return -EINVAL;
    }
    strlcpy(cfg.intf_name, intf_name, IFNAMSIZ);

    /* STA resolution didn't happen on user space */
    if ((cfg.obj == STATS_OBJ_STA) && (cfg.resolve_sta)) {
        vdev = wlan_stats_get_vdev_from_sta_mac(mac);
        if (!vdev) {
            qdf_err("Unable to find connected peer %pM", mac);
            return -EINVAL;
        }

        vap = wlan_vdev_get_mlme_ext_obj(vdev);
        if (vap && cfg.link_id != INVALID_LINK_ID)
            cfg.link_id = vap->link_id;
    }

    if (cfg.async_req)
        status = async_telemetric_reply_setup(ic->ic_pdev_obj, vdev, &cfg, mac);
    else
        status = telemetric_reply_setup(ic->ic_pdev_obj, vdev, &cfg, mac);

    if (QDF_STATUS_SUCCESS != status)
        qdf_err("Unable to setup reply!");
    ret = qdf_status_to_os_return(status);

    return ret;
}

static int wlan_cfg80211_get_telemetric_data(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MAX + 1] = {0};
    int ret = 0;

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MAX,
                                data, data_len, telemetric_req_policy)) {
        qdf_err("Failed Parsing request!");
        return -EINVAL;
    }

    ret = wlan_cfg80211_telemetric_reply(wiphy, wdev, attr);

    return ret;
}
#endif /* WLAN_SUPPORT_TELEMETRY */

#ifdef WLAN_FEATURE_11BE_MLO
static int wlan_cfg80211_mlo_link_remove_cmd(struct wiphy *wiphy,
                                             struct wireless_dev *wdev,
                                             const void *data,
                                             int data_len)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_REMOVAL_MAX + 1] = {0};
    uint32_t delete_tbtt = 0;
    osif_dev *osifp = NULL;
    wlan_if_t vap = NULL;
    QDF_STATUS status;

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_MLO_LINK_REMOVAL_MAX,
                                data, data_len, reconfig_req_policy)) {
        qdf_err("Failed Parsing request!");
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_REMOVAL_TBTT]) {
        delete_tbtt =
            nla_get_u32(attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_REMOVAL_TBTT]);
    }

    qdf_info("delete_tbtt value = %d\n", delete_tbtt);

    osifp = get_vap_device_context(wiphy, wdev->netdev, 0);

    if (!osifp) {
        qdf_err("%s: osifp NULL\n", __func__);
        return -EINVAL;
    }

    vap = osifp->os_if;
    if (!vap) {
        qdf_err("%s: VAP is null ", __func__);
        return -EINVAL;
    }

    status = ieee80211_ucfg_validate_mlo_link_removal_request(vap, delete_tbtt);
    if (QDF_IS_STATUS_SUCCESS(status))
        status = ieee80211_ucfg_process_mlo_link_removal_cmd(vap, delete_tbtt);
    else
        qdf_err("%s: Vap removal validation failed!\n", __func__);

    return qdf_status_to_os_return(status);
}
#endif

static int wlan_cfg80211_reconfig_btmreq(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_MAX + 1] = {0};
    /*
     * Send broadcast if mac address is not specified by user-space
     */
    uint8_t macaddr[QDF_MAC_ADDR_SIZE] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    struct ieee80211_bstm_reqinfo bstmreq = {0};
    void *cmd = NULL;

    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type = 0;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
    if (!ic || !ic->ic_pdev_obj) {
        qdf_err("Invalid ic or pdev!");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, 0);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        vap = (wlan_if_t)cmd;
    }
    if (vap == NULL) {
        qdf_err("ERROR! VAP is null\n");
        return 0;
    }

    bstmreq.dialogtoken = 1; /* Hard-code to 1 */
    bstmreq.disassoc = 1;
    bstmreq.bssterm_inc = 1;
    bstmreq.candidate_list =  0;
#ifdef WLAN_FEATURE_11BE_MLO
    bstmreq.link_remove = 1;
#endif

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_MAX,
                data, data_len, reconfig_btmreq_policy)) {
        qdf_err("Failed Parsing request!");
        return -EINVAL;
    }


    if (attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_MAC] &&
            (nla_len(attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_MAC]) == QDF_MAC_ADDR_SIZE)) {
        qdf_mem_copy(macaddr, nla_data(attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_MAC]), QDF_MAC_ADDR_SIZE);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_DISASSOC]) {
        bstmreq.disassoc_timer = nla_get_u16(attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_DISASSOC]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_BSSTERM]) {
        bstmreq.bssterm_tsf = nla_get_u64(attr[QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_BSSTERM]);
    }

    qdf_info("BTM Request vendor command on %s with values Disassoc=%d "
            "BSSTERM=%016llx\n", vap->iv_netdev_name, bstmreq.disassoc_timer,
            bstmreq.bssterm_tsf);
    return wlan_send_bstmreq(vap, macaddr, &bstmreq);
}

/*
    Receiving clone params before vap creation and
    storing it in a lined list in ic structure.
    During vap creation, this values will be used.
*/
int wlan_cfg80211_cloneparams(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int cmd_type = 0;
    void *cmd = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct net_device *dev = NULL;
    struct ieee80211_clone_params *cp = (struct ieee80211_clone_params *)params->data;
    struct ieee80211_clone_params_list *clone_list;
    struct ieee80211_clone_params_list *cp_entry;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        dev = wdev->netdev;
        scn =  (struct ol_ath_softc_net80211 *)cmd;
    } else {
        qdf_print("Invalid VAP Command !");
        return -EINVAL;
    }

    if (scn->soc->sc_in_delete) {
        qdf_print("Delete in Progress ! Command cannot be applied!");
        return -EBUSY;
    }
    LIST_FOREACH(cp_entry, &ic->ic_cp, link_entry)
    {
        if(!(OS_MEMCMP(cp->icp_name, cp_entry->cp.icp_name, IFNAMSIZ-1)))
        {
            return -1;
        }
    }
    clone_list = (struct ieee80211_clone_params_list *)
    qdf_mem_malloc(sizeof(struct ieee80211_clone_params_list));
    if (!clone_list){
        qdf_print("%s: Returning as mem malloc failed.",__func__);
        return -EINVAL;
    }
    qdf_mem_copy(&clone_list->cp, cp, sizeof(struct ieee80211_clone_params));
    LIST_INSERT_HEAD(&ic->ic_cp, clone_list, link_entry);
    return 0;
}

/* wlan_cfg80211_extendedstats - list extended stats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_extendedstats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    u_int8_t error;
    int cmd_type;
    void *cmd;
    int reply = 0;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct net_device *dev = NULL;
    struct extended_ioctl_wrapper *extended_cmd = ( struct extended_ioctl_wrapper *)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type) {
        dev = wdev->netdev;
        scn =  (struct ol_ath_softc_net80211 *)cmd;
    } else {
        qdf_print("Invalid VAP Command !");
        return -EINVAL;
    }

    reply = ic->ic_cfg80211_radio_handler.extended_commands(dev, (void*) extended_cmd);

    if(reply == 1) {
        error = cfg80211_reply_command(wiphy, sizeof(struct extended_ioctl_wrapper), extended_cmd, 0);
    }
    return 0;
}

/* wlan_cfg80211_athstats - athstats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_athstats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    struct ieee80211com *ic = NULL;
    u_int8_t ret = 0;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    struct sk_buff *reply_skb = NULL;
    struct ath_stats_container *asc = (struct ath_stats_container *)params->data;
    QDF_STATUS status;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print("Invalid VAP Command !");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
    }

    ic->ic_cfg80211_radio_handler.get_ath_stats(scn, asc);

    /* Allocate memory size of the data being sent + skb header length + u_32 for FLA + u_32
     * for the length of the data being sent
     */
    reply_skb = wlan_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, (2*sizeof(u_int32_t)) + NLMSG_HDRLEN);

    if (reply_skb) {
        if((nla_put_u32(reply_skb, QCA_WLAN_VENDOR_ATTR_PARAM_FLAGS, asc->offload_if))){
            wlan_cfg80211_vendor_free_skb(reply_skb);
            return -EINVAL;
        }
        status = wlan_cfg80211_qal_devcfg_send_response((qdf_nbuf_t)reply_skb);
        return qdf_status_to_os_return(status);
    } else {
        return -ENOMEM;
    }

    return ret;
}

/* wlan_cfg80211_phystats - phy stats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_phystats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    int cmd_type;
    void *cmd;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct ol_ath_radiostats scn_stats;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (!cmd_type) {
        qdf_print("Invalid VAP Command !");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;
        qdf_mem_zero(&scn_stats, sizeof(struct ol_ath_radiostats));

#ifdef QCA_SUPPORT_CP_STATS
        if (wlan_update_pdev_cp_stats(ic, &scn_stats) != 0) {
            qdf_print("Invalid VAP Command !");
            return -EFAULT;
        }
#endif
        if (wlan_get_pdev_dp_stats(ic, &scn_stats) != 0) {
            qdf_print("Invalid VAP Command !");
            return -EFAULT;
        }
    }
    return cfg80211_reply_command(wiphy, sizeof(struct ol_ath_radiostats), &scn_stats, 0);
}

/* wlan_cfg80211_httstats - htt stats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_httstats(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    struct ol_ath_softc_net80211 *scn = NULL;
    int cmd_type;
    void *cmd;
    void * req = (void*)params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);

    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type != RADIO_CMD) {
        qdf_print("Invalid VAP Command !");
        return -EINVAL;
    } else {
        scn = (struct ol_ath_softc_net80211 *)cmd;

        if(ic->ic_cfg80211_radio_handler.get_dp_htt_stats) {
            ic->ic_cfg80211_radio_handler.get_dp_htt_stats((void*)scn, req, params->data_len);
        } else  {
            return -EOPNOTSUPP;
        }
    }

    return 0;
}
/* wlan_cfg80211_ald_params - ald stats
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_ald_params(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        struct wlan_cfg8011_genric_params *params)

{
    return 0;
}

/* free the clone arams list on radio detach */
void wlan_cfg80211_free_clone_params_list(struct ieee80211com *ic)
{
    struct ieee80211_clone_params_list *cp_entry, *next_entry;
    LIST_FOREACH_SAFE(cp_entry, &ic->ic_cp, link_entry, next_entry)
    {
        LIST_REMOVE(cp_entry,link_entry);
        qdf_mem_free(cp_entry);
    }
}

/**
 * wlan_cfg80211_register_spectral_cmd_handler() - Registration api
 * for spectral to register vendor command handlers
 * @pdev:    Pointer to pdev
 * @handlers: Spectral vendor command handlers table
 *
 * Return: nothing
 */
void wlan_cfg80211_register_spectral_cmd_handler(struct wlan_objmgr_pdev *pdev,
                                                 struct spectral_cfg80211_vendor_cmd_handlers *handlers) {
    struct ol_ath_softc_net80211 *scn = NULL;
    struct pdev_osif_priv *osif_priv = NULL;
    struct ieee80211com * ic = NULL;

    osif_priv = wlan_pdev_get_ospriv(pdev);
    scn = (struct ol_ath_softc_net80211 *)osif_priv->legacy_osif_priv;
    ic = &scn->sc_ic;

    ic->ic_cfg80211_spectral_handlers = *handlers;
}
qdf_export_symbol(wlan_cfg80211_register_spectral_cmd_handler);

/**
 * wlan_cfg80211_spectral_scan_config_and_start_cb() - Handles spectral scan start command
 * @wiphy: Pointer to wireless phy
 * @wdev: Pointer to wireless device
 * @data: Pointer to data
 * @data_len: Length of @data
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_spectral_scan_config_and_start_cb(struct wiphy *wiphy,
                        struct wireless_dev *wdev,
                        const void *data,
                        int data_len)
{
    struct wlan_objmgr_pdev *pdev;
    struct ieee80211com *ic;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;

    if (ic->ic_cfg80211_spectral_handlers.wlan_cfg80211_spectral_scan_start)
        return ic->ic_cfg80211_spectral_handlers.
               wlan_cfg80211_spectral_scan_start(wiphy, pdev, NULL, data, data_len);
    else {
        QDF_TRACE_INFO(QDF_MODULE_ID_SPECTRAL, "Spectral is disabled");
        return -EPERM;
    }
}

/**
 * wlan_cfg80211_spectral_scan_stop_cb() - Handles spectral scan stop command
 * @wiphy: Pointer to wireless phy
 * @wdev: Pointer to wireless device
 * @data: Pointer to data
 * @data_len: Length of @data
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_spectral_scan_stop_cb(struct wiphy *wiphy,
                        struct wireless_dev *wdev,
                        const void *data,
                        int data_len)

{
    struct wlan_objmgr_pdev *pdev;
    struct ieee80211com *ic;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;

    if (ic->ic_cfg80211_spectral_handlers.wlan_cfg80211_spectral_scan_stop)
        return ic->ic_cfg80211_spectral_handlers.
	       wlan_cfg80211_spectral_scan_stop(wiphy, pdev, NULL, data, data_len);
    else {
	QDF_TRACE_INFO(QDF_MODULE_ID_SPECTRAL, "Spectral is disabled");
        return -EPERM;
    }
}

/**
 * wlan_cfg80211_spectral_scan_stop_cb() - Handles spectral get config command
 * @wiphy: Pointer to wireless phy
 * @wdev: Pointer to wireless device
 * @data: Pointer to data
 * @data_len: Length of @data
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_spectral_scan_get_config_cb(struct wiphy *wiphy,
                        struct wireless_dev *wdev,
                        const void *data, int data_len)
{
    struct wlan_objmgr_pdev *pdev;
    struct ieee80211com *ic;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;

    if (ic->ic_cfg80211_spectral_handlers.wlan_cfg80211_spectral_scan_get_config)
        return ic->ic_cfg80211_spectral_handlers.
	       wlan_cfg80211_spectral_scan_get_config(wiphy, pdev, NULL, data, data_len);
    else {
	QDF_TRACE_INFO(QDF_MODULE_ID_SPECTRAL, "Spectral is disabled");
        return -EPERM;
    }
}

/**
 * wlan_cfg80211_spectral_scan_get_diag_stats_cb() - Handles spectral get diag stats command
 * @wiphy: Pointer to wireless phy
 * @wdev: Pointer to wireless device
 * @data: Pointer to data
 * @data_len: Length of @data
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_spectral_scan_get_diag_stats_cb(struct wiphy *wiphy,
                        struct wireless_dev *wdev,
                        const void *data,
                        int data_len)
{
    struct wlan_objmgr_pdev *pdev;
    struct ieee80211com *ic;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;

    if (ic->ic_cfg80211_spectral_handlers.wlan_cfg80211_spectral_scan_get_diag_stats)
        return ic->ic_cfg80211_spectral_handlers.
	       wlan_cfg80211_spectral_scan_get_diag_stats(wiphy, pdev, NULL, data, data_len);
    else {
	QDF_TRACE_INFO(QDF_MODULE_ID_SPECTRAL, "Spectral is disabled");
        return -EPERM;
    }
}

/**
 * wlan_cfg80211_spectral_scan_get_cap_cb() - Handles spectral get cap command
 * @wiphy: Pointer to wireless phy
 * @wdev: Pointer to wireless device
 * @data: Pointer to data
 * @data_len: Length of @data
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_spectral_scan_get_cap_cb(struct wiphy *wiphy,
                        struct wireless_dev *wdev,
                        const void *data,
                        int data_len)
{
    struct wlan_objmgr_pdev *pdev;
    struct ieee80211com *ic;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;

    if (ic->ic_cfg80211_spectral_handlers.wlan_cfg80211_spectral_scan_get_cap)
        return ic->ic_cfg80211_spectral_handlers.
	       wlan_cfg80211_spectral_scan_get_cap(wiphy, pdev, NULL, data, data_len);
    else {
	QDF_TRACE_INFO(QDF_MODULE_ID_SPECTRAL, "Spectral is disabled");
        return -EPERM;
    }
}

/**
 * wlan_cfg80211_spectral_scan_get_status_cb() - Handles spectral get status command
 * @wiphy: Pointer to wireless phy
 * @wdev: Pointer to wireless device
 * @data: Pointer to data
 * @data_len: Length of @data
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_spectral_scan_get_status_cb(struct wiphy *wiphy,
                        struct wireless_dev *wdev,
                        const void *data,
                        int data_len)
{
    struct wlan_objmgr_pdev *pdev;
    struct ieee80211com *ic;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;

    if (ic->ic_cfg80211_spectral_handlers.wlan_cfg80211_spectral_scan_get_status)
        return ic->ic_cfg80211_spectral_handlers.
	       wlan_cfg80211_spectral_scan_get_status(wiphy, pdev, NULL, data, data_len);
    else {
	QDF_TRACE_INFO(QDF_MODULE_ID_SPECTRAL, "Spectral is disabled");
        return -EPERM;
    }
}

void wlan_cfg80211_wifi_fwstats_event(struct ieee80211com *ic,
        void *buffer, uint32_t buffer_len)
{
    struct sk_buff *vendor_event;
    const uint32_t NUM_TLVS = 10;
    struct net_device *dev = ic->ic_netdev;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
    int ret_val;
#endif

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    if (!osif_scn_event_filter_status_to_app(ic, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_WIFI_FW_STATS_INDEX)) {
        return;
     }
    vendor_event =
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, NULL,
#else
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy,
                                                    dev->ieee80211_ptr,
#endif
                          buffer_len + NLMSG_HDRLEN + NUM_TLVS*sizeof(uint32_t),
                          QCA_NL80211_VENDOR_SUBCMD_WIFI_FW_STATS_INDEX,
                          GFP_ATOMIC);

    if (!vendor_event) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "cfg80211_vendor_event_alloc failed\n");
        return;
    }
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);

    /* Send the IF INDEX to differentiate the ACS event for each interface
     * TODO: To be update once cfg80211 APIs are updated to accept if_index
     */
    ret_val = nla_put_u32(vendor_event,
            NL80211_ATTR_IFINDEX,
            dev->ifindex);
    if (ret_val) {
        qdf_print("NL80211_ATTR_IFINDEX put fail");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);

    if(nla == NULL){
        qdf_print("nla_nest_start fail nla is NULL ");
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }

    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);
#endif
    if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_CONFIG_GENERIC_DATA,
                buffer_len, buffer)) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "%s:%d nla put fail", __func__, __LINE__);
        wlan_cfg80211_vendor_free_skb(vendor_event);
        return;
    }
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(vendor_event, nla);
#endif

    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);
}
qdf_export_symbol(wlan_cfg80211_wifi_fwstats_event);

void wlan_cfg80211_hmwds_ast_add_status_event(struct ieee80211com *ic,
                                              void *buffer,
                                              uint32_t buffer_len)
{
    struct ieee80211_hmwds_ast_add_status *dbg_event;
    struct cdp_peer_hmwds_ast_add_status *status_event;
    struct wlan_objmgr_psoc *psoc;
    struct wlan_objmgr_vdev *vdev;
    wlan_if_t vap;
    osif_dev *osifp;

    if (!ic) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                  FL("ic is NULL"));
        return;
    }

    if (!buffer) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                  FL("hmwds ast add stats event buff is NULL"));
        return;
    }

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    status_event = (struct cdp_peer_hmwds_ast_add_status *)buffer;

    vdev = wlan_objmgr_get_vdev_by_id_from_psoc(psoc, status_event->vdev_id,
                                                WLAN_MISC_ID);
    if (!vdev) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                  FL("vdev object NULL"));
        return;
    }

    vap = wlan_vdev_get_mlme_ext_obj(vdev);
    if (!vap) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                  FL("vap object NULL"));
        wlan_objmgr_vdev_release_ref(vdev, WLAN_MISC_ID);
        return;
    }

    osifp = (osif_dev *)vap->iv_ifp;

    dbg_event = qdf_mem_malloc_atomic(sizeof(struct ieee80211_hmwds_ast_add_status));
    if (!dbg_event) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                  FL("failed to allocate dbg event buff"));
        wlan_objmgr_vdev_release_ref(vdev, WLAN_MISC_ID);
        return;
    }

    dbg_event->cmd = IEEE80211_DBGREQ_HMWDS_AST_ADD_STATUS;
    qdf_mem_copy(dbg_event->peer_mac, status_event->peer_mac,
                 IEEE80211_ADDR_LEN);
    qdf_mem_copy(dbg_event->ast_mac, status_event->ast_mac,
                 IEEE80211_ADDR_LEN);
    dbg_event->status = qdf_status_to_os_return(status_event->status);
    if (vap->iv_cfg80211_create) {
        wlan_cfg80211_generic_event(vap->iv_ic,
                                    QCA_NL80211_VENDOR_SUBCMD_DBGREQ,
                                    dbg_event, sizeof(*dbg_event),
                                    get_cfg80211_notification_ndev(osifp), GFP_ATOMIC);
    }

    qdf_mem_free(dbg_event);
    wlan_objmgr_vdev_release_ref(vdev, WLAN_MISC_ID);
}
qdf_export_symbol(wlan_cfg80211_hmwds_ast_add_status_event);

#ifdef WLAN_FEATURE_11BE

static int get_t2lm_app_genric_evt_data_len(void)
{
    uint32_t len = NLMSG_HDRLEN + NLA_HDRLEN;
    len += nla_total_size(sizeof(struct soc_level_info)) +
            nla_total_size(sizeof(struct peer_generic_assoc_event));
    len += T2LM_EVENT_BUFFER;
    return len;
}

static int get_peer_t2lm_event_data_len(void)
{
    int len = NLMSG_HDRLEN + NLA_HDRLEN;
    len += nla_total_size(sizeof(struct peer_t2lm_policy_event));
    len += T2LM_EVENT_BUFFER;

    return len;
}

enum wlan_t2lm_direction
convert_t2lm_direction_nl80211_to_internal(enum qca_wlan_vendor_t2lm_direction direction)
{
    enum wlan_t2lm_direction internal_dir = WLAN_T2LM_INVALID_DIRECTION;

    switch (direction) {
        case QCA_WLAN_VENDOR_T2LM_DOWNLINK_DIRECTION:
            internal_dir = WLAN_T2LM_DL_DIRECTION;
            break;
        case QCA_WLAN_VENDOR_T2LM_UPLINK_DIRECTION:
            internal_dir = WLAN_T2LM_UL_DIRECTION;
            break;
        case QCA_WLAN_VENDOR_T2LM_BIDI_DIRECTION:
            internal_dir = WLAN_T2LM_BIDI_DIRECTION;
            break;
        default:
            t2lm_debug("invalid direction from app: %d", direction);
            break;
    }

    return internal_dir;
}

enum qca_wlan_vendor_t2lm_direction
convert_t2lm_direction_internal_to_nl80211(enum wlan_t2lm_direction direction)
{
    enum qca_wlan_vendor_t2lm_direction nl80211_dir = QCA_WLAN_VENDOR_T2LM_INVALID_DIRECTION;

    switch (direction) {
        case WLAN_T2LM_DL_DIRECTION:
            nl80211_dir = QCA_WLAN_VENDOR_T2LM_DOWNLINK_DIRECTION;
            break;
        case WLAN_T2LM_UL_DIRECTION:
            nl80211_dir = QCA_WLAN_VENDOR_T2LM_UPLINK_DIRECTION;
            break;
        case WLAN_T2LM_BIDI_DIRECTION:
            nl80211_dir = QCA_WLAN_VENDOR_T2LM_BIDI_DIRECTION;
            break;
        default:
            t2lm_debug("invalid direction: %d", direction);
            nl80211_dir = QCA_WLAN_VENDOR_T2LM_INVALID_DIRECTION;
            break;
    }

    return nl80211_dir;
}

enum t2lm_resp_frm_type
convert_t2lm_resp_frm_type_nl80211_to_internal(
        enum qca_wlan_vendor_t2lm_response_frame_type frm_type)
{
    enum t2lm_resp_frm_type internal_frm_type = T2LM_RESP_TYPE_INVALID;

    switch (frm_type) {
        case QCA_WLAN_VENDOR_T2LM_RESP_FRAME_STATUS_SUCCESS:
            internal_frm_type = T2LM_RESP_TYPE_SUCCESS;
            break;
        case QCA_WLAN_VENDOR_T2LM_RESP_FRAME_STATUS_DENIED_TID_TO_LINK_MAPPING:
            internal_frm_type = T2LM_RESP_TYPE_DENIED_TID_TO_LINK_MAPPING;
            break;
        case QCA_WLAN_VENDOR_T2LM_RESP_FRAME_STATUS_PREFERRED_TID_TO_LINK_MAPPING:
            internal_frm_type = T2LM_RESP_TYPE_PREFERRED_TID_TO_LINK_MAPPING;
            break;
        default:
            t2lm_debug("invalid frame type: %d", frm_type);
            break;
    }

    return internal_frm_type;
}

enum qca_wlan_vendor_t2lm_response_frame_type
convert_t2lm_resp_frm_type_internal_to_nl80211(enum t2lm_resp_frm_type frm_type)
{
    enum qca_wlan_vendor_t2lm_response_frame_type nl80211_frm_type = QCA_WLAN_VENDOR_T2LM_RESP_FRAME_STATUS_INVALID;
    switch (frm_type) {
        case T2LM_RESP_TYPE_SUCCESS:
            nl80211_frm_type = QCA_WLAN_VENDOR_T2LM_RESP_FRAME_STATUS_SUCCESS;
            break;
        case T2LM_RESP_TYPE_DENIED_TID_TO_LINK_MAPPING:
            nl80211_frm_type = QCA_WLAN_VENDOR_T2LM_RESP_FRAME_STATUS_DENIED_TID_TO_LINK_MAPPING;
            break;
        case T2LM_RESP_TYPE_PREFERRED_TID_TO_LINK_MAPPING:
            nl80211_frm_type = QCA_WLAN_VENDOR_T2LM_RESP_FRAME_STATUS_PREFERRED_TID_TO_LINK_MAPPING;
            break;
        default:
            t2lm_debug("invalid frame type: %d", frm_type);
            break;
    }

    return nl80211_frm_type;
}

enum wlan_t2lm_tx_status
convert_t2lm_tx_status_nl80211_to_internal(
        enum qca_wlan_vendor_t2lm_tx_status tx_status)
{
    enum wlan_t2lm_tx_status internal_tx_status = QCA_WLAN_VENDOR_T2LM_TX_STATUS_INVALID;

    switch (tx_status) {
        case QCA_WLAN_VENDOR_T2LM_TX_STATUS_NONE:
            internal_tx_status = WLAN_T2LM_TX_STATUS_NONE;
            break;
        case QCA_WLAN_VENDOR_T2LM_TX_STATUS_SUCCESS:
            internal_tx_status = WLAN_T2LM_TX_STATUS_SUCCESS;
            break;
        case QCA_WLAN_VENDOR_T2LM_TX_STATUS_FAILURE:
            internal_tx_status = WLAN_T2LM_TX_STATUS_FAILURE;
            break;
        case QCA_WLAN_VENDOR_T2LM_TX_STATUS_RX_TIMEOUT:
            internal_tx_status = WLAN_T2LM_TX_STATUS_RX_TIMEOUT;
            break;
        default:
            t2lm_debug("invalid tx status: %d", tx_status);
            break;
    }

    return internal_tx_status;
}

enum qca_wlan_vendor_t2lm_tx_status
convert_t2lm_tx_status_internal_to_nl80211(enum wlan_t2lm_tx_status tx_status)
{
     enum qca_wlan_vendor_t2lm_tx_status nl80211_tx_status = QCA_WLAN_VENDOR_T2LM_TX_STATUS_INVALID;

    switch (tx_status) {
        case WLAN_T2LM_TX_STATUS_NONE:
            nl80211_tx_status = QCA_WLAN_VENDOR_T2LM_TX_STATUS_NONE;
            break;
        case WLAN_T2LM_TX_STATUS_SUCCESS:
            nl80211_tx_status = QCA_WLAN_VENDOR_T2LM_TX_STATUS_SUCCESS;
            break;
        case WLAN_T2LM_TX_STATUS_FAILURE:
            nl80211_tx_status = QCA_WLAN_VENDOR_T2LM_TX_STATUS_FAILURE;
            break;
        case WLAN_T2LM_TX_STATUS_RX_TIMEOUT:
            nl80211_tx_status = QCA_WLAN_VENDOR_T2LM_TX_STATUS_RX_TIMEOUT;
            break;
        default:
            t2lm_debug("invalid tx status: %d", tx_status);
            break;
    }

    return nl80211_tx_status;
}


enum wlan_t2lm_category
convert_t2lm_category_nl80211_to_internal(enum qca_wlan_vendor_t2lm_category category)
{
    enum wlan_t2lm_category internal_category = WLAN_T2LM_CATEGORY_NONE;

    switch(category) {
        case QCA_WLAN_VENDOR_T2LM_CATEGORY_REQUEST:
            internal_category = WLAN_T2LM_CATEGORY_REQUEST;
            break;
        case QCA_WLAN_VENDOR_T2LM_CATEGORY_RESPONSE:
            internal_category = WLAN_T2LM_CATEGORY_RESPONSE;
            break;
        case QCA_WLAN_VENDOR_T2LM_CATEGORY_TEARDOWN:
            internal_category = WLAN_T2LM_CATEGORY_TEARDOWN;
            break;
        default:
            t2lm_debug("invalid T2LM category: %d", category);
            internal_category = WLAN_T2LM_CATEGORY_NONE;
    }

    return internal_category;
}

enum qca_wlan_vendor_channel_width
wlan_cfg80211_get_qca_vendor_channel_width(struct ieee80211com *ic)
{
    enum ieee80211_cwm_width chan_bw = IEEE80211_CWM_WIDTHINVALID;

    chan_bw = get_chwidth_phymode(ieee80211_chan2mode(ic->ic_curchan));

    switch(chan_bw) {
        case IEEE80211_CWM_WIDTH20:
            return QCA_WLAN_VENDOR_CHAN_WIDTH_20MHZ;
        case IEEE80211_CWM_WIDTH40:
            return QCA_WLAN_VENDOR_CHAN_WIDTH_40MHZ;
        case IEEE80211_CWM_WIDTH80:
            return QCA_WLAN_VENDOR_CHAN_WIDTH_80MHZ;
        case IEEE80211_CWM_WIDTH160:
            return QCA_WLAN_VENDOR_CHAN_WIDTH_160MZ;
        case IEEE80211_CWM_WIDTH80_80:
            return QCA_WLAN_VENDOR_CHAN_WIDTH_80_80MHZ;
        case IEEE80211_CWM_WIDTH320:
            return QCA_WLAN_VENDOR_CHAN_WIDTH_320MHZ;
        default:
            return QCA_WLAN_VENDOR_CHAN_WIDTH_INVALID;
    }

    return QCA_WLAN_VENDOR_CHAN_WIDTH_INVALID;
}

enum qca_wlan_vendor_t2lm_mapping
wlan_cfg80211_get_t2lm_enable_val(ol_ath_soc_softc_t *soc)
{
    switch(soc->t2lm_enable) {
        case WLAN_T2LM_NOT_SUPPORTED:
            return QCA_WLAN_VENDOR_T2LM_NOT_SUPPORTED;
        case WLAN_T2LM_MAP_EACH_TID_TO_SAME_OR_DIFFERENET_LINK_SET:
            return QCA_WLAN_VENDOR_T2LM_MAP_EACH_TID_TO_SAME_OR_DIFFERENT_LINK_SET;
        case WLAN_T2LM_MAP_ALL_TIDS_TO_SAME_LINK_SET:
            return QCA_WLAN_VENDOR_T2LM_MAP_ALL_TIDS_TO_SAME_LINK_SET;
        default:
            return QCA_WLAN_VENDOR_T2LM_INVALID;
    }

    return QCA_WLAN_VENDOR_T2LM_MAP_ALL_TIDS_TO_SAME_LINK_SET;
};

static inline
int wlan_cfg80211_t2lm_app_send_app_init(struct sk_buff *vendor_event)
{
    struct wlan_objmgr_pdev *pdev = NULL;
    struct ieee80211com *ic_ptr = NULL;
    struct nlattr *soc_info = NULL, *per_soc_info = NULL;
    struct nlattr *link_info = NULL;
    struct nlattr *per_link_info = NULL;
    uint8_t num_socs = 0;
    uint8_t ml_grp_id = 0;
    uint8_t num_links = 0;
    uint8_t i = 0, j = 0;
    uint8_t tx_chain_mask, rx_chain_mask;
#ifdef WLAN_CONFIG_TELEMETRY_AGENT
    struct agent_pdev_iface_init_obj pdev_info = {0};
#endif

      t2lm_debug("Detected message type : RM_GENERIC");

      if (nla_put_u8(vendor_event,
          QCA_WLAN_VENDOR_ATTR_RM_GENERIC_APP_VERSION,
    ol_global_soc[0]->t2lm_app_version)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_APP_VERSION put fail");
        return -1;
      }

      if (nla_put_u8(vendor_event,
          QCA_WLAN_VENDOR_ATTR_RM_GENERIC_DRIVER_VERSION,
    ol_global_soc[0]->t2lm_driver_version)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_DRIVER_VERSION put fail");
        return -1;
      }

      soc_info = nla_nest_start(vendor_event,
                          QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SOC_DEVICE_INFO);
      if (!soc_info) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SOC_DEVICE_INFO put fail");
        return -1;
      }

      for (i = 0; i < ol_num_global_soc; i++) {
        if (!mlo_psoc_get_grp_id(ol_global_soc[i]->psoc_obj, &ml_grp_id)) {
          qdf_err("Invalid MLO Group id");
          continue;
        }

        num_socs++;

        per_soc_info = nla_nest_start(vendor_event, i);
        if (!per_soc_info)
            return -1;

        if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_SOC_DEVICE_SOC_ID,
              ol_global_soc[i]->psoc_obj->soc_objmgr.psoc_id)) {
          t2lm_err("QCA_WLAN_VENDOR_ATTR_SOC_DEVICE_SOC_ID put fail");
            return -1;
        }

        num_links = ol_global_soc[i]->psoc_obj->soc_objmgr.wlan_pdev_count;
        if(nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_SOC_DEVICE_NUM_LINKS,
              num_links)) {
          t2lm_err("QCA_WLAN_VENDOR_ATTR_SOC_DEVICE_NUM_LINKS put fail");
            return -1;
        }

        link_info = nla_nest_start(vendor_event,
            QCA_WLAN_VENDOR_ATTR_SOC_DEVICE_LINK_INFO);
        if (!link_info)
            return -1;

        for (j = 0; j < num_links; j++) {
          per_link_info = nla_nest_start(vendor_event, j);
          if (!per_link_info)
            return -1;

          pdev = ol_global_soc[i]->psoc_obj->soc_objmgr.wlan_pdev_list[j];
          if (!pdev) {
            t2lm_err("pdev is null");
            return -1;
          }

          ic_ptr = wlan_pdev_get_mlme_ext_obj(pdev);
          if (!ic_ptr) {
            t2lm_err("ic_ptr is null");
            return -1;
          }

          if (nla_put_u16(vendor_event,
                QCA_WLAN_VENDOR_ATTR_LINK_INFO_HW_LINK_ID,
                ((ml_grp_id << 8) |wlan_mlo_get_pdev_hw_link_id(pdev)))) {
            t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_INFO_HW_LINK_ID put fail");
            return -1;
          }

          if(nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_LINK_MAC,
                6, (void *)pdev->pdev_nif.macaddr)) {
            t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_MAC put fail");
            return -1;
          }

          if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_LINK_CHAN_BW,
                wlan_cfg80211_get_qca_vendor_channel_width(ic_ptr))) {
            t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_CHAN_BW put fail");
            return -1;
          }

          if(nla_put_u16(vendor_event, QCA_WLAN_VENDOR_ATTR_LINK_CHAN_FREQ,
                ic_ptr->ic_curchan->ic_freq)) {
            t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_CHAN_FREQ put fail");
            return -1;
          }
#ifdef WLAN_CONFIG_TELEMETRY_AGENT
          wifi_driver_get_pdev_info(pdev, &pdev_info);
          if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_LINK_BAND_CAP,
                pdev_info.band)) {
            t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_BAND_CAP put fail");
            return -1;
          }
#endif
          if(ic_ptr->ic_get_tgt_res_cfg(ic_ptr, &tx_chain_mask, &rx_chain_mask)) {
             t2lm_info("%s: error getting chainmask values", __func__);
             return -1;
          }

          if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_LINK_TX_CHAIN_MASK,
                  tx_chain_mask)) {
              t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_TX_CHAIN_MASK put fail");
              return -1;
          }

          if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_LINK_RX_CHAIN_MASK,
                  rx_chain_mask)) {
              t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_RX_CHAIN_MASK put fail");
              return -1;
          }
          nla_nest_end(vendor_event, per_link_info);
        }
        nla_nest_end(vendor_event, link_info);
        nla_nest_end(vendor_event, per_soc_info);
      }
      nla_nest_end(vendor_event, soc_info);

      if (nla_put_u8(vendor_event,
            QCA_WLAN_VENDOR_ATTR_RM_GENERIC_NUM_SOC_DEVICES,
            num_socs)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_NUM_SOC_DEVICES put fail");
            return -1;
      }

      if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_RM_GENERIC_TTLM_MAPPING,
            wlan_cfg80211_get_t2lm_enable_val(ol_global_soc[0]))) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_TTLM_MAPPING put fail");
        return -1;
      }

      return 0;
}

static inline
int wlan_cfg80211_t2lm_app_send_link_bw_nss_change(struct sk_buff *vendor_event, void * gen_data)
{
    struct link_change_info *gen_info = NULL;
    struct nlattr *link_changes = NULL;
    struct nlattr *num_links_change = NULL;
    /*Fill BW NSS attributes*/
      gen_info = (struct link_change_info *)gen_data;
      t2lm_debug("Detected message type : LINK_BW_NSS_CHANGE \n"
                       "BW = %d NSS = %d hw_id = %d ml_grp_id = %d \n", gen_info->new_bw,
                        gen_info->new_nss, gen_info->hw_id, gen_info->ml_grp_id);

      link_changes = nla_nest_start(vendor_event, QCA_WLAN_VENDOR_ATTR_RM_GENERIC_LINK_BW_NSS_CHANGE);
      if (!link_changes){
        return -1;
      }

      num_links_change = nla_nest_start(vendor_event, 0);

      if (!num_links_change){
        return -1;
      }
      if (nla_put_u16(vendor_event, QCA_WLAN_VENDOR_ATTR_LINK_HW_LINK_ID,
            (((gen_info->ml_grp_id) << 8) | (gen_info->hw_id)))) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_INFO_HW_LINK_ID put fail");
        return -1;
      }

      if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_LINK_NEW_CHAN_BW, gen_info->new_bw)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_CHAN_BW put fail");
        return -1;
      }

      if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_LINK_NEW_CHAN_NSS, gen_info->new_nss)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_CHAN_NSS put fail");
        return -1;
      }

      nla_nest_end(vendor_event, num_links_change);
      nla_nest_end(vendor_event, link_changes);

      return 0;
}

static inline
int wlan_cfg80211_t2lm_app_send_assoc_info(struct sk_buff *vendor_event, void * gen_data)
{
    struct peer_generic_assoc_event *peer_event = NULL;
    struct nlattr *nla_link_entry, *nla_per_link_entry;
    struct nlattr *nla_t2lm_info, *nla_per_direction_t2lm_info;
    struct nlattr *nla_peer_caps, *per_peer_caps_info;
    struct nlattr *tid_array, *tid_entry;
    struct mld_peer_link_entry  *mld_link_info;
    struct wlan_t2lm_info *t2lm_info_entry;
    uint8_t i = 0;
    uint8_t idx = 0, tid_idx = 0, k = 0;

    peer_event = (struct peer_generic_assoc_event *)gen_data;
    /* Fill assoc attributes of event */
    if(nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_RM_GENERIC_MLD_MAC_ADDR,
                QDF_MAC_ADDR_SIZE, &peer_event->mld_mac_addr[0])) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_MLD_MAC_ADDR put fail");
        return -1;
    }

    if (nla_put_u8(vendor_event,
                QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_NUM_LINKS,
                peer_event->num_links)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_NUM_LINKS put fail");
        return -1;
    }

    nla_link_entry = nla_nest_start(vendor_event,
                                    QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_PEER_LINK_ENTRY);
    if (nla_link_entry == NULL) {
        t2lm_err("nla_link_entry fail, nla is NULL");
        return -1;
    }

    for (i = 0; i < peer_event->num_links; i++) {

        nla_per_link_entry = nla_nest_start(vendor_event, i);
        if (nla_per_link_entry == NULL) {
            t2lm_err("nla_per_link_entry fail nla is NULL");
            return -1;
        }
        /* fill individual attributes of link entry */
        mld_link_info = &peer_event->link_entry[i];

        if (nla_put_u16(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_HW_LINK_ID,
                mld_link_info->hw_link_id) ||
            nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_PEER_MAC, QDF_MAC_ADDR_SIZE,
                &mld_link_info->link_addr[0]) ||
            nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_MLO_LINK_ID,
                mld_link_info->ieee_link_id) ||
            nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_IS_ASSOC_LINK,
                mld_link_info->is_assoc_link) ||
            nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_CHAN_BW,
                mld_link_info->chan_bw) ||
            nla_put_u16(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_CHAN_FREQ,
                mld_link_info->chan_freq) ||
            nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_RSSI,
                mld_link_info->link_rssi) ||
            nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_BAND_CAP,
                mld_link_info->band_cap) ||
            nla_put_u16(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_EFF_CHAN_BW,
                mld_link_info->eff_chan_bw) ||
            nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_VDEV_ID,
                mld_link_info->vdev_id) ||
            nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_AP_MLD_MAC,QDF_MAC_ADDR_SIZE,
                &mld_link_info->ap_mld_addr[0]) ||
            nla_put_u16(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_CAPS,
                mld_link_info->peer_flags)

            ) {
                t2lm_err(" put failed for nla_per_link_entry");
                return -1;
            }

        nla_peer_caps = nla_nest_start(vendor_event,
                QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_EHT_PEER_CAPS);
        if (nla_peer_caps == NULL) {
            t2lm_err("nla_peer_caps fail nla is NULL");
            return -1;
        }

        for (idx = 0; idx < QCA_WLAN_VENDOR_EHTCAP_TXRX_MCS_NSS_IDX_MAX; idx++) {

            per_peer_caps_info = nla_nest_start(vendor_event, idx);
            if (per_peer_caps_info == NULL) {
                t2lm_err("per_peer_caps_info fail nla is NULL");
                return -1;
            }

            if (nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_EHTCAP_RX_MCS_NSS_MAP,
                        mld_link_info->caps.rx_mcs_nss_map[idx])) {
                t2lm_err(" put failed for QCA_WLAN_VENDOR_ATTR_EHTCAP_RX_MCS_NSS_MAP");
                return -1;
            }

            if (nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_EHTCAP_TX_MCS_NSS_MAP,
                        mld_link_info->caps.tx_mcs_nss_map[idx])) {
                t2lm_err(" put failed for QCA_WLAN_VENDOR_ATTR_EHTCAP_TX_MCS_NSS_MAP");
                return -1;
            }

            nla_nest_end(vendor_event, per_peer_caps_info);
        }

        nla_nest_end(vendor_event, nla_peer_caps);
        nla_nest_end(vendor_event, nla_per_link_entry);
    }

    nla_nest_end(vendor_event, nla_link_entry);

    nla_t2lm_info = nla_nest_start(vendor_event,
                                   QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_TTLM_INFO);
    if (nla_t2lm_info == NULL) {
        t2lm_err("nla_t2lm_info fail nla is NULL");
        return -1;
    }

    for (i = 0, k = 0; i < WLAN_T2LM_BIDI_DIRECTION; i++) {
        if (peer_event->t2lm_info[i].direction == WLAN_T2LM_INVALID_DIRECTION)
            continue;

        nla_per_direction_t2lm_info = nla_nest_start(vendor_event, k);
        if (nla_per_direction_t2lm_info == NULL) {
            t2lm_err("nla_per_direction_t2lm_info fail nla is NULL");
            return -1;
        }
        t2lm_info_entry = &peer_event->t2lm_info[i];

        if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_T2LM_DIRECTION,
                    convert_t2lm_direction_internal_to_nl80211(t2lm_info_entry->direction)) ||
                nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_T2LM_DEFAULT_LINK_MAPPING,
                    t2lm_info_entry->default_link_mapping)) {
            t2lm_err(" put failed for nla_per_direction_t2lm_info");
            return -1;
        }

        tid_array = nla_nest_start(vendor_event,
                QCA_WLAN_VENDOR_ATTR_T2LM_PROVISIONED_LINKS);
         if (tid_array == NULL) {
            t2lm_err("tid_array fail nla is NULL");
            return -1;
        }

        for (tid_idx = 0; tid_idx < T2LM_MAX_NUM_TIDS; tid_idx++) {
            tid_entry = nla_nest_start(vendor_event, tid_idx);
            if (tid_entry == NULL) {
                t2lm_err("tid_array fail nla is NULL");
                return -1;
            }
            if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_TID_MAP, t2lm_info_entry->ieee_link_map_tid[tid_idx])) {
                t2lm_err(" put failed for QCA_WLAN_VENDOR_ATTR_T2LM_PROVISIONED_LINKS");
                return -1;
            }
            nla_nest_end(vendor_event, tid_entry);
        }
        nla_nest_end(vendor_event, tid_array);

        nla_nest_end(vendor_event, nla_per_direction_t2lm_info);
        k++;
    }

    nla_nest_end(vendor_event, nla_t2lm_info);

    t2lm_debug("Sent Generic Event to application");

    return 0;
}

static inline
int wlan_cfg80211_t2lm_app_send_disassoc_info(struct sk_buff *vendor_event, void * gen_data)
{
    struct nlattr *nla_link_entry, *nla_per_link_entry;
    struct mld_peer_link_entry  *mld_link_info;
    struct peer_generic_disassoc_event *disassoc_event;
    uint8_t i = 0;

    disassoc_event = (struct peer_generic_disassoc_event *)gen_data;
    /* Fill disassoc event attributes */
    if(nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_RM_GENERIC_MLD_MAC_ADDR,
                QDF_MAC_ADDR_SIZE, &disassoc_event->mld_mac_addr[0])) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLD_MAC put fail");
        return -1;
    }

    if (nla_put_u8(vendor_event,
                QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_NUM_LINKS,
                disassoc_event->num_links)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_NUM_LINKS put fail");
        return -1;
    }

    nla_link_entry = nla_nest_start(vendor_event,
                                    QCA_WLAN_VENDOR_ATTR_RM_GENERIC_ASSOC_PEER_LINK_ENTRY);
    if (nla_link_entry == NULL) {
        t2lm_err("nla_link_entry fail nla is NULL");
        return -1;
    }

    for (i = 0; i < disassoc_event->num_links; i++) {
        nla_per_link_entry = nla_nest_start(vendor_event, i);
        if (nla_per_link_entry == NULL) {
            t2lm_err("nla_per_link_entry fail nla is NULL");
            return -1;
        }
        /* fill individual attributes of link entry */
        mld_link_info = &disassoc_event->peer_entry[i];
        if (nla_put_u16(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_HW_LINK_ID,
                    mld_link_info->hw_link_id) ||
                nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_PEER_MAC, QDF_MAC_ADDR_SIZE,
                    &mld_link_info->link_addr[0]) ||
                nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_IS_ASSOC_LINK,
                    mld_link_info->is_assoc_link)) {
            t2lm_err(" put failed for nla_per_link_entry");
            return -1;
        }
        nla_nest_end(vendor_event, nla_per_link_entry);
    }
    nla_nest_end(vendor_event, nla_link_entry);

    return 0;
}

void wlan_cfg80211_t2lm_app_reply_generic_response(void * gen_data,
                                                    uint8_t category,
						    uint8_t service_id)
{
    struct sk_buff *vendor_event;
    struct net_device *dev = NULL;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
    int ret_val;
#endif
    uint32_t len = 0;
    struct wlan_objmgr_pdev *pdev = NULL;
    struct ieee80211com *ic = NULL;

    len = get_t2lm_app_genric_evt_data_len();
    if (!len) {
        t2lm_err("Invalid length");
        return;
    }

#ifdef WLAN_CONFIG_TELEMETRY_AGENT
    /* Proceed only after RM APP INIT */
    if (service_id == RM_MAIN_SERVICE && ol_global_soc[0]->rm_app_init_done != 1) {
        return;
    }
#endif

    pdev = ol_global_soc[0]->psoc_obj->soc_objmgr.wlan_pdev_list[0];
    ic = wlan_pdev_get_mlme_ext_obj(pdev);
    if (!ic) {
        t2lm_err("ic is null");
        return;
    }
    dev = ic->ic_netdev;
    t2lm_debug(">");

    vendor_event =
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, NULL,
#else
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy,
                                                    dev->ieee80211_ptr,
#endif
                          len,
                          QCA_NL80211_VENDOR_SUBCMD_RM_GENERIC_INDEX,
                          qdf_mem_malloc_flags());

    if (!vendor_event) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "cfg80211_vendor_event_alloc failed\n");
        return;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);

    ret_val = nla_put_u32(vendor_event,
            NL80211_ATTR_IFINDEX,
            dev->ifindex);
    if (ret_val) {
        t2lm_err("NL80211_ATTR_IFINDEX put fail");
        goto err;
    }

    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);

    if(nla == NULL){
        t2lm_err("nla_nest_start fail nla is NULL ");
        goto err;
    }

    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);
#endif

    if (nla_put_u8(vendor_event,
                QCA_WLAN_VENDOR_ATTR_RM_GENERIC_CATEGORY,
                category)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_CATEGORY put fail");
        goto err;
    }

    if (nla_put_u8(vendor_event,
                QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SERVICE_ID,
                service_id)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SERVICE_ID put fail");
        goto err;
    }

    if (nla_put_u8(vendor_event,
                QCA_WLAN_VENDOR_ATTR_RM_GENERIC_DYNAMIC_INIT_CONF,
                BIT_IS_SET(ol_global_soc[0]->dynamic_service_bitmask,
                                                        service_id))) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_RM_GENERIC_DYNAMIC_INIT_CONF put fail");
        goto err;
    }

    switch(category) {
        case QCA_WLAN_VENDOR_ATTR_GENERIC_CATEGORY_INVALID:
                t2lm_err("Invalid category");
                goto err;

        case QCA_WLAN_VENDOR_ATTR_GENERIC_CATEGORY_APP_INIT:
                if(wlan_cfg80211_t2lm_app_send_app_init(vendor_event))
                    goto err;
                break;

        case QCA_WLAN_VENDOR_ATTR_GENERIC_CATEGORY_LINK_BW_NSS_CHANGE:
                if(wlan_cfg80211_t2lm_app_send_link_bw_nss_change(vendor_event, gen_data))
                    goto err;
                break;

        case QCA_WLAN_VENDOR_ATTR_GENERIC_CATEGORY_ASSOC_NO_T2LM_INFO:
                /* Fallthrough */
        case QCA_WLAN_VENDOR_ATTR_GENERIC_CATEGORY_ASSOC_WITH_T2LM_INFO:
                /* Fallthrough */
        case QCA_WLAN_VENDOR_ATTR_GENERIC_CATEGORY_OMI_NO_T2LM_INFO:
                if(wlan_cfg80211_t2lm_app_send_assoc_info(vendor_event, gen_data))
                    goto err;
                break;
        case QCA_WLAN_VENDOR_ATTR_GENERIC_CATEGORY_DISASSOC:
                if(wlan_cfg80211_t2lm_app_send_disassoc_info(vendor_event, gen_data))
                    goto err;
                break;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(vendor_event, nla);
#endif
    wlan_cfg80211_vendor_event(vendor_event, qdf_mem_malloc_flags());
    return;

err:
    wlan_cfg80211_vendor_free_skb(vendor_event);
}
qdf_export_symbol(wlan_cfg80211_t2lm_app_reply_generic_response);

/**
 * wlan_cfg80211_rm_app_genric - RM application generic command from
 * userspace.
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_rm_app_genric(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_RM_GENERIC_MAX + 1];
#ifdef WLAN_CONFIG_TELEMETRY_AGENT
    enum rm_services service_id;
    uint64_t service_data = 0;
#endif
    enum qca_wlan_vendor_dynamic_init_conf dynamic_config;

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_RM_GENERIC_MAX,
                                data, data_len,
                                rm_generic_policy)) {
        t2lm_err("nla_parse failed");
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_RM_GENERIC_APP_VERSION])
        ol_global_soc[0]->t2lm_app_version = nla_get_u8(
                attr[QCA_WLAN_VENDOR_ATTR_RM_GENERIC_APP_VERSION]);

    if (attr[QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SERVICE_ID]) {
#ifdef WLAN_CONFIG_TELEMETRY_AGENT
        service_id = nla_get_u8(
                         attr[QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SERVICE_ID]);
        if (attr[QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SERVICE_DATA]) {
            if (service_id == RM_ERP_SERVICE) {
                service_data = nla_get_u64(
                                   attr[QCA_WLAN_VENDOR_ATTR_RM_GENERIC_SERVICE_DATA]);
            }
        }
#endif
    }
    else {
          t2lm_err("service id not present in app init");
          return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_RM_GENERIC_DYNAMIC_INIT_CONF]) {
        dynamic_config = nla_get_u8(
                    attr[QCA_WLAN_VENDOR_ATTR_RM_GENERIC_DYNAMIC_INIT_CONF]);
    } else {
        t2lm_err("dynamic app config not present in app init");
        /* Below change is to ensure backward compatibility is maintained until RM
         * changes are merged. This will be removed in follow up changes.
         */
        dynamic_config = QCA_WLAN_VENDOR_DYNAMIC_INIT_CONF_RM_APP_START;
    }

    ol_global_soc[0]->t2lm_driver_version = 1;

    switch (dynamic_config) {
#ifdef WLAN_CONFIG_TELEMETRY_AGENT
        case QCA_WLAN_VENDOR_DYNAMIC_INIT_CONF_RM_APP_START:
            t2lm_debug("Generic App init called");
            if (ol_global_soc[0]->rm_app_init_done) {
                /* rm init already done, reinit
                 * Deinit for services, reset init_done status for all,
                 * init for the service received.
                 */
                wlan_telemetry_agent_application_init_notify(AGENT_NOTIFY_EVENT_DEINIT,
                                                             RM_MAIN_SERVICE,
                                                             service_data);
                ol_global_soc[0]->rm_app_init_done = 0;
                ol_global_soc[0]->rm_energy_service_enabled = 0;

                wlan_telemetry_agent_application_init_notify(AGENT_NOTIFY_EVENT_INIT,
                                                             service_id,
                                                             service_data);
            }
            else
                wlan_telemetry_agent_application_init_notify(AGENT_NOTIFY_EVENT_INIT,
                                                             service_id,
                                                             service_data);

            if (service_id == RM_MAIN_SERVICE)
                ol_global_soc[0]->rm_app_init_done = 1;
            else if (service_id == RM_ADMCTRL_SERVICE)
                ol_global_soc[0]->rm_admctrl_service_enabled = 1;
            else if (service_id == RM_ENERGY_SERVICE)
                ol_global_soc[0]->rm_energy_service_enabled = 1;

            break;

        case QCA_WLAN_VENDOR_DYNAMIC_INIT_CONF_SERVICE_START:
            t2lm_debug("Dynamic App init called");
            BIT_SET(ol_global_soc[0]->dynamic_service_bitmask, service_id);
            wlan_telemetry_agent_dynamic_app_init_deinit_notify(
                                            AGENT_NOTIFY_EVENT_INIT,
                                            service_id,
                                            service_data);
            if (service_id == RM_ADMCTRL_SERVICE)
                ol_global_soc[0]->rm_admctrl_service_enabled = 1;
            else if (service_id == RM_ENERGY_SERVICE)
                ol_global_soc[0]->rm_energy_service_enabled = 1;
            break;

        case QCA_WLAN_VENDOR_DYNAMIC_INIT_CONF_SERVICE_STOP:
            t2lm_debug("Dynamic App deinit called");
            BIT_RESET(ol_global_soc[0]->dynamic_service_bitmask, service_id);
            wlan_telemetry_agent_dynamic_app_init_deinit_notify(
                                            AGENT_NOTIFY_EVENT_DEINIT,
                                            service_id,
                                            service_data);
            if (service_id == RM_ADMCTRL_SERVICE)
                ol_global_soc[0]->rm_admctrl_service_enabled = 0;
            else if (service_id == RM_ENERGY_SERVICE)
                ol_global_soc[0]->rm_energy_service_enabled = 0;
            break;

        default:
            t2lm_err("Invalid Dynamic app config value %d", dynamic_config);
            return -EINVAL;
            break;
#else /* WLAN_CONFIG_TELEMETRY_AGENT */
        case QCA_WLAN_VENDOR_DYNAMIC_INIT_CONF_RM_APP_START:
        case QCA_WLAN_VENDOR_DYNAMIC_INIT_CONF_SERVICE_START:
        case QCA_WLAN_VENDOR_DYNAMIC_INIT_CONF_SERVICE_STOP:
        default:
            t2lm_debug("%s: No-op for RM app init", __func__);
            break;
#endif /* WLAN_CONFIG_TELEMETRY_AGENT */
    }

    return 0;
}

/**
 * wlan_cfg80211_compare_app_t2lm_info_and_negotiated_t2lm_info() - API to check
 * if APP provided T2LM is same as already negotiated T2LM
 * @t2lm: Pointer to APP provided T2LM info
 * @negotiated_t2lm: Pointer to negotiated T2LM info
 *
 * Return: true if APP provided T2LM info is same as negotiated info, else false
 */
static bool wlan_cfg80211_compare_app_t2lm_info_and_negotiated_t2lm_info(
        struct wlan_t2lm_onging_negotiation_info *t2lm,
        struct wlan_prev_t2lm_negotiated_info *negotiated_t2lm)
{
    uint8_t i = 0;

    for (i = 0; i < WLAN_T2LM_MAX_DIRECTION; i++) {
        if (t2lm->t2lm_info[i].direction == WLAN_T2LM_INVALID_DIRECTION)
            continue;

        if (t2lm->t2lm_info[i].default_link_mapping !=
                negotiated_t2lm->t2lm_info[i].default_link_mapping)
            return false;

        if (qdf_mem_cmp(t2lm->t2lm_info[i].hw_link_map_tid,
                    negotiated_t2lm->t2lm_info[i].hw_link_map_tid,
                    sizeof(uint16_t) * T2LM_MAX_NUM_TIDS) != 0)
            return false;
    }

    return true;
}

static int wlan_cfg80211_process_t2lm_cmd(struct ieee80211_node *ni,
        struct wlan_t2lm_onging_negotiation_info *t2lm)
{
    struct wlan_mlo_peer_context *ml_peer = NULL;
    int retval = 0;
    uint8_t i = 0, tid = 0;

    if (!wlan_peer_is_mlo(ni->peer_obj)) {
        t2lm_err("non-mlo peer");
        return -EINVAL;
    }

    if (!ieee80211_node_is_authorized(ni)) {
        t2lm_err("Not processing T2LM cmd for unauthorized node");
        return -EINVAL;
    }

    t2lm_debug("T2LM Mapping Received from RM APP");
    for (i = 0; i < QCA_WLAN_VENDOR_T2LM_MAX_VALID_DIRECTION; i++) {
         t2lm_debug("idx:%d direction:%d default_link_mapping:%d",
                    i, t2lm->t2lm_info[i].direction, t2lm->t2lm_info[i].default_link_mapping);
         for (tid = 0; tid < T2LM_MAX_NUM_TIDS; tid++) {
              t2lm_debug("tid:%d t2lm_provisioned_links:%x",
                      tid, t2lm->t2lm_info[i].hw_link_map_tid[tid]);
         }
    }

    if (t2lm->category == WLAN_T2LM_CATEGORY_REQUEST) {
        ml_peer = ni->peer_obj->mlo_peer_ctx;
        if (!ml_peer) {
            t2lm_err("null ml_peer");
            return -EINVAL;
        }

        /* If the already negotiated mapping and new mapping are same,
         * no need to send another frame. Just send success confirmation
         * to RM APP.
         */

        if ((t2lm->t2lm_info_present == 1 && t2lm->pref_link_present == 0) &&
                wlan_cfg80211_compare_app_t2lm_info_and_negotiated_t2lm_info(
                    t2lm, &ml_peer->t2lm_policy.t2lm_negotiated_info)) {
            t2lm->t2lm_resp_type = WLAN_T2LM_RESP_TYPE_SUCCESS;
            wlan_mlme_assoc_t2lm_params(ni->peer_obj, false,
                    t2lm, QCA_WLAN_VENDOR_T2LM_CATEGORY_RESPONSE);
            return 0;
        }

        if ((t2lm->t2lm_info_present == 1 && t2lm->pref_link_present == 1) &&
                wlan_cfg80211_compare_app_t2lm_info_and_negotiated_t2lm_info(
                    t2lm, &ml_peer->t2lm_policy.t2lm_negotiated_info) &&
                (qdf_mem_cmp(&(t2lm->link_preference),
                             &(ml_peer->t2lm_policy.t2lm_negotiated_info.link_preference),
                             sizeof(struct wlan_link_preference)) == 0)) {
            t2lm->t2lm_resp_type = WLAN_T2LM_RESP_TYPE_SUCCESS;
            wlan_mlme_assoc_t2lm_params(ni->peer_obj, false,
                    t2lm, QCA_WLAN_VENDOR_T2LM_CATEGORY_RESPONSE);
            return 0;
        }
    }

    retval = wlan_send_t2lm_action_frame(ni, t2lm);
    if (retval) {
        t2lm_err("Failed to send T2LM action frame, category:%d",
                 t2lm->category);
        t2lm->t2lm_resp_type =
            WLAN_T2LM_RESP_TYPE_DENIED_TID_TO_LINK_MAPPING;
        wlan_mlme_assoc_t2lm_params(ni->peer_obj, false,
                t2lm, QCA_WLAN_VENDOR_T2LM_CATEGORY_RESPONSE);
    }

    return retval;
}

enum wlan_link_band_caps wlan_cfg80211_link_band_info(struct wlan_objmgr_pdev *pdev)
{
    uint8_t pdev_idx;
    bool is_6ghz_pdev = false;
    enum wlan_link_band_caps pdev_band = WLAN_LINK_BAND_INVALID;
    uint32_t low_freq = 0, high_freq = 0;
    struct wlan_objmgr_psoc *psoc;
    struct wlan_psoc_host_hal_reg_capabilities_ext *reg_cap;
    struct target_psoc_info *tgt_hdl;
    struct wlan_psoc_host_mac_phy_caps *mac_phy_cap;
    struct wlan_lmac_if_reg_rx_ops *reg_rx_ops;

    pdev_idx = wlan_objmgr_pdev_get_pdev_id(pdev);
    psoc = wlan_pdev_get_psoc(pdev);
    tgt_hdl = wlan_psoc_get_tgt_if_handle(psoc);
    reg_cap = ucfg_reg_get_hal_reg_cap(psoc);
    reg_rx_ops = wlan_lmac_if_get_reg_rx_ops(psoc);
    mac_phy_cap = target_psoc_get_mac_phy_cap(tgt_hdl);
    if (!reg_cap) {
        qdf_err("reg_cap is null");
        return pdev_band;
    }

    if (!mac_phy_cap) {
        qdf_err("mac_phy_cap is null");
        return pdev_band;
    }

    low_freq = reg_cap[pdev_idx].low_5ghz_chan;
    high_freq = reg_cap[pdev_idx].high_5ghz_chan;

    if (mac_phy_cap[pdev_idx].supported_bands &
            WMI_HOST_WLAN_2G_CAPABILITY) {
        pdev_band = WLAN_LINK_BAND_2GHZ;
    }

    /* is the pdev 6ghz only capable */
    if (mac_phy_cap[pdev_idx].supported_bands &
            WMI_HOST_WLAN_5G_CAPABILITY && reg_rx_ops) {
        is_6ghz_pdev = reg_rx_ops->reg_is_range_overlap_6g(
                low_freq, high_freq);
        if (is_6ghz_pdev) {
            if (high_freq < WLAN_LOW_6G_BAND_HIGHIEST_FREQ)
                pdev_band = WLAN_LINK_BAND_6GHZ_LOW;
            else if (low_freq >= WLAN_HIGH_6G_BAND_LOWEST_FREQ)
                pdev_band = WLAN_LINK_BAND_6GHZ_HIGH;
            else
                pdev_band = WLAN_LINK_BAND_6GHZ;
        }
    }

    if (!is_6ghz_pdev && (mac_phy_cap[pdev_idx].supported_bands &
                WMI_HOST_WLAN_5G_CAPABILITY)) {
        if (high_freq < WLAN_LOW_5G_BAND_HIGHIEST_FREQ)
            pdev_band = WLAN_LINK_BAND_5GHZ_LOW;
        else if (low_freq >= WLAN_HIGH_5G_BAND_LOWEST_FREQ)
            pdev_band = WLAN_LINK_BAND_5GHZ_HIGH;
        else
            pdev_band = WLAN_LINK_BAND_5GHZ;
    }

    return pdev_band;
}

void wlan_copy_ongoing_to_negotiated_info(struct wlan_mlo_peer_context *ml_peer,
                                          struct wlan_t2lm_onging_negotiation_info *t2lm)
{
    int pref_order, timeout, links = 0;
    ml_peer->t2lm_policy.t2lm_negotiated_info.link_preference.num_pref_links =
        t2lm->link_preference.num_pref_links;
    links = t2lm->link_preference.num_pref_links;

    for (pref_order = 0; pref_order < links; pref_order++) {
        ml_peer->t2lm_policy.t2lm_negotiated_info.link_preference.pref_order[pref_order] =
            t2lm->link_preference.pref_order[pref_order];
    }

    for (timeout = 0; timeout < WIFI_AC_MAX; timeout++) {
        ml_peer->t2lm_policy.t2lm_negotiated_info.link_preference.timeout[timeout] =
            t2lm->link_preference.timeout[timeout];
    }

    ml_peer->t2lm_policy.t2lm_negotiated_info.link_preference.tlt_characterization_params =
        t2lm->link_preference.tlt_characterization_params;
}

static int wlan_cfg80211_process_btmreq_info(struct ieee80211_node *ni,
                                                    struct nlattr **attr)
{
    struct ieee80211req_athdbg *req = NULL;
    struct nlattr *btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_MAX + 1];
    struct nlattr *link_id_info;
    struct nlattr *link_pref_info;
    struct nlattr *nl;
    struct ieee80211_bstm_reqinfo_target* btm_reqinfo = NULL;
    int rem = 0, link_id_count = 0, link_id_limit = 0, link_pref_limit = 0;
    int iter = 0, link_pref_count = 0;
    bool disassoc_force = false;
    uint8_t *link_set = NULL;
    int retval = EOK;

    if (attr == NULL || ni == NULL) {
        t2lm_err("NULL pointer received");
        return -EINVAL;
    }

    req = (struct ieee80211req_athdbg *)
                qdf_mem_malloc(sizeof(struct ieee80211req_athdbg));

    if (req == NULL) {
        t2lm_err("Failed buffer allocation for btm req info");
        return -EINVAL;
    }
    memset(req, 0, sizeof(struct ieee80211req_athdbg));

    btm_reqinfo = &req->data.bstmreq_target;

    for (iter = 0; iter < MAX_LINK_SUBSET; iter++) {
        link_set = btm_reqinfo->link_info[iter].linkid;
        memset(link_set, ML_PROBE_LINKID_INVALID,
               (sizeof(u_int8_t) * IEEE80211_WNM_WLAN_MAX_MLO_VDEVS));
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_BTM_REQ_INFO]) {
        nla_for_each_nested(nl, attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_BTM_REQ_INFO],
                rem) {
            if (wlan_cfg80211_nla_parse(btmreq_attr, QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_MAX,
                        nla_data(nl), nla_len(nl), NULL)) {
                t2lm_err("Link preference parsing failed");
                retval = -EINVAL;
                goto exit;
            }

            if (btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_DISASSOC_IMMINENT]) {
                btm_reqinfo->disassoc =
                    nla_get_u8(btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_DISASSOC_IMMINENT]);
                t2lm_debug("BTM request params: Disassoc Imminent:%d",
                           btm_reqinfo->disassoc);
            }

            if (btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_DISASSOC_TIMER]) {
                btm_reqinfo->disassoc_timer =
                     nla_get_u16(btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_DISASSOC_TIMER]);
                t2lm_debug("Disassoc timer: %d",
                           btm_reqinfo->disassoc_timer);
            }

            if (btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_DISASSOC_ENFORCE]) {
                disassoc_force =
                    nla_get_u8(btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_DISASSOC_ENFORCE]);
                t2lm_debug("Force Disassoc: %d", disassoc_force);
            }

            link_set = btm_reqinfo->link_info[0].linkid;
            if (btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_RECOMM_LINK_ID]) {
                link_id_count = 0;
                nla_for_each_nested(link_id_info, btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_RECOMM_LINK_ID],
                        link_id_limit) {

                    link_set[link_id_count] = nla_get_u8(link_id_info);
                    t2lm_debug("link_id[%d]:%d", link_id_count, link_set[link_id_count]);

                    link_id_count++;
                }
            }
            if (btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_LINK_ID_PREF]) {
                link_pref_count = 0;
                nla_for_each_nested(link_pref_info, btmreq_attr[QCA_WLAN_VENDOR_ATTR_BTM_REQINFO_LINK_ID_PREF],
                        link_pref_limit) {

                    btm_reqinfo->link_info[0].link_preference =
                                            nla_get_u8(link_pref_info);
                    t2lm_debug("link pref :%d", btm_reqinfo->link_info[0].link_preference);
                    link_pref_count++;
                }
            }
            btm_reqinfo->link_set = link_id_count;
        }
        btm_reqinfo->preferred_candidate_list = link_pref_count;
    }

    wlan_send_bstmreq_target(ni->ni_vap, ni->ni_macaddr,
                                btm_reqinfo, disassoc_force);
exit:
    if (req)
        qdf_mem_free(req);

    return retval;
}

/**
 * wlan_cfg80211_tid_to_link_mapping - TID-to-link negotiation commands from
 * userspace.
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_tid_to_link_mapping(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data,
        int data_len)
{
    struct ieee80211com *ic = NULL;
    struct wlan_mlo_peer_context *ml_peer = NULL;
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MAX + 1];
    struct nlattr *t2lm_attr[QCA_WLAN_VENDOR_ATTR_T2LM_MAX + 1];
    struct nlattr *preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_MAX +1];
    struct nlattr *nl;
    struct wlan_t2lm_onging_negotiation_info t2lm_cmd = {0};
    enum wlan_t2lm_direction direction = WLAN_T2LM_INVALID_DIRECTION;
    struct ieee80211_node *ni = NULL;
    struct wlan_objmgr_peer *peer = NULL;
    int retval = 0;
    uint8_t dir = 0;
    int rem = 0;
    struct nlattr *tid_map_info;
    struct nlattr *pref_order_info;
    struct nlattr *timeout_info;
    struct nlattr *tb_tid_info[QCA_WLAN_VENDOR_ATTR_TID_MAP_MAX + 1];
    int tid_map_limit, tid_count = 0, cat = -1;
    int pref_order_limit, timeout_limit,pref_order_count, timeout_count = 0;
    struct wlan_mlo_dev_context *mld_dev;
    uint8_t *mac_addr = NULL;
    uint8_t mld_macaddr[QDF_MAC_ADDR_SIZE] = {0};
    QDF_STATUS status = QDF_STATUS_E_FAILURE;
    t2lm_cmd.t2lm_info_present = 0;
    t2lm_cmd.pref_link_present = 0;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    wlan_mlme_debug("T2LM cmd received from APP");
    /* Initialize the T2LM direction to invalid */
    for (dir = 0; dir < WLAN_T2LM_MAX_DIRECTION; dir++) {
        t2lm_cmd.t2lm_info[dir].direction = WLAN_T2LM_INVALID_DIRECTION;
    }

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MAX,
                data, data_len,
                tid_to_link_mapping_policy)) {
        t2lm_err("nla_parse failed");
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_CATEGORY]) {
        cat = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_CATEGORY]);
        t2lm_cmd.category = convert_t2lm_category_nl80211_to_internal(cat);
        wlan_mlme_debug("T2LM category:%d", cat);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLD_MAC]) {
        mac_addr = nla_data(attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLD_MAC]);
        qdf_mem_copy(&mld_macaddr[0], mac_addr, QDF_MAC_ADDR_SIZE);
        t2lm_debug("MLD macaddr:%s", ether_sprintf(mld_macaddr));
    } else {
        t2lm_err("MLD macaddr not present");
        return -EINVAL;
    }

    ml_peer = wlan_mlo_get_mlpeer_by_peer_mladdr(
                (struct qdf_mac_addr *)&mld_macaddr[0],
                 &mld_dev);
    if ((mld_dev == NULL) || (ml_peer == NULL)) {
        t2lm_err("MLD context  or ML peer is NULL");
        return -EINVAL;
    }

    peer = wlan_mlo_peer_get_first_active_peer(ml_peer);
    if (!peer) {
        t2lm_err("peer is null");
        return -EINVAL;
    }

    status = wlan_objmgr_peer_try_get_ref(peer, WLAN_MLME_NB_ID);
    if (QDF_IS_STATUS_ERROR(status)) {
        t2lm_err("failed to get peer refcount");
        return -EINVAL;
    }

    ni = wlan_peer_get_mlme_ext_obj(peer);
    if (!ni) {
        t2lm_err("ni is null");
        wlan_objmgr_peer_release_ref(peer, WLAN_MLME_NB_ID);
        retval = -EINVAL;
        goto exit;
    }

    t2lm_cmd.t2lm_info_present = 0;
    t2lm_cmd.pref_link_present = 0;

    switch (cat)
    {
        case QCA_WLAN_VENDOR_T2LM_CATEGORY_LINK_QUALIFIER:

            if (attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_NUM_LINKS]) {
                t2lm_cmd.link_preference.num_pref_links = nla_get_u8(
                        attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_NUM_LINKS]);
                t2lm_debug("Number of links: %d", t2lm_cmd.link_preference.num_pref_links);
            }

            if (attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_LINK_QUALIFIER]) {
                 nla_for_each_nested(nl, attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_LINK_QUALIFIER],
                         rem) {
                     if (wlan_cfg80211_nla_parse(preference_attr, QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_MAX,
                                 nla_data(nl), nla_len(nl), NULL)) {
                         t2lm_err("Link preference parsing failed");
                         retval = -EINVAL;
                         goto exit;
                     }

                     if (preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_NUM_LINKS]) {
                         t2lm_cmd.link_preference.num_pref_links =
                             nla_get_u8(preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_NUM_LINKS]);
                         t2lm_debug("Preferred link params: num_pref_links:%d",t2lm_cmd.link_preference.num_pref_links);
                     }

                     if (preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_ORDER]) {
                         pref_order_count = 0;
                         nla_for_each_nested(pref_order_info, preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_ORDER],
                                 pref_order_limit) {

                             t2lm_cmd.link_preference.pref_order[pref_order_count] =
                                 nla_get_u8(pref_order_info);
                             t2lm_debug("pref_order[%d]:%d", pref_order_count, t2lm_cmd.link_preference.pref_order[pref_order_count]);

                             pref_order_count++;
                         }
                     }

                     if(preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_TIMEOUT]) {
                         timeout_count = 0;
                         nla_for_each_nested(timeout_info, preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_TIMEOUT],
                                 timeout_limit) {

                             t2lm_cmd.link_preference.timeout[timeout_count] =
                                 nla_get_u8(timeout_info);
                             t2lm_debug("timeout[%d]:%d", timeout_count, t2lm_cmd.link_preference.timeout[timeout_count]);

                             timeout_count++;
                         }
                     }

                     if (preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_TLT_BITMAP]) {
                         t2lm_cmd.link_preference.tlt_characterization_params =
                             nla_get_u32(preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_TLT_BITMAP]);
                         t2lm_debug("TLT bitmap: %d", t2lm_cmd.link_preference.tlt_characterization_params);
                     }

                     if (preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_FLAGS]) {
                         t2lm_cmd.link_preference.qualifier_flags =
                             nla_get_u32(preference_attr[QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_FLAGS]);
                         t2lm_debug("Qualifier flag: %d", t2lm_cmd.link_preference.qualifier_flags);
                     }

                     t2lm_cmd.pref_link_present = 1;
                 }
             }

            /* copy ongoing to negotiated info in case if only preference link present */
            wlan_copy_ongoing_to_negotiated_info(ml_peer, &t2lm_cmd);

            /* sending command to FW */
            ic->ic_send_mlo_peer_tid_to_link_map(ml_peer, false);

            /* calling for t2lm_event */
            t2lm_cmd.t2lm_resp_type =
                WLAN_T2LM_RESP_TYPE_SUCCESS;
            wlan_mlme_assoc_t2lm_params(ni->peer_obj, false,
                    &t2lm_cmd, QCA_WLAN_VENDOR_T2LM_CATEGORY_LINK_QUALIFIER);
            break;
        case QCA_WLAN_VENDOR_T2LM_CATEGORY_BTM_REQUEST:

            wlan_cfg80211_process_btmreq_info(ni, attr);

            break;

        default:
             if (attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_RESPONSE_TYPE]) {
                 t2lm_cmd.t2lm_resp_type =
                     convert_t2lm_resp_frm_type_nl80211_to_internal(nla_get_u8(
                                 attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_RESPONSE_TYPE]));
             }

             if (attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_DIALOG_TOKEN]) {
                 t2lm_cmd.dialog_token =
                     nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_DIALOG_TOKEN]);
                 t2lm_debug("dialog token = %d", t2lm_cmd.dialog_token);
             }

             nla_for_each_nested(nl, attr[QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_T2LM_INFO],
                     rem) {
                 if (wlan_cfg80211_nla_parse(t2lm_attr, QCA_WLAN_VENDOR_ATTR_T2LM_MAX,
                             nla_data(nl), nla_len(nl), NULL)) {
                     retval = -EINVAL;
                     goto exit;
                 }

                 if (t2lm_attr[QCA_WLAN_VENDOR_ATTR_T2LM_DIRECTION]) {
                     direction = convert_t2lm_direction_nl80211_to_internal(nla_get_u8(
                                 t2lm_attr[QCA_WLAN_VENDOR_ATTR_T2LM_DIRECTION]));
                     if (direction <= WLAN_T2LM_BIDI_DIRECTION)
                         t2lm_cmd.t2lm_info[direction].direction = direction;
                 }

                 if (t2lm_attr[QCA_WLAN_VENDOR_ATTR_T2LM_DEFAULT_LINK_MAPPING]) {
                     if (direction <= WLAN_T2LM_BIDI_DIRECTION) {
                         t2lm_cmd.t2lm_info[direction].default_link_mapping = nla_get_u8(
                                 t2lm_attr[QCA_WLAN_VENDOR_ATTR_T2LM_DEFAULT_LINK_MAPPING]);
                         if (t2lm_cmd.t2lm_info[direction].default_link_mapping)
                             continue;
                     }
                 }

                 if (t2lm_attr[QCA_WLAN_VENDOR_ATTR_T2LM_PROVISIONED_LINKS]) {
                     tid_count = 0;
                     nla_for_each_nested(tid_map_info,
                             t2lm_attr[QCA_WLAN_VENDOR_ATTR_T2LM_PROVISIONED_LINKS],
                             tid_map_limit) {
                         wlan_cfg80211_nla_parse(tb_tid_info,
                                 QCA_WLAN_VENDOR_ATTR_TID_MAP_MAX,
                                 nla_data(tid_map_info), nla_len(tid_map_info), NULL);
                         if (tb_tid_info[QCA_WLAN_VENDOR_ATTR_TID_MAP]) {
                             if (direction <= WLAN_T2LM_BIDI_DIRECTION) {
                                 t2lm_cmd.t2lm_info[direction].ieee_link_map_tid[tid_count] =
                                     nla_get_u8(tb_tid_info[QCA_WLAN_VENDOR_ATTR_TID_MAP]);
                             }
                         }
                         tid_count++;
                     }
                 }
                 t2lm_cmd.t2lm_info_present = 1;
             }

             if (((t2lm_cmd.t2lm_info[WLAN_T2LM_DL_DIRECTION].direction ==
                             WLAN_T2LM_DL_DIRECTION) ||
                         (t2lm_cmd.t2lm_info[WLAN_T2LM_UL_DIRECTION].direction ==
                          WLAN_T2LM_UL_DIRECTION)) &&
                     (t2lm_cmd.t2lm_info[WLAN_T2LM_BIDI_DIRECTION].direction ==
                      WLAN_T2LM_BIDI_DIRECTION)) {
                 t2lm_err("Both DL/UL and BIDI T2LM IEs should not be present at the same time");
                 retval = -EINVAL;
                 goto exit;
             }

             ieee80211_t2lm_populate_hw_link_id_map(ni, &t2lm_cmd);
             retval = wlan_cfg80211_process_t2lm_cmd(ni, &t2lm_cmd);

            if (retval) {
                t2lm_err("failed to process the t2lm/Preffered_link command");
            }
        break;
    }

exit:
    if (ni)
        ieee80211_free_node(ni, WLAN_MLME_NB_ID);

    return retval;
}

int wlan_cfg80211_fill_preferred_link_attr(
        struct sk_buff *t2lm_event,
        struct wlan_preferred_links *pref_link_entry)
{
    struct nlattr *nla_pref_info;
    struct nlattr *nla_pref_link_entry;
    struct nlattr *nla_t2lm_of_tids, *nla_per_dir_t2lm_of_tids;
    struct nlattr *tid_array_pref, *tid_entry_pref;
    int i;
    int tid_idx = 0;
    struct nlattr *nla_link_order, *nla_per_link_order;
    struct nlattr *nla_timeout, *nla_per_timeout;
    uint8_t links;
    int index = 0;

    t2lm_debug("Fill Preferred link attribute");
    nla_pref_info = nla_nest_start(t2lm_event,
            QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_LINK_QUALIFIER);
    if (nla_pref_info == NULL) {
        t2lm_err("nla_pref_info is NULL");
        return -EINVAL;
    }

    nla_pref_link_entry = nla_nest_start(t2lm_event, 0);
    if (!nla_pref_link_entry) {
         t2lm_err("nla_pref_link_entry is NULL");
         return -EINVAL;
    }

    t2lm_debug("peer_mld_mac_addr: " QDF_MAC_ADDR_FMT,
               QDF_MAC_ADDR_REF(pref_link_entry->peer_mld_mac_addr));

    if(nla_put(t2lm_event, QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_MAC_ADDR,
               QDF_MAC_ADDR_SIZE, &pref_link_entry->peer_mld_mac_addr[0])) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_MAC_ADDR put fail");
        return -EINVAL;
    }

    t2lm_debug("num_t2lm_of_tids:%d", pref_link_entry->num_t2lm_of_tids);

    if (nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_NUM_T2LM,
                   pref_link_entry->num_t2lm_of_tids)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_NUM_T2LM put fail");
        return -EINVAL;
    }

    if (pref_link_entry->num_t2lm_of_tids) {
        t2lm_debug("homogeneous_mapping:%d",
                   pref_link_entry->homogeneous_mapping);

        if (nla_put_u8(t2lm_event,
                       QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_HOMOGENEOUS_MAPPING,
                       pref_link_entry->homogeneous_mapping)) {
            t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_HOMOGENEOUS_MAPPING put fail");
            return -EINVAL;
        }
    }

    nla_t2lm_of_tids = nla_nest_start(t2lm_event,
            QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_T2LM_OF_TIDS);
    if(nla_t2lm_of_tids == NULL) {
        t2lm_err("nla_t2lm_of_tids is null");
        return -EINVAL;
    }

    for(i = 0, index = 0; (i < WLAN_T2LM_MAX_DIRECTION &&
                pref_link_entry->num_t2lm_of_tids); i++) {
        if (pref_link_entry->t2lm[i].direction == WLAN_T2LM_INVALID_DIRECTION)
            continue;

        nla_per_dir_t2lm_of_tids = nla_nest_start(t2lm_event, index);
        if(nla_per_dir_t2lm_of_tids == NULL) {
            t2lm_err("nla_per_dir_t2lm_of_tids is null");
            return -EINVAL;
        }

        t2lm_debug("direction:%d",
                   convert_t2lm_direction_internal_to_nl80211(
                       pref_link_entry->t2lm[i].direction));

        if(nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_QUALIFIER_DIRECTION,
                      convert_t2lm_direction_internal_to_nl80211(
                          pref_link_entry->t2lm[i].direction))) {
            t2lm_err("QCA_WLAN_VENDOR_ATTR_QUALIFIER_DIRECTION put fail");
            return -EINVAL;
        }

        tid_array_pref = nla_nest_start(t2lm_event,
                QCA_WLAN_VENDOR_ATTR_QUALIFIER_PROVISIONED_LINKS);
        if (tid_array_pref == NULL) {
            t2lm_err("tid_array_pref fail nla is NULL");
            return -EINVAL;
        }

        for (tid_idx = 0; tid_idx < T2LM_MAX_NUM_TIDS; tid_idx++) {
            tid_entry_pref = nla_nest_start(t2lm_event, tid_idx);
            if (tid_entry_pref == NULL) {
                t2lm_err("tid_array_pref is NULL");
                return -EINVAL;
            }

            t2lm_debug("tid:%d t2lm_provisioned_links:%x",
                       tid_idx,
                       pref_link_entry->t2lm[i].t2lm_provisioned_links[tid_idx]);

            if (nla_put_u16(t2lm_event, QCA_WLAN_VENDOR_ATTR_TID_MAP,
                            pref_link_entry->t2lm[i].t2lm_provisioned_links[tid_idx])) {
                t2lm_err("put failed for QCA_WLAN_VENDOR_ATTR_T2LM_PROVISIONED_LINKS");
                return -EINVAL;
            }
            nla_nest_end(t2lm_event, tid_entry_pref);
        }

        nla_nest_end(t2lm_event, tid_array_pref);

        nla_nest_end(t2lm_event, nla_per_dir_t2lm_of_tids);
        index++;
    }

    nla_nest_end(t2lm_event, nla_t2lm_of_tids);

    t2lm_debug("num_pref_links:%d", pref_link_entry->num_pref_links);

    if (nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_NUM_LINKS,
                   pref_link_entry->num_pref_links)){
        t2lm_err("QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_NUM_LINKS put fail");
        return -EINVAL;
    }

    nla_link_order = nla_nest_start(t2lm_event,
                                    QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_ORDER);
    if (nla_link_order == NULL) {
        t2lm_err("nla_link_order is null");
        return -EINVAL;
    }

    links = pref_link_entry->num_pref_links;
    for (i = 0; i < links; i++){
        nla_per_link_order = nla_nest_start(t2lm_event, i);
        if(nla_per_link_order == NULL) {
            t2lm_err("nla_link_order is null");
            return -EINVAL;
        }

        t2lm_debug("i:%d preffered_link_order:%d",
                   i, pref_link_entry->preffered_link_order[i]);

        if (nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_QUALIFIER_ORDER,
                       pref_link_entry->preffered_link_order[i])){
            t2lm_err("QCA_WLAN_VENDOR_ATTR_PREFERENCE_ORDER put fail");
            return -EINVAL;
        }
        nla_nest_end(t2lm_event, nla_per_link_order);
    }

    nla_nest_end(t2lm_event, nla_link_order);

    nla_timeout = nla_nest_start(t2lm_event,
                                 QCA_WLAN_VENDOR_ATTR_LINK_QUALIFIER_TIMEOUT);
    if (nla_timeout == NULL) {
        t2lm_err("nla_timeout fail nla is null");
        return -EINVAL;
    }

    for (i = 0; i < WIFI_AC_MAX && links; i++){
        nla_per_timeout = nla_nest_start(t2lm_event, i);
        if(nla_per_timeout == NULL) {
            t2lm_err("nla_timeout fail nla is null");
            return -EINVAL;
        }

        t2lm_debug("i:%d timeout:%d", i, pref_link_entry->timeout[i]);

        if (nla_put_u32(t2lm_event, QCA_WLAN_VENDOR_ATTR_TIMEOUT,
                        pref_link_entry->timeout[i])){
            t2lm_err("QCA_WLAN_VENDOR_ATTR_TIMEOUT put fail");
            return -EINVAL;
        }
        nla_nest_end(t2lm_event, nla_per_timeout);
    }

    nla_nest_end(t2lm_event, nla_timeout);
    nla_nest_end(t2lm_event, nla_pref_link_entry);
    nla_nest_end(t2lm_event, nla_pref_info);
    return 0;
}

int wlan_cfg80211_send_t2lm_teardown_event(struct peer_t2lm_tear_down *tear_down_event,
        struct wlan_objmgr_peer *peer)
{
    struct sk_buff *t2lm_event;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct pdev_osif_priv *osif_priv = NULL;
    struct ieee80211com *ic = NULL;
    struct net_device *netdev = NULL;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
#endif
    struct nlattr *nla_link_entry, *nla_per_link_entry;
    uint32_t len = 0;
    int i = 0;
    struct wlan_objmgr_pdev *pdev = NULL;
    struct mld_peer_link_entry  *link_info;
    int ret;

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    pdev = wlan_vdev_get_pdev(wlan_peer_get_vdev(peer));
    if (!pdev) {
        t2lm_err("pdev is NULL");
        return -EINVAL;
    }

    osif_priv = wlan_pdev_get_ospriv(pdev);
    if (!osif_priv) {
        t2lm_err("PDEV OS private structure is NULL");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)osif_priv->legacy_osif_priv;
    if (!scn) {
        t2lm_err("SCN is NULL");
        return -EINVAL;
    }

    ic = &scn->sc_ic;
    if (!ic) {
        t2lm_err("IC is NULL");
        return -EINVAL;
    }

    netdev = ic->ic_netdev;
    if (!netdev) {
        t2lm_err("Net device is NULL");
        return -EINVAL;
    }

    len = get_peer_t2lm_event_data_len();

    /* Allocate vendor event for T2LM */
    t2lm_event =
        wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, netdev->ieee80211_ptr,
                len,
                QCA_NL80211_VENDOR_SUBCMD_PEER_T2LM_POLICY_INDEX,
                GFP_ATOMIC);
    if (!t2lm_event) {
        t2lm_err("cfg80211_vendor_event_alloc failed");
        return -ENOMEM;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(t2lm_event, ((void **)t2lm_event->cb)[2]);

    ret_val = nla_put_u32(t2lm_event,
            NL80211_ATTR_IFINDEX,
            netdev->ifindex);
    if (ret_val) {
        t2lm_err("NL80211_ATTR_IFINDEX put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }
    nla = nla_nest_start(t2lm_event, NL80211_ATTR_VENDOR_DATA);
    if(nla == NULL) {
        t2lm_err("nla_nest_start fail nla is NULL ");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }
    VENDOR_CMD_CB_ASSIGN(t2lm_event, nla);
#endif
    /* Fill disassoc event attributes */
    t2lm_debug("mld_mac_addr: " QDF_MAC_ADDR_FMT,
               QDF_MAC_ADDR_REF(tear_down_event->mld_mac_addr));

    if(nla_put(t2lm_event, QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLD_MAC,
                QDF_MAC_ADDR_SIZE, &tear_down_event->mld_mac_addr[0])) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLD_MAC put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    t2lm_debug("category:%d", tear_down_event->category);

    if (nla_put_u8(t2lm_event,
                QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_CATEGORY,
                tear_down_event->category)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_CATEGORY put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    t2lm_debug("num_links:%d", tear_down_event->num_links);

    if (nla_put_u8(t2lm_event,
                QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_NUM_LINKS,
                tear_down_event->num_links)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_NUM_LINKS put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }
    /* Nested attributes; array of MLD peers struct mld_peer_link_entry */
    nla_link_entry = nla_nest_start(t2lm_event,
        QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLO_PEER_LINK_ENTRY);
    if (nla_link_entry == NULL) {
        t2lm_err("nla_link_entry fail nla is NULL");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    for (i = 0; i < tear_down_event->num_links; i++) {
        nla_per_link_entry = nla_nest_start(t2lm_event, i);
        if (nla_per_link_entry == NULL) {
            t2lm_err("nla_per_link_entry fail nla is NULL");
            wlan_cfg80211_vendor_free_skb(t2lm_event);
            return -EINVAL;
        }
        /* fill individual attributes of link entry */
        link_info = &tear_down_event->peer_entry[i];
        t2lm_debug("i:%d hw_link_id:%d link_addr: " QDF_MAC_ADDR_FMT " is_assoc_link:%d",
                   i, link_info->hw_link_id,
                   QDF_MAC_ADDR_REF(link_info->link_addr),
                   link_info->is_assoc_link);

        if (nla_put_u16(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_HW_LINK_ID,
                    link_info->hw_link_id) ||
                nla_put(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_PEER_MAC, QDF_MAC_ADDR_SIZE,
                    &link_info->link_addr[0]) ||
                nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_IS_ASSOC_LINK,
                    link_info->is_assoc_link)) {
            t2lm_err(" put failed for nla_per_link_entry");
            wlan_cfg80211_vendor_free_skb(t2lm_event);
            return -EINVAL;
        }

        nla_nest_end(t2lm_event, nla_per_link_entry);
    }
    nla_nest_end(t2lm_event, nla_link_entry);

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(t2lm_event, nla);
#endif

    ret = wlan_cfg80211_fill_preferred_link_attr(t2lm_event,
                                                 &tear_down_event->preference_link);
    if (ret) {
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    t2lm_debug("Sent T2LM Event to application");
    wlan_cfg80211_vendor_event(t2lm_event, GFP_ATOMIC);
    return 0;
}

int wlan_cfg80211_send_peer_t2lm_event(struct peer_t2lm_policy_event *t2lm_policy,
        struct wlan_objmgr_peer *peer)
{
    struct sk_buff *t2lm_event;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct pdev_osif_priv *osif_priv = NULL;
    struct ieee80211com *ic = NULL;
    struct net_device *netdev = NULL;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
#endif
    struct nlattr *nla_link_entry, *nla_per_link_entry;
    struct nlattr *nla_t2lm_info, *nla_per_direction_t2lm_info;
    struct nlattr *nla_peer_caps, *per_peer_caps_info;
    struct nlattr *tid_array, *tid_entry;
    struct wlan_t2lm_info *t2lm_info_entry;
    uint32_t len;
    int i = 0, idx = 0, tid_idx = 0, k = 0;
    struct wlan_objmgr_pdev *pdev = NULL;
    struct mld_peer_link_entry  *link_info;
    int ret = 0;

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    pdev = wlan_vdev_get_pdev(wlan_peer_get_vdev(peer));
    if (!pdev) {
        t2lm_err("pdev is NULL");
        return -EINVAL;
    }

    osif_priv = wlan_pdev_get_ospriv(pdev);
    if (!osif_priv) {
        t2lm_err("PDEV OS private structure is NULL");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)osif_priv->legacy_osif_priv;
    if (!scn) {
        t2lm_err("SCN is NULL");
        return -EINVAL;
    }

    ic = &scn->sc_ic;
    if (!ic) {
        t2lm_err("IC is NULL");
        return -EINVAL;
    }

    netdev = ic->ic_netdev;
    if (!netdev) {
        t2lm_err("Net device is NULL");
        return -EINVAL;
    }

    len = get_peer_t2lm_event_data_len();

    if (!osif_scn_event_filter_status_to_app(ic, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_PEER_T2LM_POLICY_INDEX)) {
        return QDF_STATUS_SUCCESS;
    }
    /* Allocate vendor event for T2LM */
    t2lm_event =
        wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, netdev->ieee80211_ptr,
                len,
                QCA_NL80211_VENDOR_SUBCMD_PEER_T2LM_POLICY_INDEX,
                GFP_ATOMIC);
    if (!t2lm_event) {
        t2lm_err("cfg80211_vendor_event_alloc failed");
        return -ENOMEM;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(t2lm_event, ((void **)t2lm_event->cb)[2]);

    ret_val = nla_put_u32(t2lm_event,
            NL80211_ATTR_IFINDEX,
            netdev->ifindex);
    if (ret_val) {
        t2lm_err("NL80211_ATTR_IFINDEX put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }
    nla = nla_nest_start(t2lm_event, NL80211_ATTR_VENDOR_DATA);
    if(nla == NULL) {
        t2lm_err("nla_nest_start fail nla is NULL ");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }
    VENDOR_CMD_CB_ASSIGN(t2lm_event, nla);
#endif
    /* Fill attributes of event */
    if(nla_put(t2lm_event, QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLD_MAC,
                QDF_MAC_ADDR_SIZE, &t2lm_policy->mld_mac_addr[0])) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLD_MAC put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    if (nla_put_u8(t2lm_event,
                QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_CATEGORY,
                t2lm_policy->category)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_CATEGORY put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    if (nla_put_u8(t2lm_event,
                QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_NUM_LINKS,
                t2lm_policy->num_links)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_NUM_LINKS put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    /* Nested attributes; array of MLD peers struct mld_peer_link_entry */
    nla_link_entry = nla_nest_start(t2lm_event,
        QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MLO_PEER_LINK_ENTRY);
    if (nla_link_entry == NULL) {
        t2lm_err("nla_link_entry fail nla is NULL");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    for (i = 0; i < t2lm_policy->num_links; i++) {

        nla_per_link_entry = nla_nest_start(t2lm_event, i);
        if (nla_per_link_entry == NULL) {
            t2lm_err("nla_per_link_entry fail nla is NULL");
            wlan_cfg80211_vendor_free_skb(t2lm_event);
            return -EINVAL;
        }
        /* fill individual attributes of link entry */
        link_info = &t2lm_policy->link_entry[i];

        if (nla_put_u16(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_HW_LINK_ID,
                link_info->hw_link_id) ||
            nla_put(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_PEER_MAC, QDF_MAC_ADDR_SIZE,
                &link_info->link_addr[0]) ||
            nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_MLO_LINK_ID,
                link_info->ieee_link_id) ||
            nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_IS_ASSOC_LINK,
                link_info->is_assoc_link) ||
            nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_CHAN_BW,
                link_info->chan_bw) ||
            nla_put_u16(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_CHAN_FREQ,
                link_info->chan_freq) ||
            nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_RSSI,
                link_info->link_rssi) ||
            nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_BAND_CAP,
                link_info->band_cap) ||
            nla_put_u16(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_EFF_CHAN_BW,
                link_info->eff_chan_bw) ||
            nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_VDEV_ID,
                link_info->vdev_id) ||
            nla_put(t2lm_event, QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_AP_MLD_MAC,QDF_MAC_ADDR_SIZE,
                &link_info->ap_mld_addr[0])

            ) {
                t2lm_err(" put failed for nla_per_link_entry");
                wlan_cfg80211_vendor_free_skb(t2lm_event);
                return -EINVAL;
            }

        nla_peer_caps = nla_nest_start(t2lm_event,
                QCA_WLAN_VENDOR_ATTR_MLO_PEER_LINK_EHT_PEER_CAPS);
        if (nla_peer_caps == NULL) {
            t2lm_err("nla_peer_caps fail nla is NULL");
            wlan_cfg80211_vendor_free_skb(t2lm_event);
            return -EINVAL;
        }

        for (idx = 0; idx < QCA_WLAN_VENDOR_EHTCAP_TXRX_MCS_NSS_IDX_MAX; idx++) {

            per_peer_caps_info = nla_nest_start(t2lm_event, idx);
            if (per_peer_caps_info == NULL) {
                t2lm_err("per_peer_caps_info fail nla is NULL");
                wlan_cfg80211_vendor_free_skb(t2lm_event);
                return -EINVAL;
            }

            if (nla_put_u32(t2lm_event, QCA_WLAN_VENDOR_ATTR_EHTCAP_RX_MCS_NSS_MAP,
                        link_info->caps.rx_mcs_nss_map[idx])) {
                t2lm_err(" put failed for QCA_WLAN_VENDOR_ATTR_EHTCAP_RX_MCS_NSS_MAP");
                wlan_cfg80211_vendor_free_skb(t2lm_event);
                return -EINVAL;
            }

            if (nla_put_u32(t2lm_event, QCA_WLAN_VENDOR_ATTR_EHTCAP_TX_MCS_NSS_MAP,
                        link_info->caps.tx_mcs_nss_map[idx])) {
                t2lm_err(" put failed for QCA_WLAN_VENDOR_ATTR_EHTCAP_TX_MCS_NSS_MAP");
                wlan_cfg80211_vendor_free_skb(t2lm_event);
                return -EINVAL;
            }

            nla_nest_end(t2lm_event, per_peer_caps_info);
        }

        nla_nest_end(t2lm_event, nla_peer_caps);
        nla_nest_end(t2lm_event, nla_per_link_entry);
    }

    nla_nest_end(t2lm_event, nla_link_entry);

    nla_t2lm_info = nla_nest_start(t2lm_event,
            QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_T2LM_INFO);
    if (nla_t2lm_info == NULL) {
        t2lm_err("nla_t2lm_info fail nla is NULL");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    for (i = 0, k = 0; i < WLAN_T2LM_BIDI_DIRECTION; i++) {
        if (t2lm_policy->t2lm_info[i].direction == WLAN_T2LM_INVALID_DIRECTION)
            continue;

        nla_per_direction_t2lm_info = nla_nest_start(t2lm_event, k);
        if (nla_per_direction_t2lm_info == NULL) {
            t2lm_err("nla_per_direction_t2lm_info fail nla is NULL");
            wlan_cfg80211_vendor_free_skb(t2lm_event);
            return -EINVAL;
        }
        t2lm_info_entry = &t2lm_policy->t2lm_info[i];

        if (nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_T2LM_DIRECTION,
                    convert_t2lm_direction_internal_to_nl80211(t2lm_info_entry->direction)) ||
                nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_T2LM_DEFAULT_LINK_MAPPING,
                    t2lm_info_entry->default_link_mapping)) {
            t2lm_err(" put failed for nla_per_direction_t2lm_info");
            wlan_cfg80211_vendor_free_skb(t2lm_event);
            return -EINVAL;
        }

        tid_array = nla_nest_start(t2lm_event,
                QCA_WLAN_VENDOR_ATTR_T2LM_PROVISIONED_LINKS);
         if (tid_array == NULL) {
            t2lm_err("tid_array fail nla is NULL");
            wlan_cfg80211_vendor_free_skb(t2lm_event);
            return -EINVAL;
        }

        for (tid_idx = 0; tid_idx < T2LM_MAX_NUM_TIDS; tid_idx++) {
            tid_entry = nla_nest_start(t2lm_event, tid_idx);
            if (tid_entry == NULL) {
                t2lm_err("tid_array fail nla is NULL");
                wlan_cfg80211_vendor_free_skb(t2lm_event);
                return -EINVAL;
            }
            if (nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_TID_MAP, t2lm_info_entry->ieee_link_map_tid[tid_idx])) {
                t2lm_err(" put failed for QCA_WLAN_VENDOR_ATTR_T2LM_PROVISIONED_LINKS");
                wlan_cfg80211_vendor_free_skb(t2lm_event);
                return -EINVAL;
            }
            nla_nest_end(t2lm_event, tid_entry);
        }
        nla_nest_end(t2lm_event, tid_array);

        nla_nest_end(t2lm_event, nla_per_direction_t2lm_info);
        k++;
    }
    nla_nest_end(t2lm_event, nla_t2lm_info);

    if (nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_TX_STATUS,
                convert_t2lm_tx_status_internal_to_nl80211(t2lm_policy->t2lm_tx_status))) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_TX_STATUS put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    if (nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MAPPING,
                t2lm_policy->t2lm_mapping)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MAPPING put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }
    if (nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_RESPONSE_TYPE,
                convert_t2lm_resp_frm_type_internal_to_nl80211(t2lm_policy->t2lm_resp_status))) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_RESPONSE_TYPE put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }
    if (nla_put_u8(t2lm_event, QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_DIALOG_TOKEN,
                t2lm_policy->dialog_token)) {
        t2lm_err("QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_DIALOG_TOKEN put fail");
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

    ret = wlan_cfg80211_fill_preferred_link_attr(t2lm_event,
            &t2lm_policy->preference_link);
    if (ret) {
        wlan_cfg80211_vendor_free_skb(t2lm_event);
        return -EINVAL;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(t2lm_event, nla);
#endif
    t2lm_debug("Sent T2LM Event to application");
    wlan_cfg80211_vendor_event(t2lm_event, GFP_ATOMIC);
    return 0;
}
#endif /* WLAN_FEATURE_11BE */

#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
#define WLAN_PASN_AUTH_KEY_INDEX 0
int wlan_cfg80211_set_pasn_key(struct wiphy *wiphy, struct wireless_dev *wdev,
                               struct nlattr **tb)
{
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_objmgr_peer *peer = NULL;
    wlan_if_t vap = NULL;
    ieee80211_keyval req_key;
    int error;
    uint32_t cipher;
    int cipher_len;
    uint8_t macaddr[6];
    bool is_ltf_keyseed_required = false;
    struct wlan_pasn_auth_status *pasn_status = NULL;
    uint8_t vdev_id = 0;
    QDF_STATUS status;

    vap = wlan_cfg80211_extract_vap_intf(wiphy, wdev, 0);
    if (!vap) {
        wifi_pos_err("null vap");
        return -EINVAL;
    }

    psoc = wlan_vdev_get_psoc(vap->vdev_obj);
    if (!psoc) {
        wifi_pos_err("null psoc");
        return -EINVAL;
    }

    vdev_id = wlan_vdev_get_id(vap->vdev_obj);

    qdf_mem_zero(&req_key, sizeof(ieee80211_keyval));

    if (!tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_CIPHER]) {
        wifi_pos_err("Missing cipher type");
        return -EINVAL;
    }

    /* Fill cipher type */
    cipher = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_CIPHER]);
    req_key.keytype = osif_nl_to_crypto_cipher_type(cipher);

    /* Fill cipher len*/
    cipher_len = osif_nl_to_crypto_cipher_len(cipher);
    req_key.keylen = nla_len(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_TK]);
    if ((cipher_len < 0) || (req_key.keylen < cipher_len) ||
        (req_key.keylen > (WLAN_CRYPTO_KEYBUF_SIZE + WLAN_CRYPTO_MICBUF_SIZE))) {
        wifi_pos_err("Invalid key length %d", req_key.keylen);
        return -EINVAL;
    }

    /* Fill TK */
    req_key.keydata = qdf_mem_malloc(req_key.keylen);
    if (!req_key.keydata) {
        wifi_pos_err("Could not allocate memory for TK");
        return -EINVAL;
    }

    qdf_mem_copy(req_key.keydata,
                 nla_data(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_TK]),
                 req_key.keylen);

    if (!tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_PEER_MAC_ADDR]) {
        wifi_pos_err("Peer mac address not present");
        qdf_mem_free(req_key.keydata);
        return -EINVAL;
    }

    /* Fill macaddr */
    qdf_mem_copy(macaddr,
            nla_data(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_PEER_MAC_ADDR]),
            QDF_MAC_ADDR_SIZE);
    req_key.macaddr = macaddr;

    wifi_pos_debug("Call wlan_set_key, vdev_id:%d  macaddr:%s", vdev_id, ether_sprintf(macaddr));
    error = wlan_set_key(vap, WLAN_PASN_AUTH_KEY_INDEX, &req_key);
    qdf_mem_free(req_key.keydata);
    if (error) {
        wifi_pos_err("Failed to set the PASN key");
        return error;
    }

    peer = wlan_objmgr_get_peer_by_mac(psoc, macaddr,
            WLAN_WIFI_POS_CORE_ID);
    if (!peer) {
        wifi_pos_err("PASN peer is not found");
        return -EFAULT;
    }

    /*
     * If LTF key seed is not required for the peer, then update
     * the source mac address for that peer by sending PASN auth
     * status command.
     * If LTF keyseed is required, then PASN Auth status command
     * will be sent after LTF keyseed command.
     */
    is_ltf_keyseed_required =
        ucfg_wifi_pos_is_ltf_keyseed_required_for_peer(peer);
    wlan_objmgr_peer_release_ref(peer, WLAN_WIFI_POS_CORE_ID);
    if (is_ltf_keyseed_required) {
        wifi_pos_debug("LTF keyseed is required, return");
        return 0;
    }

   if (!((vap->rtt_enable ==  RTT_INITIATOR_MODE) ||
              (vap->current_rtt_role == RTT_INITIATOR_MODE))) {
        wifi_pos_debug("Initiator mode is not enabled, return");
        return 0;
    }

    pasn_status = qdf_mem_malloc(sizeof(*pasn_status));
    if (!pasn_status) {
        wifi_pos_err("Failed to allocated memory for pasn auth status");
        return -ENOMEM;
    }

    pasn_status->vdev_id = vdev_id;
    pasn_status->num_peers = 1;

    qdf_mem_copy(pasn_status->auth_status[0].peer_mac.bytes,
            macaddr, QDF_MAC_ADDR_SIZE);

    if (tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_SRC_ADDR])
        qdf_mem_copy(pasn_status->auth_status[0].self_mac.bytes,
                nla_data(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_SRC_ADDR]),
                QDF_MAC_ADDR_SIZE);

    wifi_pos_debug("Call wifi_pos_send_pasn_auth_status");
    status = wifi_pos_send_pasn_auth_status(psoc, pasn_status);
    if (QDF_IS_STATUS_ERROR(status))
        wifi_pos_err("Send PASN auth status failed");

    qdf_mem_free(pasn_status);

    return qdf_status_to_os_return(status);
}

static int wlan_cfg80211_send_set_ltf_keyseed(struct wiphy *wiphy,
                                              struct wireless_dev *wdev,
                                              struct nlattr **tb)
{
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_crypto_ltf_keyseed_data *data = NULL;
    bool is_ltf_keyseed_required = false;
    struct wlan_pasn_auth_status *pasn_auth_status = NULL;
    struct wlan_objmgr_peer *peer = NULL;
    wlan_if_t vap = NULL;
    uint8_t vdev_id = 0;
    QDF_STATUS status = QDF_STATUS_SUCCESS;
    int ret;

    vap = wlan_cfg80211_extract_vap_intf(wiphy, wdev, 0);
    if (!vap) {
        wifi_pos_err("null vap");
        return -EINVAL;
    }

    vdev_id = wlan_vdev_get_id(vap->vdev_obj);
    wifi_pos_debug("Entry: vdev_id:%d", vdev_id);

    psoc = wlan_vdev_get_psoc(vap->vdev_obj);
    if (!psoc) {
        wifi_pos_err("null psoc");
        return -EINVAL;
    }

    data = qdf_mem_malloc(sizeof(*data));
    if (!data) {
        wifi_pos_err("Failed to allocate memory for LTF keyseed");
        return -ENOMEM;
    }

    data->vdev_id = vdev_id;

    if (!tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_PEER_MAC_ADDR]) {
        wifi_pos_err("BSSID is not present");
        ret = -EINVAL;
        goto err;
    }

    qdf_mem_copy(data->peer_mac_addr.bytes,
            nla_data(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_PEER_MAC_ADDR]),
            QDF_MAC_ADDR_SIZE);

    if (tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_SRC_ADDR])
        qdf_mem_copy(data->src_mac_addr.bytes,
                nla_data(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_SRC_ADDR]),
                QDF_MAC_ADDR_SIZE);

    data->key_seed_len =
        nla_len(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_LTF_KEYSEED]);

    if (!data->key_seed_len ||
        (data->key_seed_len < WLAN_MIN_SECURE_LTF_KEYSEED_LEN) ||
        (data->key_seed_len > WLAN_MAX_SECURE_LTF_KEYSEED_LEN)) {
        wifi_pos_err("Invalid key seed length:%d", data->key_seed_len);
        ret = -EINVAL;
        goto err;
    }

    qdf_mem_copy(data->key_seed,
            nla_data(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_LTF_KEYSEED]),
            data->key_seed_len);

    wifi_pos_debug("Call wlan_crypto_set_ltf_keyseed, macaddr:%s",
                   ether_sprintf(data->src_mac_addr.bytes));
    status = wlan_crypto_set_ltf_keyseed(psoc, data);
    if (QDF_IS_STATUS_ERROR(status)) {
        wifi_pos_err("Set LTF Keyseed failed");
        ret = qdf_status_to_os_return(status);
        goto err;
    }

    peer = wlan_objmgr_get_peer_by_mac(psoc, data->peer_mac_addr.bytes,
            WLAN_WIFI_POS_CORE_ID);
    if (!peer) {
        wifi_pos_err("PASN peer is not found");
        ret = -EFAULT;
        goto err;
    }

    /*
     * If LTF key seed is not required for the peer, then update
     * the source mac address for that peer by sending PASN auth
     * status command.
     * If LTF keyseed is required, then PASN Auth status command
     * will be sent after LTF keyseed command.
     */
    is_ltf_keyseed_required =
        ucfg_wifi_pos_is_ltf_keyseed_required_for_peer(peer);
    wlan_objmgr_peer_release_ref(peer, WLAN_WIFI_POS_CORE_ID);

    if (!is_ltf_keyseed_required) {
        ret = 0;
        wifi_pos_debug("LTF keyseed is not required, return");
        goto err;
    }

    if (!((vap->rtt_enable ==  RTT_INITIATOR_MODE) ||
               (vap->current_rtt_role == RTT_INITIATOR_MODE))) {
        ret = 0;
        wifi_pos_debug("Initiator mode is not enabled, return");
        goto err;
    }

    /*
     * Send PASN Auth status followed by SET LTF keyseed command to
     * set the peer as authorized at firmware and firmware will start
     * ranging after this.
     */
    pasn_auth_status = qdf_mem_malloc(sizeof(*pasn_auth_status));
    if (!pasn_auth_status) {
        wifi_pos_err("Failed to allocated memory for pasn auth status");
        ret = -ENOMEM;
        goto err;
    }

    pasn_auth_status->vdev_id = vdev_id;
    pasn_auth_status->num_peers = 1;
    qdf_mem_copy(pasn_auth_status->auth_status[0].peer_mac.bytes,
            data->peer_mac_addr.bytes, QDF_MAC_ADDR_SIZE);
    qdf_mem_copy(pasn_auth_status->auth_status[0].self_mac.bytes,
            data->src_mac_addr.bytes, QDF_MAC_ADDR_SIZE);

    wifi_pos_debug("Call wifi_pos_send_pasn_auth_status, peer_mac:" QDF_MAC_ADDR_FMT " self_mac: " QDF_MAC_ADDR_FMT,
            QDF_MAC_ADDR_REF(pasn_auth_status->auth_status[0].peer_mac.bytes),
            QDF_MAC_ADDR_REF(pasn_auth_status->auth_status[0].self_mac.bytes));
    status = wifi_pos_send_pasn_auth_status(psoc, pasn_auth_status);
    if (QDF_IS_STATUS_ERROR(status))
        wifi_pos_err("Send PASN auth status failed");

    qdf_mem_free(pasn_auth_status);
    ret = qdf_status_to_os_return(status);

err:
    qdf_mem_free(data);
    return ret;
}

static int wlan_cfg80211_create_pasn_peer(struct wiphy *wiphy,
        struct wireless_dev *wdev, const void *data, int data_len)
{
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_pasn_request *pasn_req;
    struct ieee80211vap *vap = NULL;
    uint8_t vdev_id;
    uint8_t macaddr[6];
    uint8_t total_entries = 1;
    struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_MAX + 1];
    struct nlattr *tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAX + 1];
    struct nlattr *curr_attr;
    QDF_STATUS status = QDF_STATUS_SUCCESS;
    int rem;

    vap = wlan_cfg80211_extract_vap_intf(wiphy, wdev, 0);
    if (!vap) {
        wifi_pos_err("null vap");
        return -EINVAL;
    }

    psoc = wlan_vdev_get_psoc(vap->vdev_obj);
    if (!psoc) {
        wifi_pos_err("null psoc");
        return -EINVAL;
    }

    if (wlan_cfg80211_nla_parse(tb,QCA_WLAN_VENDOR_ATTR_MAX,
                data, data_len, wlan_cfg80211_create_delete_pasn_auth_status_policy)) {
        wifi_pos_err("Invalid create/delete pasn peer attributes");
        return -EINVAL;
    }

    if (!tb[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEERS]) {
        wifi_pos_err("No pasn peer");
        return -EINVAL;
    }

    pasn_req = qdf_mem_malloc(sizeof(*pasn_req));
    if (!pasn_req) {
        wifi_pos_err("Failed to allocate memory for pasn data");
        return -ENOMEM;
    }

    vdev_id = wlan_vdev_get_id(vap->vdev_obj);

    nla_for_each_nested(curr_attr, tb[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEERS], rem) {
        if (wlan_cfg80211_nla_parse_nested(tb2,QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAX,
                    curr_attr, wlan_cfg80211_create_delete_pasn_auth_policy)) {
            wifi_pos_err("Invalid create pasn peer attributes");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }

        if (!tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAC_ADDR]) {
            wifi_pos_err("Peer mac address not present");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }

        qdf_mem_copy(macaddr,
                nla_data(tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAC_ADDR]),
                QDF_MAC_ADDR_SIZE);

        if (qdf_is_macaddr_zero((struct qdf_mac_addr *)macaddr)) {
            wifi_pos_err("peer mac address invalid/all zero");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }

        qdf_mem_copy(pasn_req->peer_mac.bytes, macaddr, QDF_MAC_ADDR_SIZE);

        if (!tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_TYPE]) {
            wifi_pos_err("Peer type not present");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }

        pasn_req->peer_type = nla_get_u32(tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_TYPE]);

        if (pasn_req->peer_type != WLAN_WIFI_POS_PASN_UNSECURE_PEER && pasn_req->peer_type != WLAN_WIFI_POS_PASN_SECURE_PEER) {
            wifi_pos_err("peer type invalid");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }

        pasn_req->is_ltf_keyseed_required = nla_get_flag(
                tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_LTF_KEYSEED_REQUIRED]);

        if (pasn_req->is_ltf_keyseed_required && pasn_req->peer_type == WLAN_WIFI_POS_PASN_UNSECURE_PEER) {
            wifi_pos_err("LTF keyseed is not required for unsecure ranging");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }
    }

    wifi_pos_debug("Call wifi_pos_handle_ranging_peer_create");
    status = wifi_pos_handle_ranging_peer_create(psoc, pasn_req, vdev_id, total_entries);
    if (QDF_IS_STATUS_ERROR(status))
        wifi_pos_err("Send ranging peer create failed");

    qdf_mem_free(pasn_req);
    return qdf_status_to_os_return(status);
}

static int wlan_cfg80211_delete_pasn_peer(struct wiphy *wiphy,
        struct wireless_dev *wdev, const void *data, int data_len)
{
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_pasn_request *pasn_req;
    struct ieee80211vap *vap = NULL;
    uint8_t vdev_id;
    uint8_t macaddr[6];
    uint8_t total_entries = 1;
    struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_MAX + 1];
    struct nlattr *tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAX + 1];
    struct nlattr *curr_attr;
    QDF_STATUS status = QDF_STATUS_SUCCESS;
    int rem;

    vap = wlan_cfg80211_extract_vap_intf(wiphy, wdev, 0);
    if (!vap) {
        wifi_pos_err("null vap");
        return -EINVAL;
    }

    psoc = wlan_vdev_get_psoc(vap->vdev_obj);
    if (!psoc) {
        wifi_pos_err("null psoc");
        return -EINVAL;
    }

    if (wlan_cfg80211_nla_parse(tb,QCA_WLAN_VENDOR_ATTR_MAX,
                data, data_len, wlan_cfg80211_create_delete_pasn_auth_status_policy)) {
        wifi_pos_err("Invalid create/delete pasn peer attributes");
        return -EINVAL;
    }

    if (!tb[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEERS]) {
        wifi_pos_err("no pasn peer");
        return -EINVAL;
    }

    pasn_req = qdf_mem_malloc(sizeof(*pasn_req));
    if (!pasn_req) {
        wifi_pos_err("Failed to allocate memory for pasn data");
        return -ENOMEM;
    }

    vdev_id = wlan_vdev_get_id(vap->vdev_obj);

    nla_for_each_nested(curr_attr, tb[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEERS], rem) {
        if (wlan_cfg80211_nla_parse_nested(tb2,QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAX,
                    curr_attr, wlan_cfg80211_create_delete_pasn_auth_policy)) {
            wifi_pos_err("Invalid delete pasn peer attributes");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }

        if (!tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAC_ADDR]) {
            wifi_pos_err("Peer mac address not present");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }

        qdf_mem_copy(macaddr,
                nla_data(tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_MAC_ADDR]),
                QDF_MAC_ADDR_SIZE);

        if (qdf_is_macaddr_zero((struct qdf_mac_addr *)macaddr)) {
            wifi_pos_err("peer mac address invalid/all zero");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }

        qdf_mem_copy(pasn_req->peer_mac.bytes, macaddr, QDF_MAC_ADDR_SIZE);

        if (!tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_CONTROL_FLAG]) {
            wifi_pos_err("NO delete pasn peer control flag");
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }

        pasn_req->control_flags = nla_get_u16(tb2[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_PEER_CONTROL_FLAG]);
        if (pasn_req->control_flags != WIFI_POS_PEER_DELETE_ACTION_ALREADY_DELETED && pasn_req->control_flags != WIFI_POS_PEER_DELETE_ACTION_FLUSH_KEYS) {
            wifi_pos_err(" Invalid control flag value" );
            qdf_mem_free(pasn_req);
            return -EINVAL;
        }
    }

    wifi_pos_debug("Call wifi_pos_handle_ranging_peer_delete");
    status = wifi_pos_handle_ranging_peer_delete(psoc, pasn_req, vdev_id, total_entries);
    if (QDF_IS_STATUS_ERROR(status))
        wifi_pos_err("Send ranging peer delete failed");

    qdf_mem_free(pasn_req);

    return qdf_status_to_os_return(status);
}

static int wlan_cfg80211_set_secure_ranging_context(struct wiphy *wiphy,
        struct wireless_dev *wdev, const void *data, int data_len)
{
    struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_MAX + 1];
    int ret =0;
    struct qdf_mac_addr peer_mac;
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_objmgr_peer *peer;
    wlan_if_t vap = NULL;

    if (wlan_cfg80211_nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_MAX,
                data, data_len, wlan_cfg80211_pasn_set_ranging_ctx_policy)) {
        wifi_pos_err("Invalid secure ranging attributes");
        return -EINVAL;
    }

    if (!tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_ACTION]) {
        wifi_pos_err("Action attribute is missing");
        return -EINVAL;
    }

    if (nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_ACTION]) ==
            QCA_WLAN_VENDOR_SECURE_RANGING_CTX_ACTION_ADD) {
        if (tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_TK] &&
                nla_len(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_TK])) {
            ret = wlan_cfg80211_set_pasn_key(wiphy, wdev, tb);
            if (ret)
                return ret;
        }

        if (tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_LTF_KEYSEED] &&
                nla_len(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_LTF_KEYSEED])) {
            ret = wlan_cfg80211_send_set_ltf_keyseed(wiphy, wdev, tb);
            if (ret)
                return ret;
        }
    } else if (nla_get_u32(
            tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_ACTION]) ==
            QCA_WLAN_VENDOR_SECURE_RANGING_CTX_ACTION_DELETE) {
        if (!tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_PEER_MAC_ADDR]) {
            wifi_pos_err("Peer mac address attribute is missing");
            return -EINVAL;
        }

        vap = wlan_cfg80211_extract_vap_intf(wiphy, wdev, 0);
        if (!vap) {
            wifi_pos_err("null vap");
            return -EINVAL;
        }

        psoc = wlan_vdev_get_psoc(vap->vdev_obj);
        if (!psoc) {
            wifi_pos_err("null psoc");
            return -EINVAL;
        }

        qdf_mem_copy(peer_mac.bytes,
                     nla_data(tb[QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_PEER_MAC_ADDR]),
                     QDF_MAC_ADDR_SIZE);

        peer = wlan_objmgr_get_peer_by_mac(psoc, peer_mac.bytes, WLAN_WIFI_POS_CORE_ID);
        if (!peer) {
            wifi_pos_debug("PASN peer is not found");
            return -EINVAL;
        }

        wifi_pos_debug("Send PASN peer deauth" QDF_MAC_ADDR_FMT,
                       QDF_MAC_ADDR_REF(peer_mac.bytes));

        wifi_pos_send_pasn_peer_deauth(psoc, &peer_mac);

        wlan_objmgr_peer_release_ref(peer, WLAN_WIFI_POS_CORE_ID);
    }

    return ret;
}

static int wlan_cfg80211_send_pasn_auth_status(struct wiphy *wiphy,
        struct wireless_dev *wdev, const void *data, int data_len)
{
    struct wlan_objmgr_psoc *psoc = NULL;
    struct wlan_pasn_auth_status *pasn_data;
    struct ieee80211vap *vap = NULL;
    struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_MAX + 1];
    struct nlattr *tb2[QCA_WLAN_VENDOR_ATTR_PASN_PEER_MAX + 1];
    struct nlattr *curr_attr;
    QDF_STATUS status = QDF_STATUS_SUCCESS;
    bool is_pasn_success = false;
    int ret, i = 0, rem;

    vap = wlan_cfg80211_extract_vap_intf(wiphy, wdev, 0);
    if (!vap) {
        wifi_pos_err("null vap");
        return -1;
    }

    if (!((vap->rtt_enable ==  RTT_INITIATOR_MODE) ||
                (vap->current_rtt_role == RTT_INITIATOR_MODE))) {
        wifi_pos_debug("Initiator mode is not enabled, return");
        return 0;
    }

    psoc = wlan_vdev_get_psoc(vap->vdev_obj);
    if (!psoc) {
        wifi_pos_err("null psoc");
        return -1;
    }

    if (wlan_cfg80211_nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX,
                data, data_len,
                wlan_cfg80211_pasn_auth_status_policy)) {
        wifi_pos_err("Invalid PASN auth status attributes");
        return -EINVAL;
    }

    if (!tb[QCA_WLAN_VENDOR_ATTR_PASN_PEERS]) {
        wifi_pos_err("No PASN peer");
        return -EINVAL;
    }

    pasn_data = qdf_mem_malloc(sizeof(*pasn_data));
    if (!pasn_data) {
        wifi_pos_err("Failed to allocate memory for pasn data");
        return -ENOMEM;
    }

    pasn_data->vdev_id = wlan_vdev_get_id(vap->vdev_obj);
    nla_for_each_nested(curr_attr, tb[QCA_WLAN_VENDOR_ATTR_PASN_PEERS], rem) {
        if (wlan_cfg80211_nla_parse_nested(
                    tb2, QCA_WLAN_VENDOR_ATTR_PASN_PEER_MAX, curr_attr,
                    wlan_cfg80211_pasn_auth_policy)) {
            wifi_pos_err("nla_parse failed");
            qdf_mem_free(pasn_data);
            return -EINVAL;
        }

        is_pasn_success = nla_get_flag(
                tb2[QCA_WLAN_VENDOR_ATTR_PASN_PEER_STATUS_SUCCESS]);
        if (!is_pasn_success)
            pasn_data->auth_status[i].status =
                WLAN_PASN_AUTH_STATUS_PASN_FAILED;

        wifi_pos_debug("vdev_id:%d PASN auth status:%d", pasn_data->vdev_id, pasn_data->auth_status[i].status);

        if (tb2[QCA_WLAN_VENDOR_ATTR_PASN_PEER_MAC_ADDR]) {
            nla_memcpy(pasn_data->auth_status[i].peer_mac.bytes,
                    tb2[QCA_WLAN_VENDOR_ATTR_PASN_PEER_MAC_ADDR],
                    QDF_MAC_ADDR_SIZE);
            wifi_pos_debug("Peer mac[%d]: " QDF_MAC_ADDR_FMT, i,
                    QDF_MAC_ADDR_REF(pasn_data->auth_status[i].peer_mac.bytes));
        }

        if (tb2[QCA_WLAN_VENDOR_ATTR_PASN_PEER_SRC_ADDR]) {
            nla_memcpy(pasn_data->auth_status[i].self_mac.bytes,
                    tb2[QCA_WLAN_VENDOR_ATTR_PASN_PEER_SRC_ADDR],
                    QDF_MAC_ADDR_SIZE);
            wifi_pos_debug("Src addr[%d]: " QDF_MAC_ADDR_FMT, i,
                    QDF_MAC_ADDR_REF(pasn_data->auth_status[i].self_mac.bytes));
        }

        i++;
        pasn_data->num_peers++;
        if (pasn_data->num_peers >= WLAN_MAX_11AZ_PEERS) {
            wifi_pos_err("Invalid num_peers:%d", pasn_data->num_peers);
            qdf_mem_free(pasn_data);
            return -EINVAL;
        }
    }

    wifi_pos_debug("Call wifi_pos_send_pasn_auth_status");
    status = wifi_pos_send_pasn_auth_status(psoc, pasn_data);
    if (QDF_IS_STATUS_ERROR(status))
        wifi_pos_err("Send pasn auth status failed");

    qdf_mem_free(pasn_data);
    ret = qdf_status_to_os_return(status);

    return ret;
}

static int wlan_cfg80211_handle_pasn(struct wiphy *wiphy,
        struct wireless_dev *wdev, const void *data, int data_len)
{
    struct wlan_objmgr_psoc *psoc = NULL;
    struct ieee80211vap *vap = NULL;
    struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_MAX + 1];
    int ret = 0;

    vap = wlan_cfg80211_extract_vap_intf(wiphy, wdev, 0);
    if (!vap) {
        wifi_pos_err("null vap");
        return -EINVAL;
    }

    psoc = wlan_vdev_get_psoc(vap->vdev_obj);
    if (!psoc) {
        wifi_pos_err("null psoc");
        return -EINVAL;
    }

    if (wlan_cfg80211_nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX,
                data, data_len,
                wlan_cfg80211_create_delete_pasn_auth_status_policy)) {
        wifi_pos_err("Invalid PASN auth status/create/delete attributes");
        return -EINVAL;
    }

    if (!tb[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_ACTION]) {
        wifi_pos_debug("call wlan_cfg80211_send_pasn_auth_status");
        return wlan_cfg80211_send_pasn_auth_status(wiphy, wdev, data, data_len);
    }

    if (nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_ACTION]) ==
            QCA_WLAN_VENDOR_PASN_CREATE_DELETE_ACTION_PEER_CREATE) {
        wifi_pos_debug("call wlan_cfg80211_create_pasn_peer");
        return wlan_cfg80211_create_pasn_peer(wiphy, wdev, data, data_len);
    }

    if (nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_CREATE_DELETE_PASN_ACTION]) ==
            QCA_WLAN_VENDOR_PASN_CREATE_DELETE_ACTION_PEER_DELETE) {
        wifi_pos_debug("call wlan_cfg80211_delete_pasn_peer");
        return wlan_cfg80211_delete_pasn_peer(wiphy, wdev, data, data_len);
    }

    return ret;
}

#ifdef CONFIG_2G_5G_WIDEBAND_SUPPPORT
static void
wlan_cfg80211_set_feature_flags(struct ieee80211com *ic,
                                uint8_t *feature_flags,
                                enum qca_wlan_vendor_features feature)
{
    uint32_t index;
    uint8_t bit_mask;

    index = feature / BITS_IN_A_BYTE;
    bit_mask = 1 << (feature % BITS_IN_A_BYTE);
    feature_flags[index] |= bit_mask;
    IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD,
                         IEEE80211_MSG_CFG80211,
                         "feature_flag: %x\n",  feature_flags[index]);
}
#endif

/**
 * wlan_cfg80211_get_features() - Get the Driver Supported features
 * @wiphy:   pointer to wireless wiphy structure.
 * @wdev:    pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * This is called when wlan driver needs to send supported feature set to
 * supplicant upon a request/query from the supplicant.
 *
 * Return:   Return the Success or Failure code.
 */
static int
wlan_cfg80211_get_features(struct wiphy *wiphy, struct wireless_dev *wdev,
                           const void *data, int data_len)
{
    struct ieee80211com *ic = NULL;
    struct wlan_objmgr_psoc *psoc = NULL;
    struct sk_buff *skb = NULL;
    uint8_t feature_flags[(NUM_QCA_WLAN_VENDOR_FEATURES + 7) / 8] = {0};
    QDF_STATUS status;
    struct ol_ath_softc_net80211 *scn = NULL;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    scn = (struct ol_ath_softc_net80211 *)ic;

    if (!ic) {
        qdf_err("null ic");
        return -EINVAL;
    }

    if (scn->soc->sc_in_delete) {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD,
                          IEEE80211_MSG_CFG80211,
                          "Delete in Progress - Can't get supported features");
        return -EBUSY;
    }

    if (ic->recovery_in_progress) {
        return -EBUSY;
    }

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if (!psoc) {
        qdf_err("null psoc");
        return -EINVAL;
    }

    if (!ic->ic_is_target_lithium(psoc)) {
        qdf_err("non lithium target, return");
        return -EINVAL;
    }

#ifdef CONFIG_2G_5G_WIDEBAND_SUPPPORT
    if ((ic->ic_supported_bands & WMI_HOST_WLAN_5G_CAPABILITY) &&
        (ic->ic_supported_bands & WMI_HOST_WLAN_2G_CAPABILITY))
        wlan_cfg80211_set_feature_flags(ic, feature_flags,
                                        QCA_WLAN_VENDOR_FEATURE_SUPPORT_HW_MODE_ANY);
#endif

    wlan_wifi_pos_cfg80211_set_features(psoc, feature_flags);

    skb = wlan_cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
            sizeof(feature_flags) + NLMSG_HDRLEN);
    if (!skb) {
        qdf_err("wlan_cfg80211_vendor_cmd_alloc_reply_skb failed");
        return -ENOMEM;
    }

    if (nla_put(skb, QCA_WLAN_VENDOR_ATTR_FEATURE_FLAGS, sizeof(feature_flags),
                feature_flags)) {
        wlan_cfg80211_vendor_free_skb(skb);
        return -EINVAL;
    }

    status = wlan_cfg80211_qal_devcfg_send_response((qdf_nbuf_t)skb);
    return qdf_status_to_os_return(status);
}
#endif

#ifdef WLAN_SUPPORT_SCS
/**
 * wlan_cfg80211_parse_scs_rule_config_resp() - API to parse scs_config_resp
 *                                              from scs_tool
 * Return: 0 on success and errno on failure
 */
static int  wlan_cfg80211_parse_scs_rule_config_resp(struct wiphy *wiphy,
                                                     struct wireless_dev *wdev,
                                                     const void *data,
                                                     int data_len)
{
    uint32_t rule_id = 0;
    struct ieee80211com *ic = NULL;
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_MAX + 1] = {0};

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_MAX,
                                data, data_len, scs_config_resp_rule_id_policy))
    {
       scs_err("Failed Parsing request!");
       return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_RULE_ID])
        rule_id = nla_get_u32(attr[QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_RULE_ID]);

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
    if (!ic) {
        scs_err("Invalid interface");
        return -EINVAL;
    }

    ieee80211_scs_clear_stream(ic, rule_id);

    return 0;
}

#ifdef WLAN_SUPPORT_SCS_API
static const struct nla_policy
qca_wlan_vendor_scs_api_policy[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX + 1] = {
        [QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TYPE] = {.type = NLA_U8 },
        [QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_PEER_MAC] = {.type = NLA_BINARY,
                                               .len = QDF_MAC_ADDR_SIZE },
        [QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MLD_MAC] = {.type = NLA_BINARY,
                                               .len = QDF_MAC_ADDR_SIZE },
        [QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DIALOG_TOKEN] = {.type = NLA_U8 },
        [QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TOTAL_SCS_IDX] = {.type = NLA_U8 },
        [QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DATA] = {.type = NLA_BINARY },
};

static void
scs_api_format_and_copy_scs_params(struct ieee80211_scs_data *scs_data,
                                   struct scs_api_data *scs_temp)
{
    scs_data->scsid = scs_temp->scsid;
    scs_data->request_type = scs_temp->request_type;
    if (scs_data->request_type != SCS_API_SCS_REMOVE_RULE) {
        scs_data->access_priority = scs_temp->access_priority;
        scs_data->tclas_elements = scs_temp->tclas_elements;
    }
}

static void
scs_api_copy_tclas_type4_v4_params(struct ieee80211_scs_data *scs_data,
                                   struct scs_api_data *scs_temp,
                                   uint8_t tclas_idx)
{
    qdf_mem_copy(
       scs_data->tclas_tuple[tclas_idx].tclas.type4.src_ip.ipv4,
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.src_ip.ipv4,
       SCS_API_IPV4_LEN);
    qdf_mem_copy(
       scs_data->tclas_tuple[tclas_idx].tclas.type4.dst_ip.ipv4,
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.dst_ip.ipv4,
       SCS_API_IPV4_LEN);
}

static void
scs_api_copy_tclas_type4_v6_params(struct ieee80211_scs_data *scs_data,
                                   struct scs_api_data *scs_temp,
                                   uint8_t tclas_idx)
{
    qdf_mem_copy(
       scs_data->tclas_tuple[tclas_idx].tclas.type4.src_ip.ipv6,
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.src_ip.ipv6,
       SCS_API_IPV6_LEN);
    qdf_mem_copy(
       scs_data->tclas_tuple[tclas_idx].tclas.type4.dst_ip.ipv6,
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.dst_ip.ipv6,
       SCS_API_IPV6_LEN);
    qdf_mem_copy(
       scs_data->tclas_tuple[tclas_idx].tclas.type4.flow_label,
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.flow_label,
       SCS_API_FLOW_LABEL_SIZE);
}

static uint16_t
scs_api_copy_tclas_type4_params(struct ieee80211_scs_data *scs_data,
                                struct scs_api_data *scs_temp,
                                uint8_t tclas_idx)
{
    uint8_t version;
    uint16_t status = SCS_API_SCS_SUCCESS;

    scs_data->tclas_tuple[tclas_idx].tclas.type4.mask =
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.mask;
    scs_data->tclas_tuple[tclas_idx].tclas.type4.version =
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.version;
    version = scs_data->tclas_tuple[tclas_idx].tclas.type4.version;

    switch (version) {
        case SCS_API_WNM_TCLAS_CLAS4_VERSION_4:
            scs_api_copy_tclas_type4_v4_params(scs_data, scs_temp, tclas_idx);
            break;

        case SCS_API_WNM_TCLAS_CLAS4_VERSION_6:
            scs_api_copy_tclas_type4_v6_params(scs_data, scs_temp, tclas_idx);
            break;

        default:
            return SCS_API_SCS_REQUESTED_TCLAS_NOT_SUPPORTED;
    }

    scs_data->tclas_tuple[tclas_idx].tclas.type4.src_port =
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.src_port;
    scs_data->tclas_tuple[tclas_idx].tclas.type4.dst_port =
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.dst_port;
    scs_data->tclas_tuple[tclas_idx].tclas.type4.dscp =
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.dscp;
    scs_data->tclas_tuple[tclas_idx].tclas.type4.next_header =
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type4.next_header;

    return status;
}

static uint16_t scs_api_copy_tclas_type10_params(
                                      struct ieee80211_node *ni,
                                      struct ieee80211_scs_data *scs_data,
                                      struct scs_api_data *scs_temp,
                                      uint8_t tclas_idx, uint8_t tclas_len)
{
    uint8_t filter_len;
    uint8_t *filter_value;
    uint8_t *filter_mask;

    scs_data->tclas_tuple[tclas_idx].tclas.type10.protocol_instance =
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type10.protocol_instance;
    scs_data->tclas_tuple[tclas_idx].tclas.type10.protocol_number =
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type10.protocol_number;
    filter_len =
       scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type10.filter_len;
    scs_data->tclas_tuple[tclas_idx].tclas.type10.filter_len = filter_len;

    if (filter_len > SCS_API_TCLAS10_FILTER_LEN) {
        scs_err("Invalid TCLAS10 filter len");
        return SCS_API_SCS_REQUEST_DECLINED;
    }

    filter_value = OS_MALLOC(ni->ni_vap->iv_ic->ic_osdev, filter_len,
                             GFP_KERNEL);
    if (!filter_value) {
        scs_err("TCLAS filter mask MALLOC failed!");
        return SCS_API_SCS_INSUFFICIENT_TCLAS_PROCESSING_RESOURCES;
    }

    filter_mask = OS_MALLOC(ni->ni_vap->iv_ic->ic_osdev, filter_len,
                            GFP_KERNEL);
    if (!filter_mask) {
        scs_err("TCLAS filter mask MALLOC failed!");
        OS_FREE(filter_value);
        return SCS_API_SCS_INSUFFICIENT_TCLAS_PROCESSING_RESOURCES;
    }

    qdf_mem_copy(
      filter_value,
      scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type10.filter_val,
      filter_len);

    qdf_mem_copy(
      filter_mask,
      scs_temp->scs_api_tclas_tuple[tclas_idx].scs_api_tclas.type10.filter_mask,
      filter_len);

    scs_data->tclas_tuple[tclas_idx].tclas.type10.filter_val = filter_value;
    scs_data->tclas_tuple[tclas_idx].tclas.type10.filter_mask = filter_mask;

    return SCS_API_SCS_SUCCESS;
}

static uint16_t scs_api_format_and_copy_tclas_params(struct ieee80211_node *ni,
                                      struct ieee80211_scs_data *scs_data,
                                      struct scs_api_data *scs_temp)
{

    uint8_t type;
    uint16_t status = SCS_API_SCS_SUCCESS;
    uint8_t tclas_elements = scs_temp->tclas_elements;
    uint8_t tclas_idx = 0;
    uint8_t tclas_len = 0;

    /* Boundary check for no. of tclas elements in 1 SCS descriptor */
    if (tclas_elements >= SCS_API_TCLAS_MAX_SIZE)
        return SCS_API_SCS_INSUFFICIENT_TCLAS_PROCESSING_RESOURCES;

    while (tclas_elements > 0) {
        tclas_len = scs_temp->scs_api_tclas_tuple[tclas_idx].len;
        scs_data->tclas_tuple[tclas_idx].type =
                  scs_temp->scs_api_tclas_tuple[tclas_idx].type;
        type = scs_data->tclas_tuple[tclas_idx].type;

        switch (type) {
            case SCS_API_WNM_TCLAS_CLASSIFIER_TYPE4:
            {
                status = scs_api_copy_tclas_type4_params(scs_data, scs_temp,
                                                         tclas_idx);
                if (status)
                    goto fail;
                break;
            }

            case SCS_API_WNM_TCLAS_CLASSIFIER_TYPE10:
            {
                status = scs_api_copy_tclas_type10_params(ni, scs_data,
                                                          scs_temp, tclas_idx,
                                                          tclas_len);
                if (status)
                    goto fail;
                break;
            }

            default:
                status = SCS_API_SCS_REQUESTED_TCLAS_NOT_SUPPORTED;
                goto fail;
        }

        tclas_idx++;
        tclas_elements--;
    }

fail:
    return status;
}

static void scs_api_format_and_copy_tclas_processing_elem(
                                          struct ieee80211_scs_data *scs_data,
                                          struct scs_api_data *scs_temp)
{
    if (scs_data->tclas_elements > 0) {
        scs_data->tclas_processing.elem_id =
                               scs_temp->scs_api_tclas_processing.elem_id;
        scs_data->tclas_processing.length =
                               scs_temp->scs_api_tclas_processing.length;
        scs_data->tclas_processing.tclas_process =
                               scs_temp->scs_api_tclas_processing.tclas_process;
    }
}

#ifdef WLAN_FEATURE_11BE
static uint16_t scs_api_format_and_copy_qos_attributes(
                                          struct ieee80211_scs_data *scs_data,
                                          struct scs_api_data *scs_temp)
{
    struct ieee80211_qos_attr *qos_attr = NULL;
    uint16_t bitmap = 0;
    uint32_t resultant_burst_size = 0, resultant_service_interval = 0;
    uint32_t data_rate = 0;
    uint16_t retval = QDF_STATUS_SUCCESS;

    if (!scs_temp->is_qos_present)
        goto fail;

    qos_attr = qdf_mem_malloc(sizeof(struct ieee80211_qos_attr));
    if (!qos_attr) {
         scs_err("Memory allocation failed for QoS attributes");
         retval = QDF_STATUS_E_NOMEM;
         goto fail;
    }

    qos_attr->service_class_id = IEEE80211_QOS_ATTR_INVALID_SERVICE_CLASS_ID;
    qos_attr->direction = scs_temp->qos_attr.direction;
    if (qos_attr->direction == IEEE80211_QOS_ATTR_DIRECTION_DIRECT_LINK) {
        scs_err("SCS for direct link is not supported by AP");
        qdf_mem_free(qos_attr);
        qos_attr = NULL;
        retval = QDF_STATUS_E_NOSUPPORT;
        goto fail;
    }

    qos_attr->tid = scs_temp->qos_attr.tid;
    qos_attr->user_priority = scs_temp->qos_attr.user_priority;
    qos_attr->bitmap = scs_temp->qos_attr.bitmap;
    qos_attr->link_id = scs_temp->qos_attr.link_id;

    scs_info("******** QoS Characteristics Element ********");
    scs_info("Control Info Params: Direction: %u, TID: %u, UP: %u, "
             "Bitmap: %u, Link_ID: %u", qos_attr->direction,
             qos_attr->tid, qos_attr->user_priority, qos_attr->bitmap,
             qos_attr->link_id);

    qos_attr->min_service_interval = scs_temp->qos_attr.min_service_interval;
    qos_attr->max_service_interval = scs_temp->qos_attr.max_service_interval;
    /* Compute resultant_service_interval */
    qos_attr->resultant_service_interval =
      ((qos_attr->min_service_interval + qos_attr->max_service_interval) >> 1);
    /* Resultant service interval in milliseconds */
    resultant_service_interval = qos_attr->resultant_service_interval/1000;

    qos_attr->min_data_rate = scs_temp->qos_attr.min_data_rate;
    /* Data rate in Kilo Bytes Per Second */
    data_rate = qos_attr->min_data_rate/8;

    /*
     * Resultant burst size (in bytes) is computed as minimum of the
     * following 3 calculations:
     * 1. Resultant Service Interval * Minimum Data Rate
     * 2. Resultant Service Interval * Mean Data Rate (if rcvd from station)
     * 3. Burst Size (if rcvd from station in SCS request)
     */
    resultant_burst_size = resultant_service_interval * data_rate;

    qos_attr->delay_bound = scs_temp->qos_attr.delay_bound;

    bitmap = qos_attr->bitmap;
    if (IEEE80211_CHECK_QOS_ATTR_PRESENT(bitmap, MAX_MSDU_SIZE))
        qos_attr->max_msdu_size = scs_temp->qos_attr.max_msdu_size;

    if (IEEE80211_CHECK_QOS_ATTR_PRESENT(bitmap, SERVICE_START_TIME))
        qos_attr->service_start_time = scs_temp->qos_attr.service_start_time;

    if (IEEE80211_CHECK_QOS_ATTR_PRESENT(bitmap, SERVICE_START_TIME_LINK_ID))
        qos_attr->service_start_time_link_id =
                  scs_temp->qos_attr.service_start_time_link_id;

    if (IEEE80211_CHECK_QOS_ATTR_PRESENT(bitmap, MEAN_DATA_RATE)) {
        qos_attr->mean_data_rate = scs_temp->qos_attr.mean_data_rate;
        /* Data rate in Kilo Bytes Per Second */
        data_rate = qos_attr->mean_data_rate/8;
        resultant_burst_size = QDF_MIN(resultant_burst_size,
                                       resultant_service_interval * data_rate);
    }

    if (IEEE80211_CHECK_QOS_ATTR_PRESENT(bitmap, BURST_SIZE)) {
        qos_attr->burst_size = scs_temp->qos_attr.burst_size;
        resultant_burst_size = QDF_MIN(resultant_burst_size,
                                       qos_attr->burst_size);
    }

    qos_attr->resultant_burst_size = resultant_burst_size;

    if (IEEE80211_CHECK_QOS_ATTR_PRESENT(bitmap, MSDU_LIFETIME))
        qos_attr->msdu_lifetime = scs_temp->qos_attr.msdu_lifetime;

    if (IEEE80211_CHECK_QOS_ATTR_PRESENT(bitmap, MSDU_DELIVERY_RATIO))
        qos_attr->msdu_delivery_ratio = scs_temp->qos_attr.msdu_delivery_ratio;

    if (IEEE80211_CHECK_QOS_ATTR_PRESENT(bitmap, MSDU_COUNT_EXPONENT))
        qos_attr->msdu_count_exponent = scs_temp->qos_attr.msdu_count_exponent;

    if (IEEE80211_CHECK_QOS_ATTR_PRESENT(bitmap, MEDIUM_TIME))
        qos_attr->medium_time = scs_temp->qos_attr.medium_time;

    qos_attr->access_category = TID_TO_WME_AC(qos_attr->tid);

    scs_info("Min_Service_Interval: %u, Max_Service_Interval: %u, "
             "Resultant_Service_Interval: %u, Min_Data_Rate: %u, "
             "Delay_Bound: %u, Max_MSDU_Size: %u, "
             "Service_Start_Time: %u, Service_Start_Time_Link_ID: %u, "
             "Mean_Data_Rate: %u, Burst_Size: %u, "
             "Resultant_Burst_Size: %u, MSDU_Lifetime: %u, "
             "MSDU_Delivery_Ratio: %u, MSDU_Count_Exponent: %u, "
             "Medium_Time: %u, AC: %u ", qos_attr->min_service_interval,
             qos_attr->max_service_interval,
             qos_attr->resultant_service_interval,
             qos_attr->min_data_rate, qos_attr->delay_bound,
             qos_attr->max_msdu_size, qos_attr->service_start_time,
             qos_attr->service_start_time_link_id,
             qos_attr->mean_data_rate, qos_attr->burst_size,
             qos_attr->resultant_burst_size, qos_attr->msdu_lifetime,
             qos_attr->msdu_delivery_ratio,
             qos_attr->msdu_count_exponent, qos_attr->medium_time,
             qos_attr->access_category);

fail:
    scs_data->qos_attr = qos_attr;
    return retval;
}

#else
static uint16_t scs_api_format_and_copy_qos_attributes(
                                          struct ieee80211_scs_data *scs_data,
                                          struct scs_api_data *scs_temp)
{
    return QDF_STATUS_SUCCESS;
}
#endif /* WLAN_FEATURE_11BE */

static
uint16_t scs_api_format_and_process_data(struct ieee80211_node *ni,
                                         struct scs_api_data *scs_temp,
                                         struct ieee80211_scs_data *scs_data)
{
    uint16_t retval = SCS_API_SCS_SUCCESS;

    if (scs_temp->parsing_status_code != SCS_API_SCS_SUCCESS) {
        scs_err("SCS parsing failed in Application");
        retval = scs_temp->parsing_status_code;
        return retval;
    }

    scs_api_format_and_copy_scs_params(scs_data, scs_temp);

    if (scs_data->request_type == SCS_API_SCS_REMOVE_RULE)
        return retval;

    /* TCLAS copy code */
    retval = scs_api_format_and_copy_tclas_params(ni, scs_data, scs_temp);
    if (retval) {
        scs_err("Error in Formatting/Copy of TCLAS params");
        return retval;
    }

    /* TCLAS Processing element */
    scs_api_format_and_copy_tclas_processing_elem(scs_data, scs_temp);

    /* QOS Attributes element */
    retval = scs_api_format_and_copy_qos_attributes(scs_data, scs_temp);
    if (retval) {
        scs_err("Error in QOS attributes copy");
        retval = SCS_API_SCS_REQUEST_DECLINED;
        return retval;
    }

    return retval;
}

static int process_nl_msg_recv_scs_api_app_reg(struct ieee80211com *ic,
                                               const void *data, int data_len)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX + 1] = {0};
    struct nlattr *tb;
    struct ol_ath_softc_net80211 *scn;
    ol_ath_soc_softc_t *soc;
    struct scs_api_info scs_api_app_info = {0};
    uint16_t scs_api_info_size = sizeof(struct scs_api_info);

    scn = OL_ATH_SOFTC_NET80211(ic);
    if (!scn) {
        scs_err("scn is NULL");
        return -EINVAL;
    }

    soc = scn->soc;
    if (!soc) {
        scs_err("SOC is NULL");
        return -EINVAL;
    }

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX,
                                data, data_len,
                                qca_wlan_vendor_scs_api_policy)) {
        scs_err("Failed Parsing SCS API Response message");
        return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DATA];
    if (tb) {
        if ((nla_len(tb) % scs_api_info_size) == 0) {
            scs_trace("SCS API App Info data is received with correct size");
        } else {
            scs_err("SCS API App Info  data size is wrong");
            return -1;
        }
        qdf_mem_copy(&scs_api_app_info, nla_data(tb), scs_api_info_size);

        ol_global_soc[0]->scs_api_app_support_enable =
                          scs_api_app_info.scs_app_support_enable;
        ol_global_soc[0]->scs_api_frame_fwd_support =
                          scs_api_app_info.frame_fwd_support;
        ol_global_soc[0]->scs_api_nw_mgr_support =
                          scs_api_app_info.nw_mgr_support;

        scs_info("SCS API Drv info - APP support:%d, Frame Fwd support:%d, "
                 "NW Manager support:%d",
                 ol_global_soc[0]->scs_api_app_support_enable,
                 ol_global_soc[0]->scs_api_frame_fwd_support,
                 ol_global_soc[0]->scs_api_nw_mgr_support);
    } else {
        scs_err("SCS API Parsed data not found");
        return -1;
    }

    return 0;
}

static int process_scs_api_data(struct ieee80211_node *ni,
                                uint8_t *scs_req_parsed_data,
                                uint8_t num_scs_descriptor,
                                uint8_t *link_mac_addr, uint8_t *mld_mac_addr,
                                uint8_t dialog_token, bool is_mlo)
{
    struct scs_api_data scs_temp = {0};
    struct scs_api_drv_resp scs_api_resp[SCS_API_SCS_MAX_SIZE];
    struct ieee80211_scs_data *scs_data = NULL;
    struct ieee80211com *ic = ni->ni_ic;
    struct ieee80211_node *assoc_ni = NULL;
    uint8_t scs_id, service_class_id, request_type;
    uint8_t idx = 0;
    uint16_t scs_data_size = sizeof(struct scs_api_data);
    uint16_t status = SCS_API_SCS_SUCCESS;
#ifdef WLAN_FEATURE_11BE_MLO
    bool flag = false;
#endif

#ifdef WLAN_FEATURE_11BE_MLO
    /* Maintain SCS database on assoc_node for MLO peer */
    if (wlan_peer_is_mlo(ni->peer_obj) &&
        !wlan_peer_mlme_is_assoc_peer(ni->peer_obj)) {
        assoc_ni =
            ieee80211_ucfg_get_mlo_assoc_link_node(ni->peer_obj->mlo_peer_ctx);
        if (!assoc_ni)
            return -1;

        qdf_spin_lock_bh(&assoc_ni->ni_scs_lock);
        flag = true;
    } else
#endif
    {
        assoc_ni = ni;
    }

    while (num_scs_descriptor > 0) {
        scs_id = 0;
        service_class_id = 0;

        if (idx >= IEEE80211_SCS_MAX_SIZE) {
            scs_err("Rcvd more than %d SCS requests in 1 Action Frame",
                    SCS_API_SCS_MAX_SIZE);
            scs_err("Processing only first %d SCS requests and ignoring "
                    "the remaining ones", SCS_API_SCS_MAX_SIZE);
            break;
        }

        scs_data = (struct ieee80211_scs_data *) OS_MALLOC(ic->ic_osdev,
                           (sizeof(struct ieee80211_scs_data)),0);

        if (!scs_data) {
            scs_err("Memory allocation failed for SCS Data");
            status = SCS_API_SCS_INSUFFICIENT_TCLAS_PROCESSING_RESOURCES;
            goto fail;
        }

        qdf_mem_copy(&scs_temp, (scs_req_parsed_data + (idx*scs_data_size)),
                     scs_data_size);

        status = scs_api_format_and_process_data(ni, &scs_temp, scs_data);

        scs_id = scs_temp.scsid;
        request_type = scs_temp.request_type;

        if (status != SCS_API_SCS_SUCCESS) {
            if (scs_data) {
                scs_trace("Parse: Clearing scs_temp memory, status:%d",
                          status);
                ieee80211_scs_desc_mem_free(scs_data);
            }
            goto fail;
        }

        /* Process the SCS request frame based on the request type*/
        status = ieee80211_process_scs_req(assoc_ni, scs_data);

        /* For SCS Add fail after scs_temp is attached to the node, do not
         * clear the memory as it is already freed inside.
         * For SCS Del, return value is always != Success and memory should
         * be cleared. Below case takes care of that.
         */
        if (status != SCS_API_SCS_SUCCESS) {
            if (status != SCS_REQUEST_DECLINED_DATA_FREED &&
                status != SCS_TCLAS_PROCESSING_TERMINATED_DATA_FREED) {
                if (scs_data) {
                    scs_trace("Process: Clearing scs_temp memory, "
                              "status:%d, Request type:%d", status,
                              scs_data->request_type);
                    ieee80211_scs_desc_mem_free(scs_data);
                }
            }
        } else {
            if ((request_type == IEEE80211_SCS_ADD_RULE) ||
                (request_type == IEEE80211_SCS_CHANGE_RULE)) {
#ifdef WLAN_FEATURE_11BE
                if (scs_data->qos_attr) {
                    service_class_id = scs_data->qos_attr->service_class_id;
                } else
#endif
                {
                    service_class_id = SCS_API_SAWF_SCS_SVC_CLASS_MIN +
                                       (scs_data->access_priority &
                                       SCS_API_SCS_OUTPUT_TID_MASK);
                }
            }
        }

        /* When scs_temp data already freed case, in case of failure in add
         * after node attach, return IEEE80211_SCS_REQUEST_DECLINED code.
         * In case of failure during update after node attach, return
         * IEEE80211_SCS_TCLAS_PROCESSING_TERMINATED code.
         */
        if (status == SCS_REQUEST_DECLINED_DATA_FREED)
            status = SCS_API_SCS_REQUEST_DECLINED;
        else if (status == SCS_TCLAS_PROCESSING_TERMINATED_DATA_FREED)
            status = SCS_API_SCS_TCLAS_PROCESSING_TERMINATED;

fail:
        scs_api_resp[idx].scs_id = scs_id;
        scs_api_resp[idx].svc_id = service_class_id;
        scs_api_resp[idx].status_code = status;

        scs_trace("SCS API populating Resp: SCS ID:%d, SVC ID:%d, "
                  "Status code:%d, idx:%d", scs_api_resp[idx].scs_id,
                  scs_api_resp[idx].svc_id, scs_api_resp[idx].status_code,
                  idx);

        num_scs_descriptor--;
        idx++;
    }

    ieee80211_send_scs_api_drv_response(ni, dialog_token, scs_api_resp, idx,
                                        mld_mac_addr, is_mlo);

#ifdef WLAN_FEATURE_11BE_MLO
    if (flag) {
         /* Release lock and reference on assoc_node */
         qdf_spin_unlock_bh(&assoc_ni->ni_scs_lock);
         wlan_objmgr_peer_release_ref(assoc_ni->peer_obj, WLAN_MLME_NB_ID);
    }
#endif

    return 0;
}

static int process_nl_msg_recv_scs_api_data(struct ieee80211com *ic,
                                            const void *data, int data_len)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX + 1] = {0};
    struct nlattr *tb;
    uint8_t link_mac_addr[QDF_MAC_ADDR_SIZE];
    uint8_t mld_mac_addr[QDF_MAC_ADDR_SIZE];
    uint8_t *scs_req_parsed_data;
    uint8_t num_scs_descriptor = 0;
    uint16_t scs_data_size = sizeof(struct scs_api_data);
    uint8_t dialog_token;
    bool is_mlo = false;
    struct ieee80211_node *ni = NULL;
    int ret;

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX,
                                data, data_len,
                                qca_wlan_vendor_scs_api_policy)) {
        scs_err("Failed Parsing SCS API Response message");
        return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_PEER_MAC];
    if (tb) {
        qdf_mem_copy(link_mac_addr, nla_data(tb), nla_len(tb));
        scs_trace("Len %d, data_len:%d", nla_len(tb), data_len);
        scs_info("Link Mac Address: %02x:%02x:%02x:%02x:%02x:%02x",
                 link_mac_addr[0], link_mac_addr[1], link_mac_addr[2],
                 link_mac_addr[3], link_mac_addr[4], link_mac_addr[5]);
    } else {
        scs_err("Peer mac address not found");
        return -1;
    }

#ifdef WLAN_FEATURE_11BE_MLO
    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MLD_MAC];
    if (tb) {
        is_mlo = true;
        qdf_mem_copy(mld_mac_addr, nla_data(tb), nla_len(tb));
        scs_trace("Len %d, data_len:%d", nla_len(tb), data_len);
        scs_info("MLD Mac Address: %02x:%02x:%02x:%02x:%02x:%02x",
                 mld_mac_addr[0], mld_mac_addr[1], mld_mac_addr[2],
                 mld_mac_addr[3], mld_mac_addr[4], mld_mac_addr[5]);
    }
#endif

    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DIALOG_TOKEN];
    if (tb) {
        dialog_token = nla_get_u8(tb);
        scs_info("Dialog Token: %d", dialog_token);
    } else {
        scs_err("Dialog token not found");
        return -1;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DATA];
    if (tb) {
        scs_info("Length of SCS parsed data: %d", nla_len(tb));
        if (nla_len(tb) > SCS_API_DATA_BUF_MAX_SIZE) {
                scs_err("Err: Parsed SCS data size > max buf size");
                return -1;
        }

        if ((nla_len(tb) % scs_data_size) == 0) {
            scs_trace("SCS API parsed data is received with correct size");
        } else {
            scs_err("SCS API parsed data size is wrong");
            return -1;
        }

        ni = ieee80211_find_node(ic, link_mac_addr, WLAN_MLME_NB_ID);
        if (!ni) {
            scs_err("Node not found");
            return -1;
        }

        num_scs_descriptor = nla_len(tb) / scs_data_size;
        scs_info("Number of SCS descriptors present: %d", num_scs_descriptor);

        scs_req_parsed_data = qdf_mem_malloc(nla_len(tb));
        qdf_mem_copy(scs_req_parsed_data, nla_data(tb), nla_len(tb));

        qdf_spin_lock_bh(&ni->ni_scs_lock);
        ret = process_scs_api_data(ni, scs_req_parsed_data, num_scs_descriptor,
                                   link_mac_addr, mld_mac_addr, dialog_token,
                                   is_mlo);
        qdf_spin_unlock_bh(&ni->ni_scs_lock);
        ieee80211_free_node(ni, WLAN_MLME_NB_ID);

        qdf_mem_free(scs_req_parsed_data);
        scs_req_parsed_data = NULL;

        if (ret) {
            scs_err("SCS API process data failed");
            return -1;
        }

    } else {
        scs_err("SCS API Parsed data not found");
        return -1;
    }

    return 0;
}

static int process_scs_api_response_data(struct ieee80211_node *ni,
                                         uint8_t *app_resp,
                                         uint8_t num_scs_descriptor,
                                         uint8_t *link_mac_addr,
                                         uint8_t *mld_mac_addr,
                                         uint8_t dialog_token)
{
    struct scs_api_drv_resp scs_api_app_resp = {0};
    int idx = 0;
    uint8_t resp_data_size = sizeof(struct scs_api_drv_resp);

    qdf_mem_zero(&ni->ni_scs_resp, sizeof(struct ieee80211_scs_resp));
    ni->ni_scs_resp.dialog_token = dialog_token;

    while (num_scs_descriptor > 0) {
        if (idx >= IEEE80211_SCS_MAX_SIZE) {
            scs_err("Rcvd more than %d SCS Response idx from application",
                    SCS_API_SCS_MAX_SIZE);
            scs_err("Processing only first %d SCS requests and ignoring "
                    "the remaining ones", SCS_API_SCS_MAX_SIZE);
            break;
        }

        qdf_mem_copy(&scs_api_app_resp, (app_resp + (idx * resp_data_size)),
                     resp_data_size);
        scs_info("SCS ID:%d, SVC_ID:%d, Driver Response:%d",
                 scs_api_app_resp.scs_id, scs_api_app_resp.svc_id,
                 scs_api_app_resp.status_code);

        ieee80211_prepare_scs_resp(ni, scs_api_app_resp.scs_id,
                                   scs_api_app_resp.status_code);
        num_scs_descriptor--;
        idx++;
    }

    ieee80211_send_scs_resp(ni);

    return 0;
}

static int process_nl_msg_recv_scs_api_scs_response(struct ieee80211com *ic,
                                                    const void *data,
                                                    int data_len)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX + 1] = {0};
    struct nlattr *tb;
    uint8_t link_mac_addr[QDF_MAC_ADDR_SIZE];
    uint8_t mld_mac_addr[QDF_MAC_ADDR_SIZE];
    uint8_t num_scs_descriptor;
    uint8_t dialog_token;
    uint8_t app_resp[SCS_API_RESP_BUF_MAX_SIZE];
    struct ieee80211_node *ni = NULL;
    int ret;
    uint8_t resp_data_size = sizeof(struct scs_api_drv_resp);

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX,
                                data, data_len,
                                qca_wlan_vendor_scs_api_policy)) {
        scs_err("Failed Parsing SCS API Response message");
        return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_PEER_MAC];
    if (tb) {
        qdf_mem_copy(link_mac_addr, nla_data(tb), nla_len(tb));
        scs_trace("Len %d, data_len:%d", nla_len(tb), data_len);
        scs_info("Mac Address: %02x:%02x:%02x:%02x:%02x:%02x",
                 link_mac_addr[0], link_mac_addr[1], link_mac_addr[2],
                 link_mac_addr[3], link_mac_addr[4], link_mac_addr[5]);
    } else {
        scs_err("Peer mac address not found");
        return -1;
    }

#ifdef WLAN_FEATURE_11BE_MLO
    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MLD_MAC];
    if (tb) {
        qdf_mem_copy(mld_mac_addr, nla_data(tb), nla_len(tb));
        scs_trace("Len %d, data_len:%d", nla_len(tb), data_len);
        scs_info("MLD Mac Address: %02x:%02x:%02x:%02x:%02x:%02x",
                 mld_mac_addr[0], mld_mac_addr[1], mld_mac_addr[2],
                 mld_mac_addr[3], mld_mac_addr[4], mld_mac_addr[5]);
    }
#endif

    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DIALOG_TOKEN];
    if (tb) {
        dialog_token = nla_get_u8(tb);
        scs_info("Dialog Token: %d", dialog_token);
    } else {
        scs_err("Dialog token not found");
        return -1;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TOTAL_SCS_IDX];
    if (tb) {
        num_scs_descriptor = nla_get_u8(tb);
        scs_info("Total SCS Descriptor count: %d", num_scs_descriptor);
        if (num_scs_descriptor <= 0) {
            scs_err("SCS descriptor count is Invalid");
            return -1;
        }
    } else {
        scs_err("Total SCS index not found");
        return -1;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DATA];
    if (tb) {
        scs_info("Length of SCS response data: %d", nla_len(tb));
        if (nla_len(tb) > SCS_API_RESP_BUF_MAX_SIZE) {
            scs_err("Err: SCS response data size > max buf size");
            return -1;
        }

        if ((nla_len(tb) % resp_data_size) == 0) {
            scs_trace("SCS API Response data is received with correct size");
        } else {
            scs_err("SCS API Response data size is wrong");
            return -1;
        }

        scs_info("Len of NL buffer: %d", nla_len(tb));
        qdf_mem_copy(app_resp, nla_data(tb), nla_len(tb));
        scs_info("SCS Application Response: SCS ID - Status code dump:");

        ni = ieee80211_find_node(ic, link_mac_addr, WLAN_MLME_NB_ID);
        if (!ni) {
            scs_err("Node not found");
            return -1;
        }

        qdf_spin_lock_bh(&ni->ni_scs_lock);
        ret = process_scs_api_response_data(ni, app_resp, num_scs_descriptor,
                                            link_mac_addr, mld_mac_addr,
                                            dialog_token);
        qdf_spin_unlock_bh(&ni->ni_scs_lock);
        ieee80211_free_node(ni, WLAN_MLME_NB_ID);

        if (ret) {
            scs_err("SCS API process response data failed");
            return -1;
        }

    } else {
        scs_err("SCS API Response data not found");
        return -1;
    }

    return 0;
}

static int wlan_cfg80211_parse_scs_api_resp_msg(struct wiphy *wiphy,
                                                struct wireless_dev *wdev,
                                                const void *data,
                                                int data_len)
{
    uint8_t msg_type = 0;
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX + 1] = {0};
    struct nlattr *tb;
    struct ieee80211com *ic = NULL;
    struct wlan_objmgr_pdev *pdev;
    struct wlan_objmgr_psoc *psoc_obj;
    int ret = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, INVALID_LINK_ID);
    if (!ic) {
        scs_err("Invalid interface");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;
    if (!pdev) {
       scs_err("pdev is NULL");
       return -ENOMEM;
    }

    psoc_obj = wlan_pdev_get_psoc(pdev);
    if (!psoc_obj) {
       scs_err("psoc obj is NULL");
       return -ENOMEM;
    }

    scs_info("Processing NL message - Received SCS message from Application "
             "- len:%d", data_len);

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX,
                                data, data_len,
                                qca_wlan_vendor_scs_api_policy)) {
       scs_err("Failed in parsing SCS API message from Application");
       return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TYPE];

    if (tb) {
        msg_type = nla_get_u8(tb);
        scs_info("MSG_TYPE: %u", msg_type);
    } else {
        scs_err("MSG_TYPE not present");
        return -ENOMEM;
    }

    switch (msg_type) {
        case QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TYPE_REGISTRATION:
            ret = process_nl_msg_recv_scs_api_app_reg(ic, data, data_len);
            break;

        case QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TYPE_SCS_REQUEST_PARSED_DATA:
            ret = process_nl_msg_recv_scs_api_data(ic, data, data_len);
            break;

        case QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TYPE_SCS_RESPONSE:
            ret = process_nl_msg_recv_scs_api_scs_response(ic, data, data_len);
            break;

        default:
            scs_err("Unknown SCS API Message Type");
    }

    if (ret)
        scs_err("SCS msg recv processing failed");

    return ret;
}
#endif /* WLAN_SUPPORT_SCS_API */
#endif /* WLAN_SUPPORT_SCS */

#ifdef SAWF_ADMISSION_CONTROL
static const struct nla_policy
qca_wlan_vendor_sawf_flow_deprioritize_msg_policy[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MAX + 1] = {
	[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_PEER_MAC] = {.type = NLA_BINARY,
		                             .len = QDF_MAC_ADDR_SIZE},
	[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MLD_MAC] = {.type = NLA_BINARY,
		                                 .len = QDF_MAC_ADDR_SIZE},
	[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MSDUQ_ID] = {.type = NLA_U8},
	[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MARK_METADATA] = {.type = NLA_U32},
	[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_SVC_ID] = {.type = NLA_U8 },
	[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_SVC_TYPE] = {.type = NLA_U8},
	[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_HW_LINK_ID] = {.type = NLA_U16},
};

static int
wlan_cfg80211_process_sawf_flow_deprioritize_cmd(
              struct wlan_cfg80211_sawf_flow_deprioritize_params *deprio_params)
{
    uint32_t prim_ifindex;
    struct ieee80211_node *ni = NULL;
    struct ieee80211vap *vap = NULL;
    struct qca_sawf_flow_deprioritize_params result_params = {0};

#ifdef WLAN_FEATURE_11BE_MLO
    struct wlan_mlo_dev_context *mld_dev = NULL;
    struct wlan_mlo_peer_context *ml_peer = NULL;
#endif

#ifdef WLAN_FEATURE_11BE_MLO
    if (deprio_params->is_mlo_peer) {
        qdf_mem_copy(result_params.peer_mac, deprio_params->mld_mac,
                     QDF_MAC_ADDR_SIZE);

        ml_peer = wlan_mlo_get_mlpeer_by_peer_mladdr(
                    (struct qdf_mac_addr *)deprio_params->mld_mac, &mld_dev);

        if (mld_dev && ml_peer)
            ni = ieee80211_ucfg_get_mlo_assoc_link_node(ml_peer);
    } else
#endif
    {
        uint16_t link_id;
        uint8_t ml_group_id;
        struct ieee80211com *ic = NULL;
        struct wlan_objmgr_pdev *pdev = NULL;

        link_id = (deprio_params->hw_link_id & 0xFF);
        ml_group_id = (deprio_params->hw_link_id >> 8);

        pdev = wlan_mlo_get_pdev_by_hw_link_id(link_id, ml_group_id,
                                               WLAN_MLME_NB_ID);
        if (!pdev)
            return -EINVAL;

        ic = wlan_pdev_get_mlme_ext_obj(pdev);
        if (!ic) {
             wlan_objmgr_pdev_release_ref(pdev, WLAN_MLME_NB_ID);
             return -EINVAL;
        }

        qdf_mem_copy(result_params.peer_mac, deprio_params->peer_mac,
                     QDF_MAC_ADDR_SIZE);

        ni = ieee80211_find_node(ic, deprio_params->peer_mac, WLAN_MLME_NB_ID);

        wlan_objmgr_pdev_release_ref(pdev, WLAN_MLME_NB_ID);
    }

    if (!ni) {
        qdf_err("Node not found");
        return -EINVAL;
    }

    if (deprio_params->svc_type != WLAN_SVC_TYPE_SCS) {
#ifdef QCA_SUPPORT_WDS_EXTENDED
        if (ni->is_wds_client) {
            prim_ifindex = ni->netdev_if_index;
        } else
#endif
        {
            vap = ni->ni_vap;
            if (!vap) {
                ieee80211_free_node(ni, WLAN_MLME_NB_ID);
                return -EINVAL;
            }
#ifdef WLAN_FEATURE_11BE_MLO
            if (wlan_peer_is_mlo(ni->peer_obj)) {
                uint8_t prim_peer_link_id;

                prim_peer_link_id = wlan_mlo_peer_get_primary_peer_link_id(ni->peer_obj);
                prim_ifindex = wlan_get_ifidx_by_link_id(vap, prim_peer_link_id);
            } else
#endif
            {
                osif_dev *osif = NULL;
                osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
                prim_ifindex = osif->netdev->ifindex;
            }
        }

        result_params.netdev_info_valid = true;
        result_params.netdev_ifindex = prim_ifindex;
        result_params.mark_metadata = deprio_params->mark_metadata;
        wlan_sawf_flow_deprioritize(&result_params);
    }
#ifdef WLAN_SUPPORT_SCS
    else {
        ieee80211_deprioritize_scs_flows(ni, deprio_params->svc_id);
    }
#endif

    ieee80211_free_node(ni, WLAN_MLME_NB_ID);
    return 0;
}

static int
wlan_cfg80211_parse_sawf_flow_deprioritize_msg(struct wiphy *wiphy,
                                               struct wireless_dev *wdev,
                                               const void *data, int data_len)
{
    struct nlattr *tb;
    struct wlan_cfg80211_sawf_flow_deprioritize_params deprio_params = {0};
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MAX + 1] = {0};

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MAX,
                                data, data_len, qca_wlan_vendor_sawf_flow_deprioritize_msg_policy)) {
        qdf_err("Failed in parsing sawf flow deprioritization cmd from application");
        return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_PEER_MAC];
    if (tb) {
        qdf_mem_copy(deprio_params.peer_mac, nla_data(tb), nla_len(tb));
        qdf_info("Mac Addr: "QDF_MAC_ADDR_FMT, QDF_MAC_ADDR_REF(deprio_params.peer_mac));
    } else {
        qdf_err("Peer mac addr missing in deprio cmd");
        return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MLD_MAC];
    if (tb) {
        deprio_params.is_mlo_peer = true;
        qdf_mem_copy(deprio_params.mld_mac, nla_data(tb), nla_len(tb));
        qdf_info("MLD Mac Addr: "QDF_MAC_ADDR_FMT, QDF_MAC_ADDR_REF(deprio_params.mld_mac));
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MSDUQ_ID];
    if (tb) {
        deprio_params.msduq_id = nla_get_u8(tb);
        qdf_info("MSDUQ ID: %d", deprio_params.msduq_id);
    } else {
        qdf_err("MSDU_Queue ID missing in deprio cmd");
        return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MARK_METADATA];
    if (tb) {
        deprio_params.mark_metadata = nla_get_u32(tb);
        qdf_info("Mark metadata: %x", deprio_params.mark_metadata);
    } else {
        qdf_err("Mark metadata missing in deprio cmd");
        return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_SVC_ID];
    if (tb) {
        deprio_params.svc_id = nla_get_u8(tb);
        qdf_info("Svc ID: %d", deprio_params.svc_id);
    } else {
        qdf_err("Svc Type missing in deprio cmd");
        return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_SVC_TYPE];
    if (tb) {
        deprio_params.svc_type = nla_get_u8(tb);
        qdf_info("Svc Type: %d", deprio_params.svc_type);
    } else {
        qdf_err("Svc Type missing in deprio cmd");
        return -EINVAL;
    }

    tb = attr[QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_HW_LINK_ID];
    if (tb) {
        deprio_params.hw_link_id = nla_get_u16(tb);
        qdf_info("Hw Link ID: %d", deprio_params.hw_link_id);
    } else {
        qdf_err("Hw Link ID missing in deprio cmd");
        return -EINVAL;
    }

    return wlan_cfg80211_process_sawf_flow_deprioritize_cmd(&deprio_params);
}
#endif

#ifdef CONFIG_SAWF
/**
 * wlan_cfg80211_parse_sla_event() - API to parse the sla event data
 *                                   from user-space
 * @wiphy:   Pointer to wireless wiphy structure.
 * @wdev:    Pointer to wireless_dev structure.
 * @data:    Pointer to the data to be passed via vendor interface
 * @data_len:Length of the data to be passed
 *
 * Return: 0 on success, negative errno on failure
 */
static int wlan_cfg80211_parse_sla_event(struct wiphy *wiphy,
                                         struct wireless_dev *wdev,
                                         const void *data,
                                         int data_len)
{
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_SLA_MAX + 1] = {0};
    uint8_t svc_id, flag, peer_mac[QDF_MAC_ADDR_SIZE],
            peer_mld_mac[QDF_MAC_ADDR_SIZE];
    int ret = 0;

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_SLA_MAX,
                                data, data_len, qca_wlan_vendor_sla_policy)) {
        qdf_err("Failed Parsing request!");
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID]) {
       svc_id = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC]) {
            nla_memcpy(peer_mac,
                       attr[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC],
                       QDF_MAC_ADDR_SIZE);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR]) {
       flag = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR]);
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC]) {
            nla_memcpy(peer_mld_mac,
                       attr[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC],
                       QDF_MAC_ADDR_SIZE);
    }

    ret = wlan_sawf_sla_process_sla_event(svc_id, peer_mac,
                                          peer_mld_mac, flag);

    return ret;
}

#if defined(WLAN_SUPPORT_SCS) && defined(SAWF_ADMISSION_CONTROL)
static const struct nla_policy
qca_wlan_vendor_scs_adm_ctrl_data_policy[QCA_WLAN_VENDOR_ATTR_SCS_DATA_MAX + 1] = {
        [QCA_WLAN_VENDOR_ATTR_SCS_DATA_SCSID] = {.type = NLA_U8 },
        [QCA_WLAN_VENDOR_ATTR_SCS_DATA_ACCESS_CATEGORY] = {.type = NLA_U8 },
        [QCA_WLAN_VENDOR_ATTR_SCS_DATA_TID] = {.type = NLA_U8 },
        [QCA_WLAN_VENDOR_ATTR_SCS_DATA_SERVICE_INTERVAL] = {.type = NLA_U32 },
        [QCA_WLAN_VENDOR_ATTR_SCS_DATA_DELAY_BOUND] = {.type = NLA_U32 },
        [QCA_WLAN_VENDOR_ATTR_SCS_DATA_BURST_SIZE] = {.type = NLA_U32 },
        [QCA_WLAN_VENDOR_ATTR_SCS_DATA_MIN_DATA_RATE] = {.type = NLA_U32 },
        [QCA_WLAN_VENDOR_ATTR_SCS_DATA_STATUS] = {.type = NLA_U8 },
};

static const struct nla_policy
qca_wlan_vendor_scs_adm_ctrl_resp_policy[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_MAX + 1] = {
        [QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_DIALOG_TOKEN] = {.type = NLA_U8 },
        [QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_HW_LINK_ID] = {.type = NLA_U16 },
        [QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_PEER_MAC] = {.type = NLA_BINARY,
                                                        .len = QDF_MAC_ADDR_SIZE },
        [QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_PEER_MLD_MAC] = {.type = NLA_BINARY,
                                                            .len = QDF_MAC_ADDR_SIZE },
        [QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_NUM_SCS_REQS] = {.type = NLA_U8 },
        [QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_SCS_DATA] = {.type = NLA_NESTED},
};

static int wlan_cfg80211_parse_scs_adm_ctrl_resp(struct wiphy *wiphy,
                                                 struct wireless_dev *wdev,
                                                 const void *data,
                                                 int data_len)
{
    int rem;
    uint8_t scs_id, status, i = 0;
    struct ieee80211com *ic = NULL;
    struct ieee80211_scs_adm_ctrl_intf scs_adm_ctrl_intf = {0};
    struct nlattr *attr[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_MAX + 1] = {0};
    struct nlattr *nl, *nl_attr[QCA_WLAN_VENDOR_ATTR_SCS_DATA_MAX + 1];

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    if (wlan_cfg80211_nla_parse(attr, QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_MAX,
                                data, data_len, qca_wlan_vendor_scs_adm_ctrl_resp_policy)) {
        qdf_err("Failed Parsing request!");
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_DIALOG_TOKEN]) {
        scs_adm_ctrl_intf.dialog_token = nla_get_u8(attr[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_DIALOG_TOKEN]);
    } else {
        qdf_err("Dialog Token missing in SCS Admission Control response");
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_PEER_MAC]) {
            nla_memcpy(scs_adm_ctrl_intf.peer_mac_addr,
                       attr[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_PEER_MAC],
                       QDF_MAC_ADDR_SIZE);
    } else {
        qdf_err("Peer MAC address missing in SCS Admission Control response");
        return -EINVAL;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_PEER_MLD_MAC]) {
            nla_memcpy(scs_adm_ctrl_intf.peer_mld_mac_addr,
                       attr[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_PEER_MLD_MAC],
                       QDF_MAC_ADDR_SIZE);
            scs_adm_ctrl_intf.is_mlo_peer = 1;
    }

    if (attr[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_SCS_DATA]) {
        nla_for_each_nested(nl, attr[QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_SCS_DATA], rem) {

            if (wlan_cfg80211_nla_parse(nl_attr, QCA_WLAN_VENDOR_ATTR_SCS_DATA_MAX,
                                    nla_data(nl), nla_len(nl),
                                    qca_wlan_vendor_scs_adm_ctrl_data_policy)) {
                qdf_err("nla_parse failed !!");
                return -EINVAL;
            }

            if (nl_attr[QCA_WLAN_VENDOR_ATTR_SCS_DATA_SCSID]) {
                scs_id = nla_get_u8(nl_attr[QCA_WLAN_VENDOR_ATTR_SCS_DATA_SCSID]);
            } else {
               qdf_err("SCS_ID missing in SCS Admission Control response");
               return -EINVAL;
            }

            if (nl_attr[QCA_WLAN_VENDOR_ATTR_SCS_DATA_STATUS]) {
                status = nla_get_u8(nl_attr[QCA_WLAN_VENDOR_ATTR_SCS_DATA_STATUS]);
            } else {
                qdf_err("Status missing in SCS Admission Control response");
                return -EINVAL;
            }

            scs_adm_ctrl_intf.scs_info[i].scsid = scs_id;
            scs_adm_ctrl_intf.scs_info[i].status = status;
            i++;
        }
    } else {
        qdf_err("SCS_Data missing in SCS Admission Control response");
        return -EINVAL;
    }

    scs_adm_ctrl_intf.num_scs_reqs = i;

    ieee80211_process_scs_adm_ctrl_resp(ic, &scs_adm_ctrl_intf);

    return 0;
}
#endif
#endif

/* Vendor id to be used in vendor specific command and events
 *
 * to user space.
 */

#define QCA_NL80211_VENDOR_ID           0x001374
#define MAX_REQUEST_ID                  0xFFFFFFFF

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24))
/* "policy" has been added as a new member from 5.4 onwards */
const struct wiphy_vendor_command wlan_cfg80211_vendor_commands[] = {
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SET_WIFI_CONFIGURATION,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_set_wificonfiguration,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_setget_wificonfiguration_policy,
                                      QCA_WLAN_VENDOR_ATTR_CONFIG_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_GET_WIFI_CONFIGURATION,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_get_wificonfiguration,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_setget_wificonfiguration_policy,
                                      QCA_WLAN_VENDOR_ATTR_CONFIG_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },

    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_GPIO_CONFIG_COMMAND,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_set_gpio_config,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_gpio_config_policy,
                                      QCA_WLAN_VENDOR_ATTR_GPIO_PARAM_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#if UMAC_SUPPORT_ACS
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_DO_ACS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_do_acs,
        vendor_command_policy(wlan_cfg80211_do_acs_policy,
				      QCA_WLAN_VENDOR_ATTR_ACS_MAX)
    },
#endif /* UMAC_SUPPORT_ACS */
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_PHYERR,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_phyerr,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(VENDOR_CMD_RAW_DATA, 0)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_TRIGGER_SCAN,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_vendor_scan,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(scan_policy, QCA_WLAN_VENDOR_ATTR_SCAN_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_EXTERNAL_ACS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_update_vendor_channel,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_external_acs_policy,
                                      QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_CHANNEL_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_START,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_config_and_start_cb,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(spectral_scan_policy,
                                      QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_STOP,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_stop_cb,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(spectral_scan_policy,
                                      QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_GET_CONFIG,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_get_config_cb,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(spectral_scan_policy,
                                      QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_CONFIG_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_GET_DIAG_STATS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_get_diag_stats_cb,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(VENDOR_CMD_RAW_DATA, 0)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_GET_CAP_INFO,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_get_cap_cb,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(VENDOR_CMD_RAW_DATA, 0)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_GET_STATUS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_get_status_cb,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(spectral_scan_get_status_policy,
                                      QCA_WLAN_VENDOR_ATTR_SPECTRAL_SCAN_STATUS_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_GET_RROP_INFO,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_vendor_get_rropinfo,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(VENDOR_CMD_RAW_DATA, 0)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SET_QDEPTH_THRESH,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_set_qdepth_thresh_cb,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_set_qdepth_thresh_policy,
                                      QCA_WLAN_VENDOR_ATTR_QDEPTH_THRESH_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_ADD_STA_NODE,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_add_sta_node,
        vendor_command_policy(qca_wlan_vendor_add_sta_node_attr,
                                      QCA_WLAN_VENDOR_ATTR_ADD_STA_NODE_PARAM_MAX)
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SEND_EGID,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_send_egid,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(qca_wlan_vendor_send_egid_attr,
                                      QCA_WLAN_VENDOR_ATTR_SEND_EGID_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#if WLAN_SUPPORT_TELEMETRY
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_TELEMETRIC_DATA,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_get_telemetric_data,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(telemetric_req_policy,
                                      QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#endif /* WLAN_SUPPORT_TELEMETRY */
#ifdef WLAN_FEATURE_11BE_MLO
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_MLO_LINK_REMOVAL,
        .flags =  WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_mlo_link_remove_cmd,
        vendor_command_policy(reconfig_req_policy,
                QCA_WLAN_VENDOR_ATTR_MLO_LINK_REMOVAL_MAX)
    },
#endif
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_MLO_LINK_BTMREQ,
        .flags =  WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_reconfig_btmreq,
        vendor_command_policy(reconfig_btmreq_policy,
                QCA_WLAN_VENDOR_ATTR_MLO_LINK_BTM_MAX)
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SON_REG_PARAMS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_son_reg_params,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_setget_wificonfiguration_policy,
                                      QCA_WLAN_VENDOR_ATTR_CONFIG_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#ifdef CONFIG_AFC_SUPPORT
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_AFC_RESPONSE,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_afc_response,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_afc_response_policy,
                        QCA_WLAN_VENDOR_ATTR_AFC_RESP_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_GET_DEV_DEPLOYMENT_TYPE,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_get_dev_deployment_type,
        .policy = VENDOR_CMD_RAW_DATA
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_AFC_GET_REG_EIRP,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_get_afc_reg_eirp,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_afc_reg_eirp_policy,
                        QCA_WLAN_VENDOR_ATTR_AFC_REG_EIRP_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#endif /* CONFIG_AFC_SUPPORT */
#ifdef WLAN_FEATURE_11BE
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_RM_GENERIC,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_rm_app_genric,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(rm_generic_policy,
                              QCA_WLAN_VENDOR_ATTR_RM_GENERIC_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_PEER_T2LM_POLICY,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_tid_to_link_mapping,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(tid_to_link_mapping_policy,
                              QCA_WLAN_VENDOR_ATTR_T2LM_POLICY_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#endif /* WLAN_FEATURE_11BE */
#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SECURE_RANGING_CONTEXT,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_set_secure_ranging_context,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_pasn_set_ranging_ctx_policy,
                              QCA_WLAN_VENDOR_ATTR_SECURE_RANGING_CTX_MAX)
#else
            .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */

    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_PASN,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_handle_pasn,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_create_delete_pasn_auth_status_policy,
                              QCA_WLAN_VENDOR_ATTR_MAX)
#else
            .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */

    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_GET_FEATURES,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_get_features,
        vendor_command_policy(VENDOR_CMD_RAW_DATA, 0)
    },
#endif

#ifdef CONFIG_SAWF
#ifdef WLAN_FEATURE_11BE
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_parse_sla_event,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(qca_wlan_vendor_sla_policy,
                              QCA_WLAN_VENDOR_ATTR_SLA_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#endif
#endif

#ifdef WLAN_SUPPORT_SCS
    {
    .info.vendor_id = QCA_NL80211_VENDOR_ID,
    .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SCS_RULE_CONFIG,
    .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
         WIPHY_VENDOR_CMD_NEED_NETDEV |
         WIPHY_VENDOR_CMD_NEED_RUNNING,
    .doit = wlan_cfg80211_parse_scs_rule_config_resp,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(scs_config_resp_rule_id_policy,
                              QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#ifdef WLAN_SUPPORT_SCS_API
    {
    .info.vendor_id = QCA_NL80211_VENDOR_ID,
    .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SCS_API_MSG,
    .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
         WIPHY_VENDOR_CMD_NEED_NETDEV |
         WIPHY_VENDOR_CMD_NEED_RUNNING,
    .doit = wlan_cfg80211_parse_scs_api_resp_msg,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(qca_wlan_vendor_scs_api_policy,
                              QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#endif

#ifdef SAWF_ADMISSION_CONTROL
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SCS_ADM_CTRL_MSG,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_parse_scs_adm_ctrl_resp,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(qca_wlan_vendor_scs_adm_ctrl_resp_policy,
                              QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#endif
#endif
#ifdef SAWF_ADMISSION_CONTROL
    {
    .info.vendor_id = QCA_NL80211_VENDOR_ID,
    .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SAWF_FLOW_DEPRIORITIZE_MSG,
    .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
         WIPHY_VENDOR_CMD_NEED_NETDEV |
         WIPHY_VENDOR_CMD_NEED_RUNNING,
    .doit = wlan_cfg80211_parse_sawf_flow_deprioritize_msg,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(qca_wlan_vendor_sawf_flow_deprioritize_msg_policy,
                              QCA_WLAN_VENDOR_ATTR_SAWF_FLOW_DEPRIORITIZE_MSG_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    },
#endif
    {
    .info.vendor_id = QCA_NL80211_VENDOR_ID,
    .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_MU_TPUT_INFO,
    .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
         WIPHY_VENDOR_CMD_NEED_NETDEV |
         WIPHY_VENDOR_CMD_NEED_RUNNING,
    .doit = wlan_cfg80211_enable_disable_sched_modes,
#if STRICT_NLPOLICY_CHECKING
        vendor_command_policy(wlan_cfg80211_get_mu_params_policy,
                              QCA_WLAN_VENDOR_ATTR_MU_TPUT_INFO_MAX)
#else
        .policy = VENDOR_CMD_RAW_DATA
#endif /* STRICT_NLPOLICY_CHECKING */
    }
};
#else
const struct wiphy_vendor_command wlan_cfg80211_vendor_commands[] = {
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SET_WIFI_CONFIGURATION,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_set_wificonfiguration
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_GET_WIFI_CONFIGURATION,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_get_wificonfiguration
    },

    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_GPIO_CONFIG_COMMAND,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_set_gpio_config
    },
#if UMAC_SUPPORT_ACS
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_DO_ACS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_do_acs
    },
#endif /* UMAC_SUPPORT_ACS */
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_PHYERR,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_phyerr
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_TRIGGER_SCAN,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_vendor_scan
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_EXTERNAL_ACS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_update_vendor_channel
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_START,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_config_and_start_cb
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_STOP,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_stop_cb
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_GET_CONFIG,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_get_config_cb
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_GET_DIAG_STATS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_get_diag_stats_cb
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_GET_CAP_INFO,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_get_cap_cb
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_GET_STATUS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_spectral_scan_get_status_cb
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_GET_RROP_INFO,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_vendor_get_rropinfo
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SET_QDEPTH_THRESH,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_set_qdepth_thresh_cb
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_ADD_STA_NODE,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_add_sta_node
    },
#if WLAN_SUPPORT_TELEMETRY
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_TELEMETRIC_DATA,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_get_telemetric_data
    },
#endif /* WLAN_SUPPORT_TELEMETRY */
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SON_REG_PARAMS,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV |
            WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_son_reg_params
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SEND_EGID,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
             WIPHY_VENDOR_CMD_NEED_NETDEV |
             WIPHY_VENDOR_CMD_NEED_RUNNING,
        .doit = wlan_cfg80211_send_egid
    },
#ifdef CONFIG_AFC_SUPPORT
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_AFC_RESPONSE,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_afc_response
    },
#endif /* CONFIG_AFC_SUPPORT */
#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SECURE_RANGING_CONTEXT,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_set_secure_ranging_context,
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_PASN,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_handle_pasn,
    },
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_GET_FEATURES,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_get_features,
        vendor_command_policy(VENDOR_CMD_RAW_DATA, 0)
    },
#endif
    {
        .info.vendor_id = QCA_NL80211_VENDOR_ID,
        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_MU_TPUT_INFO,
        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
            WIPHY_VENDOR_CMD_NEED_NETDEV,
        .doit = wlan_cfg80211_enable_disable_sched_modes,
    },
};
#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)*/

/* vendor specific events */
static const struct nl80211_vendor_cmd_info wlan_cfg80211_vendor_events[] = {
    [QCA_NL80211_VENDOR_SUBCMD_DO_ACS_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_DO_ACS
    },
    [QCA_NL80211_VENDOR_SUBCMD_DFS_OFFLOAD_CAC_STARTED_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_DFS_OFFLOAD_CAC_STARTED
    },
    [QCA_NL80211_VENDOR_SUBCMD_UPDATE_EXTERNAL_ACS_CONFIG] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_EXTERNAL_ACS
    },
    [QCA_NL80211_VENDOR_SUBCMD_SCAN_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_TRIGGER_SCAN
    },
    [QCA_NL80211_VENDOR_SUBCMD_SCAN_DONE_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_SCAN_DONE
    },
    [QCA_NL80211_VENDOR_SUBCMD_GET_WIFI_CONFIGURATION_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_GET_WIFI_CONFIGURATION
    },
    [QCA_NL80211_VENDOR_SUBCMD_WIFI_FW_STATS_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_WIFI_FW_STATS
    },
    [QCA_NL80211_VENDOR_SUBCMD_PEER_STATS_CACHE_FLUSH_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_PEER_STATS_CACHE_FLUSH
    },
    [QCA_NL80211_VENDOR_SUBCMD_UPDATE_SSID_INDEX] = {
            .vendor_id = QCA_NL80211_VENDOR_ID,
            .subcmd = QCA_NL80211_VENDOR_SUBCMD_UPDATE_SSID
    },
    [QCA_NL80211_VENDOR_SUBCMD_MBSSID_TX_VDEV_STATUS_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_MBSSID_TX_VDEV_STATUS
    },
#ifdef CONFIG_AFC_SUPPORT
    [QCA_NL80211_VENDOR_SUBCMD_AFC_EVENT_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_AFC_EVENT
    },
#endif /* CONFIG_AFC_SUPPORT */

#ifdef WLAN_FEATURE_11BE
    [QCA_NL80211_VENDOR_SUBCMD_RM_GENERIC_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_RM_GENERIC
    },
    [QCA_NL80211_VENDOR_SUBCMD_PEER_T2LM_POLICY_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_PEER_T2LM_POLICY
    },

#endif /* WLAN_FEATURE_11BE */
#if defined(WLAN_SUPPORT_SCS) || defined(CONFIG_SAWF)
    [QCA_NL80211_VENDOR_SUBCMD_SCS_RULE_CONFIG_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_SCS_RULE_CONFIG
    },
#endif
#ifdef SAWF_ADMISSION_CONTROL
#ifdef WLAN_SUPPORT_SCS
    [QCA_NL80211_VENDOR_SUBCMD_SCS_ADM_CTRL_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_SCS_ADM_CTRL_MSG
    },
#endif
    [QCA_NL80211_VENDOR_SUBCMD_SAWF_PEER_MSDUQ_EVENT_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_SAWF_PEER_MSDUQ_EVENT
    },
#endif
#ifdef CONFIG_SAWF
    [QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH
    },
#endif
#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
    [QCA_NL80211_VENDOR_SUBCMD_PASN_AUTH_STATUS_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_PASN,
    },
#endif
    [QCA_NL80211_VENDOR_SUBCMD_MLO_LINK_REMOVAL_TBTT_UPDATE_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_MLO_LINK_REMOVAL_TBTT_UPDATE,
    },

    [QCA_NL80211_VENDOR_SUBCMD_DISABLE_MU_MODES_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_MU_TPUT_INFO,
    },

#ifdef WLAN_FEATURE_11BE_MLO
    [QCA_NL80211_VENDOR_SUBCMD_MLO_PEER_PRIM_NETDEV_EVENT_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_MLO_PEER_PRIM_NETDEV_EVENT,
    },
    [QCA_NL80211_VENDOR_SUBCMD_QCOM_HW_STATUS_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_QCOM_HW_STATUS,
    },
#endif
    [QCA_NL80211_VENDOR_SUBCMD_TTLM_LINK_UPDATE_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_TTLM_LINK_UPDATE_EVENT,
    },
#ifdef WLAN_SUPPORT_SCS_API
    [QCA_NL80211_VENDOR_SUBCMD_SCS_API_MSG_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_SCS_API_MSG,
    },
#endif
#ifdef WLAN_SUPPORT_TELEMETRY
    [QCA_NL80211_VENDOR_SUBCMD_TELEMETRY_STATS_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_TELEMETRIC_DATA,
    },
#endif
    [QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_COMPLETE_INDEX] = {
        .vendor_id = QCA_NL80211_VENDOR_ID,
        .subcmd = QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_COMPLETE,
    },
    /* Any new addition of event here should be defined inside
     * qca_nl80211_vendor_subcmds_index_internal and also under g_cfg_ev_fl[]
     * global filter event array, defined to filter configured events and categorize to
     * respective subevent and flag to deliver event to userspace.
     */
};

#ifdef QCA_BLOCK_EVENT_TO_USERSPACE
/**
 * Global list of CFG vendor events is formed by categorizing events to sub events,
 * flag to indicate delivery of event to application and count to indicate number
 * of times the events are blocked. Any new event addition for CFG vendor specific
 * events in wlan_cfg80211_vendor_events[], needs to be listed in global event under
 * suitable subtype.
 */
struct filter_events g_cfg_ev_fl[QCA_NL80211_VENDOR_SUBCMD_INDEX_LAST] = {

    [QCA_NL80211_VENDOR_SUBCMD_DO_ACS_INDEX]                  =
     {QCA_NL80211_VENDOR_SUBCMD_DO_ACS_INDEX, FL_SUBTYPE_SCAN, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_DFS_OFFLOAD_CAC_STARTED_INDEX] =
     {QCA_NL80211_VENDOR_SUBCMD_DFS_OFFLOAD_CAC_STARTED_INDEX, FL_SUBTYPE_RADIO, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_UPDATE_EXTERNAL_ACS_CONFIG]    =
     {QCA_NL80211_VENDOR_SUBCMD_UPDATE_EXTERNAL_ACS_CONFIG, FL_SUBTYPE_SCAN, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_SCAN_INDEX]                    =
     {QCA_NL80211_VENDOR_SUBCMD_SCAN_INDEX, FL_SUBTYPE_SCAN, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_SCAN_DONE_INDEX]               =
     {QCA_NL80211_VENDOR_SUBCMD_SCAN_DONE_INDEX, FL_SUBTYPE_SCAN, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_GET_WIFI_CONFIGURATION_INDEX]  =
     {QCA_NL80211_VENDOR_SUBCMD_GET_WIFI_CONFIGURATION_INDEX, FL_SUBTYPE_RADIO, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_WIFI_FW_STATS_INDEX]           =
     {QCA_NL80211_VENDOR_SUBCMD_WIFI_FW_STATS_INDEX, FL_SUBTYPE_RADIO, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_PEER_STATS_CACHE_FLUSH_INDEX]  =
     {QCA_NL80211_VENDOR_SUBCMD_PEER_STATS_CACHE_FLUSH_INDEX, FL_SUBTYPE_RADIO, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_UPDATE_SSID_INDEX]             =
     {QCA_NL80211_VENDOR_SUBCMD_UPDATE_SSID_INDEX, FL_SUBTYPE_VAP, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_MBSSID_TX_VDEV_STATUS_INDEX]   =
     {QCA_NL80211_VENDOR_SUBCMD_MBSSID_TX_VDEV_STATUS_INDEX, FL_SUBTYPE_AP, true, 0},
#ifdef CONFIG_AFC_SUPPORT
    [QCA_NL80211_VENDOR_SUBCMD_AFC_EVENT_INDEX]                 =
     {QCA_NL80211_VENDOR_SUBCMD_AFC_EVENT_INDEX, FL_SUBTYPE_RADIO, true, 0},
#endif /* CONFIG_AFC_SUPPORT */
#ifdef WLAN_FEATURE_11BE
    [QCA_NL80211_VENDOR_SUBCMD_RM_GENERIC_INDEX] =
     {QCA_NL80211_VENDOR_SUBCMD_RM_GENERIC_INDEX, FL_SUBTYPE_RADIO, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_PEER_T2LM_POLICY_INDEX]        =
     {QCA_NL80211_VENDOR_SUBCMD_PEER_T2LM_POLICY_INDEX, FL_SUBTYPE_RADIO, true, 0},
#endif /* WLAN_FEATURE_11BE */
#if defined(WLAN_SUPPORT_SCS) || defined(CONFIG_SAWF)
    [QCA_NL80211_VENDOR_SUBCMD_SCS_RULE_CONFIG_INDEX]         =
     {QCA_NL80211_VENDOR_SUBCMD_SCS_RULE_CONFIG_INDEX, FL_SUBTYPE_RADIO, true, 0},
#endif
#ifdef SAWF_ADMISSION_CONTROL
#ifdef WLAN_SUPPORT_SCS
    [QCA_NL80211_VENDOR_SUBCMD_SCS_ADM_CTRL_INDEX] =
     {QCA_NL80211_VENDOR_SUBCMD_SCS_ADM_CTRL_INDEX, FL_SUBTYPE_VAP, true, 0},
#endif
    [QCA_NL80211_VENDOR_SUBCMD_SAWF_PEER_MSDUQ_EVENT_INDEX] =
     {QCA_NL80211_VENDOR_SUBCMD_SAWF_PEER_MSDUQ_EVENT_INDEX, FL_SUBTYPE_MISC, true, 0},
#endif
#ifdef CONFIG_SAWF
    [QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH_INDEX]         =
     {QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH_INDEX, FL_SUBTYPE_RADIO, true, 0},
#endif
#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
    [QCA_NL80211_VENDOR_SUBCMD_PASN_AUTH_STATUS_INDEX]        =
     {QCA_NL80211_VENDOR_SUBCMD_PASN_AUTH_STATUS_INDEX, FL_SUBTYPE_SEC, true, 0},
#endif
    [QCA_NL80211_VENDOR_SUBCMD_MLO_LINK_REMOVAL_TBTT_UPDATE_INDEX] =
     {QCA_NL80211_VENDOR_SUBCMD_MLO_LINK_REMOVAL_TBTT_UPDATE_INDEX, FL_SUBTYPE_VAP, true, 0},
#ifdef WLAN_FEATURE_11BE_MLO
    [QCA_NL80211_VENDOR_SUBCMD_MLO_PEER_PRIM_NETDEV_EVENT_INDEX]   =
     {QCA_NL80211_VENDOR_SUBCMD_MLO_PEER_PRIM_NETDEV_EVENT_INDEX, FL_SUBTYPE_VAP, true, 0},
    [QCA_NL80211_VENDOR_SUBCMD_QCOM_HW_STATUS_INDEX]               =
     {QCA_NL80211_VENDOR_SUBCMD_QCOM_HW_STATUS_INDEX, FL_SUBTYPE_VAP, true, 0},
#endif
    [QCA_NL80211_VENDOR_SUBCMD_TTLM_LINK_UPDATE_INDEX]             =
     {QCA_NL80211_VENDOR_SUBCMD_TTLM_LINK_UPDATE_INDEX, FL_SUBTYPE_VAP, true, 0},
#ifdef WLAN_SUPPORT_SCS_API
    [QCA_NL80211_VENDOR_SUBCMD_SCS_API_MSG_INDEX] =
     {QCA_NL80211_VENDOR_SUBCMD_SCS_API_MSG_INDEX, FL_SUBTYPE_VAP, true, 0},
#endif
    [QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_COMPLETE_INDEX] =
     {QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_COMPLETE_INDEX, FL_SUBTYPE_RADIO, true, 0},
};

qdf_export_symbol(g_cfg_ev_fl);

/* Event name information structure for CFG vendor specific events */
struct event_name_info g_cfg_event_name[QCA_NL80211_VENDOR_SUBCMD_INDEX_LAST] = {
    [QCA_NL80211_VENDOR_SUBCMD_DO_ACS_INDEX] = {"DO_ACS_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_DFS_OFFLOAD_CAC_STARTED_INDEX] =
        {"DFS_OFFLOAD_CAC_STARTED_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_UPDATE_EXTERNAL_ACS_CONFIG] = {"UPDATE_EXTERNAL_ACS_CONFIG"},
    [QCA_NL80211_VENDOR_SUBCMD_SCAN_INDEX] = {"SCAN_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_SCAN_DONE_INDEX] = {"SCAN_DONE_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_GET_WIFI_CONFIGURATION_INDEX] = {"GET_WIFI_CONFIGURATION_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_WIFI_FW_STATS_INDEX] = {"WIFI_FW_STATS_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_PEER_STATS_CACHE_FLUSH_INDEX] = {"PEER_STATS_CACHE_FLUSH_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_UPDATE_SSID_INDEX] = {"UPDATE_SSID_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_MBSSID_TX_VDEV_STATUS_INDEX] = {"MBSSID_TX_VDEV_STATUS_INDEX"},
#ifdef CONFIG_AFC_SUPPORT
    [QCA_NL80211_VENDOR_SUBCMD_AFC_EVENT_INDEX] = {"AFC_EVENT_INDEX"},
#endif /* CONFIG_AFC_SUPPORT */
#ifdef WLAN_FEATURE_11BE
    [QCA_NL80211_VENDOR_SUBCMD_RM_GENERIC_INDEX] = {"RM_GENERIC_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_PEER_T2LM_POLICY_INDEX] = {"PEER_T2LM_POLICY_INDEX"},
#endif
#if defined(WLAN_SUPPORT_SCS) || defined(CONFIG_SAWF)
    [QCA_NL80211_VENDOR_SUBCMD_SCS_RULE_CONFIG_INDEX] = {"SCS_RULE_CONFIG_INDEX"},
#endif
#ifdef SAWF_ADMISSION_CONTROL
#ifdef WLAN_SUPPORT_SCS
    [QCA_NL80211_VENDOR_SUBCMD_SCS_ADM_CTRL_INDEX] = {"SCS_ADM_CTRL_INDEX"},
#endif
    [QCA_NL80211_VENDOR_SUBCMD_SAWF_PEER_MSDUQ_EVENT_INDEX] = {"SAWF_PEER_MSDUQ_EVENT_INDEX"},
#endif
#ifdef CONFIG_SAWF
    [QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH_INDEX] = {"SAWF_SLA_BREACH_INDEX"},
#endif
#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
    [QCA_NL80211_VENDOR_SUBCMD_PASN_AUTH_STATUS_INDEX] = {"PASN_AUTH_STATUS_INDEX"},
#endif
    [QCA_NL80211_VENDOR_SUBCMD_MLO_LINK_REMOVAL_TBTT_UPDATE_INDEX] =
        {"MLO_LINK_REMOVAL_TBTT_UPDATE_INDEX"},
#ifdef WLAN_FEATURE_11BE_MLO
    [QCA_NL80211_VENDOR_SUBCMD_MLO_PEER_PRIM_NETDEV_EVENT_INDEX] =
        {"MLO_PEER_PRIM_NETDEV_EVENT_INDEX"},
    [QCA_NL80211_VENDOR_SUBCMD_QCOM_HW_STATUS_INDEX] = {"QCOM_HW_STATUS_INDEX"},
#endif
    [QCA_NL80211_VENDOR_SUBCMD_TTLM_LINK_UPDATE_INDEX] = {"TTLM_LINK_UPDATE_INDEX"},
#ifdef WLAN_SUPPORT_SCS_API
    [QCA_NL80211_VENDOR_SUBCMD_SCS_API_MSG_INDEX] = {"SCS_API_MSG_INDEX"},
#endif
    [QCA_NL80211_VENDOR_SUBCMD_SPECTRAL_SCAN_COMPLETE_INDEX] =
        {"SPECTRAL_SCAN_COMPLETE_INDEX"},
};
qdf_export_symbol(g_cfg_event_name);
#endif /* QCA_BLOCK_EVENT_TO_USERSPACE */

#endif

static struct ieee80211_rate wlan_cfg80211_rates_2g[] = {
    /* CCK */
    RATETAB(10,  0x82, 0),
    RATETAB(20,  0x84, 0),
    RATETAB(55,  0x8b, 0),
    RATETAB(110, 0x96, 0),
    /* OFDM */
    RATETAB(60,  0x0c, 0),
    RATETAB(90,  0x12, 0),
    RATETAB(120, 0x18, 0),
    RATETAB(180, 0x24, 0),
    RATETAB(240, 0x30, 0),
    RATETAB(360, 0x48, 0),
    RATETAB(480, 0x60, 0),
    RATETAB(540, 0x6c, 0),
};
#define wlan_cfg80211_rates_2g_size (12)

static struct ieee80211_rate wlan_cfg80211_rates_5g[] = {
    /* OFDM */
    RATETAB(60,  0x0c, 0),
    RATETAB(90,  0x12, 0),
    RATETAB(120, 0x18, 0),
    RATETAB(180, 0x24, 0),
    RATETAB(240, 0x30, 0),
    RATETAB(360, 0x48, 0),
    RATETAB(480, 0x60, 0),
    RATETAB(540, 0x6c, 0),
};
#define wlan_cfg80211_rates_5g_size (8)

static struct ieee80211_rate wlan_cfg80211_rates_49g_half[] = {
    /* OFDM */
    RATETAB(30,  0x06, 0),
    RATETAB(45,  0x09, 0),
    RATETAB(60, 0x0c, 0),
    RATETAB(90, 0x12, 0),
    RATETAB(120, 0x18, 0),
    RATETAB(180, 0x24, 0),
    RATETAB(240, 0x30, 0),
    RATETAB(270, 0x6c, 0),
};
#define wlan_cfg80211_rates_49g_half_size (8)

static struct ieee80211_rate wlan_cfg80211_rates_49g_quarter[] = {
    /* OFDM */
    RATETAB(15,  0x03, 0),
    RATETAB(20,  0x04, 0),
    RATETAB(30, 0x06, 0),
    RATETAB(45, 0x09, 0),
    RATETAB(60, 0x0c, 0),
    RATETAB(90, 0x12, 0),
    RATETAB(120, 0x18, 0),
    RATETAB(135, 0x1b, 0),
};
#define wlan_cfg80211_rates_49g_quarter_size (8)

/**
 * cfg80211_add_half_quarter_count() - Add the count of half and quarter rate
 * 4.9G channels to total channel count.
 * @chan_list: Regulatory active channel list.
 * @num_channels: Number of active channels in regulatory list.
 */
static void
cfg80211_add_half_quarter_count(struct regulatory_channel *chan_list,
                                uint8_t *num_channels)
{
    uint8_t i;
    uint8_t half_qrtr_count = 0;

    for (i = 0; i < *num_channels; i++) {
        if (WLAN_REG_IS_49GHZ_FREQ(chan_list[i].center_freq)) {
            int min_bw = chan_list[i].min_bw;
            int max_bw = chan_list[i].max_bw;

            if (min_bw == FULL_BW || max_bw == QRTR_BW)
                continue;

            while (max_bw > QRTR_BW) {
                max_bw /= 2;

                if (max_bw >= min_bw)
                    half_qrtr_count++;
            }
        }
    }

    *num_channels += half_qrtr_count;
}

/**
 *   wlan_cfg80211_get_num_channels: returns number of channels available for
 *   given mode and ic.
 *   @ic: pointer to ieee80211com.
 *   @reg_band: regulatory band (2/5/6Ghz band).
 *
 *   Return number of channels.
 */
static int
wlan_cfg80211_get_num_channels(struct ieee80211com *ic,
                               enum reg_wifi_band reg_band)

{
    struct regulatory_channel *chan_list;
    uint8_t num_channels = 0;

    switch (reg_band) {
            case REG_BAND_2G:
                 num_channels = NUM_24GHZ_CHANNELS;
                 break;
            case REG_BAND_5G:
                 num_channels = NUM_5GHZ_CHANNELS + NUM_49GHZ_CHANNELS;
                 break;
            case REG_BAND_6G:
                 num_channels = NUM_6GHZ_CHANNELS;
                 break;
            default:
                 return 0;
    }

    chan_list = qdf_mem_malloc(num_channels *
                               sizeof(struct regulatory_channel));
    if (!chan_list) {
        qdf_err("Memory allocation failed for chan_list");
        return 0;
    }

    num_channels =  wlan_reg_get_band_channel_list_for_pwrmode(ic->ic_pdev_obj,
                                                   BIT(reg_band),
                                                   chan_list,
                                                   REG_BEST_PWR_MODE,
                                                   true);
    cfg80211_add_half_quarter_count(chan_list, &num_channels);
    qdf_mem_free(chan_list);
    return num_channels;
}

/**
 *   ieee80211_is_sp_only_deployment: Checks if only SP regulatory rules are
 *   present.
 *   @pdev: pointer to wlan_objmgr_pdev.
 *
 *   Return: True if only SP regulatory rules are present. False otherwise.
 */
static inline bool
ieee80211_is_sp_only_deployment(struct wlan_objmgr_pdev *pdev)
{
    uint8_t num_sp_rules = 0, num_lpi_rules = 0, num_vlp_rules = 0;

    num_lpi_rules = wlan_reg_get_num_rules_of_ap_pwr_type(pdev, REG_INDOOR_AP);
    num_sp_rules = wlan_reg_get_num_rules_of_ap_pwr_type(pdev, REG_STANDARD_POWER_AP);
    num_vlp_rules = wlan_reg_get_num_rules_of_ap_pwr_type(pdev, REG_VERY_LOW_POWER_AP);

    if (!num_lpi_rules && !num_vlp_rules && num_sp_rules) {
        return true;
    }

    return false;
}

static inline void
wlan_copy_reg_chan_to_ieee80211_channel(struct ieee80211_channel *ieee_chan,
                                        struct regulatory_channel *reg_chan,
                                        enum reg_wifi_band reg_band,
                                        struct wlan_objmgr_pdev *pdev)
{
    switch (reg_band) {
            case REG_BAND_2G:
                 ieee_chan->band =  IEEE80211_BAND_2GHZ;
                 break;
            case REG_BAND_5G:
                 ieee_chan->band =  IEEE80211_BAND_5GHZ;
                 break;
            case REG_BAND_6G:
                 ieee_chan->band =  IEEE80211_BAND_6GHZ;
                 break;
            default:
                 return;
    }

    ieee_chan->flags = 0;

    if (wlan_reg_is_6ghz_chan_freq(reg_chan->center_freq)) {
        enum channel_enum chan_index = wlan_reg_get_chan_enum_for_freq(reg_chan->center_freq);

        /* Check for AFC_NOT_DONE only for SP only deployment inorder to avoid
         * incorrectly marking those channels as NO_IR which are not present in
         * super channel list, eventhough they are allowed in VLP operation.
         *
         * Use Super channel list to check for AFC_NOT_DONE as REG_BEST_PWR_MODE
         * is used for channel list population.
         */
        if (ieee80211_is_sp_only_deployment(pdev) &&
                !wlan_is_sup_chan_entry_afc_done(pdev, chan_index, REG_AP_SP)) {
            ieee_chan->flags |= IEEE80211_CHAN_NO_IR;
        }
    }

    ieee_chan->center_freq = reg_chan->center_freq;
    ieee_chan->hw_value = reg_chan->chan_num;

    ieee_chan->max_antenna_gain = reg_chan->ant_gain;
    ieee_chan->max_power = reg_chan->tx_power;
    ieee_chan->orig_flags = ieee_chan->flags;
}

/**
 * cfg80211_add_half_and_quarter_chans() - Add half and quarter rate channels
 * to the cfg80211_channel list.
 * @ieee_chan: Destination channel list for cfg80211.
 * @reg_chan: Regulatory 4.9G channel entry.
 * @num_channels: Number of channels in destination channel list.
 * @max_channels: Maximum number of channels allowed in destination channel list
 * @pdev: pdev ptr
 *
 * Return: Updated destination channel list pointer.
 */
static struct ieee80211_channel *
cfg80211_add_half_and_quarter_chans(struct ieee80211_channel *ieee_chan,
				    struct regulatory_channel *reg_chan,
				    int *num_channels, int max_channels,
                                    struct wlan_objmgr_pdev *pdev)
{
    int max_bw = reg_chan->max_bw;
    int min_bw = reg_chan->min_bw;

    for (; max_bw >= min_bw; max_bw /= 2) {
        if ((*num_channels + 1) > max_channels)
            return ieee_chan;

        wlan_copy_reg_chan_to_ieee80211_channel(ieee_chan, reg_chan,
                                                REG_BAND_5G, pdev);
        (*num_channels)++;
        ieee_chan++;
    }
    return ieee_chan;
}

/**
 *   wlan_cfg80211_populate_channels: This function populates channels list for
 *   given phymode and phyband.
 *   @ic: pointer to ieee80211com.
 *   @reg_band: regulatory band (2/5/6Ghz band).
 *   @dest_chan_list: pointer to channel list which needs to be filled.
 *   @max_channels: maximum channels allowed to be added to @channel_list
 *
 *   Return - number of channels populated
 */
int wlan_cfg80211_populate_channels(struct ieee80211com *ic,
                                    enum reg_wifi_band reg_band,
                                    struct ieee80211_channel *dest_chan_list,
                                    uint32_t max_channels)
{
    int i;
    int num_channels = 0;
    uint32_t nchan = 0;
    struct regulatory_channel *src_chan_list;

    qdf_debug("reg_band : %d, max_channels: %d", reg_band, max_channels);
    switch (reg_band) {
            case REG_BAND_2G:
                 nchan = NUM_24GHZ_CHANNELS;
                 break;
            case REG_BAND_5G:
                 nchan = NUM_5GHZ_CHANNELS + NUM_49GHZ_CHANNELS;
                 break;
            case REG_BAND_6G:
                 nchan = NUM_6GHZ_CHANNELS;
                 break;
            default:
                 return 0;
    }

    src_chan_list = qdf_mem_malloc(nchan *
                               sizeof(struct regulatory_channel));
    if (!src_chan_list) {
        qdf_err("Memory allocation failed for chan_list");
        return 0;
    }

    nchan = wlan_reg_get_band_channel_list_for_pwrmode(
                                           ic->ic_pdev_obj,
                                           BIT(reg_band),
                                           src_chan_list,
                                           REG_BEST_PWR_MODE,
                                           true);

    if (nchan > max_channels)
        nchan = max_channels;

    for (i = 0; i < nchan; i++) {
        if ((num_channels + 1) > max_channels)
            goto exit;

        if (WLAN_REG_IS_49GHZ_FREQ(src_chan_list[i].center_freq)) {
            dest_chan_list = cfg80211_add_half_and_quarter_chans(dest_chan_list,
                                    &src_chan_list[i],
                                    &num_channels,
                                    max_channels,
                                    ic->ic_pdev_obj);
        } else {
            wlan_copy_reg_chan_to_ieee80211_channel(dest_chan_list,
                                                    &src_chan_list[i],
                                                    reg_band, ic->ic_pdev_obj);
            num_channels++;
            dest_chan_list++;
        }
    }

exit:
    qdf_mem_free(src_chan_list);
    return num_channels;
}

/**
 *   wlan_cfg80211_populate_he_caps: This function populates HE caps
 *   for given band and ic
 *
 *   @ic: pointer to ieee80211com
 *   @band: underlying band
 *   @iftype_data: pointer to interface data.
 *   Return - 0 on succuss and Error value on failure
 */

#if CFG80211_SUPPORT_11AX_HOSTAPD
#define HEHANDLE_CAP_MACINFO_SIZE 2
int wlan_cfg80211_populate_he_caps(struct ieee80211com *ic,
        struct ieee80211_supported_band *band,
        struct ieee80211_sband_iftype_data *iftype_data)
{
    struct ieee80211_he_handle *ic_he;
    uint32_t hecap_phyinfo[HEHANDLE_CAP_PHYINFO_SIZE];
    uint32_t hecap_macinfo[HEHANDLE_CAP_MACINFO_SIZE];
    int i, idx = 0, j;

    if ((ic == NULL) || (band == NULL) || (iftype_data == NULL))
        return -EINVAL;

    ic_he = &ic->ic_he;
    if(ic_he == NULL)
        return -EINVAL;

    for (j = 0; j < NUM_NL80211_IFTYPES; j++) {
         if (!((j == NL80211_IFTYPE_AP) || (j == NL80211_IFTYPE_STATION)))
              continue;

         iftype_data[idx].he_cap.has_he =
                 (ic->ic_caps_ext & IEEE80211_CEXT_11AX) ? 1 : 0;

         if (!iftype_data[idx].he_cap.has_he)
             return -EOPNOTSUPP;

         iftype_data[idx].types_mask = BIT(j);

         band->n_iftype_data = 2;
         /* HE MAC capabilities */
         qdf_mem_copy(hecap_macinfo,
                      &ic_he->hecap_macinfo[0], HECAP_IE_MACINFO_SIZE);

         for (i=0; i<HEHANDLE_CAP_MACINFO_SIZE; i++) {
              hecap_macinfo[i] = cpu_to_le32(hecap_macinfo[i]);
         }

         qdf_mem_copy(&(iftype_data[idx].he_cap.he_cap_elem.mac_cap_info[0]),
                      hecap_macinfo, HECAP_IE_MACINFO_SIZE);

         /* HE Phy capabilities */
         for (i=0; i<HEHANDLE_CAP_PHYINFO_SIZE; i++) {
              hecap_phyinfo[i] = cpu_to_le32(ic_he->hecap_phyinfo[i]);
         }

         qdf_mem_copy(&(iftype_data[idx].he_cap.he_cap_elem.phy_cap_info[0]),
                      hecap_phyinfo,HECAP_PHYINFO_SIZE);

         /* HE Rx/Tx MCS map */
         iftype_data[idx].he_cap.he_mcs_nss_supp.rx_mcs_80 =
               cpu_to_le16(ic_he->hecap_rxmcsnssmap[HECAP_TXRX_MCS_NSS_IDX_80]);
         iftype_data[idx].he_cap.he_mcs_nss_supp.tx_mcs_80 =
               cpu_to_le16(ic_he->hecap_txmcsnssmap[HECAP_TXRX_MCS_NSS_IDX_80]);

         iftype_data[idx].he_cap.he_mcs_nss_supp.rx_mcs_160 =
               cpu_to_le16(ic_he->hecap_rxmcsnssmap[HECAP_TXRX_MCS_NSS_IDX_160]);
         iftype_data[idx].he_cap.he_mcs_nss_supp.tx_mcs_160 =
               cpu_to_le16(ic_he->hecap_txmcsnssmap[HECAP_TXRX_MCS_NSS_IDX_160]);

         iftype_data[idx].he_cap.he_mcs_nss_supp.rx_mcs_80p80 =
               cpu_to_le16(ic_he->hecap_rxmcsnssmap[HECAP_TXRX_MCS_NSS_IDX_80_80]);
         iftype_data[idx].he_cap.he_mcs_nss_supp.tx_mcs_80p80 =
               cpu_to_le16(ic_he->hecap_txmcsnssmap[HECAP_TXRX_MCS_NSS_IDX_80_80]);

         /* PPE Threshold  iftype_data->he_cap.ppe_thres ; */

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
         /* Fill 6g HE cap */
         iftype_data[idx].he_6ghz_capa.capa =
               cpu_to_le16(*((uint16_t *)ic_he->he6g_bandcap));
#endif
         idx++;
    }
    return 0;
}
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */

#ifdef WLAN_FEATURE_11BE
/**
 *   wlan_cfg80211_populate_eht_caps: This function populates HE caps
 *   for given band and ic
 *
 *   @ic: pointer to ieee80211com
 *   @band: underlying band
 *   @iftype_data: pointer to interface data.
 *   Return - 0 on succuss and Error value on failure
 */

int wlan_cfg80211_populate_eht_caps(struct ieee80211com *ic,
        struct ieee80211_supported_band *band,
        struct ieee80211_sband_iftype_data *iftype_data)
{
    struct ieee80211_eht_handle *ic_eht;
    struct ieee80211_sta_eht_cap *eht_cap;
    uint32_t ehtcap_phyinfo[EHTHANDLE_CAP_PHYINFO_SIZE];
    uint32_t ehtcap_macinfo[EHTHANDLE_CAP_MACINFO_SIZE];
    int i, idx = 0, j;

    if ((ic == NULL) || (band == NULL) || (iftype_data == NULL))
        return -EINVAL;

    ic_eht = &ic->ic_eht;
    if(ic_eht == NULL)
        return -EINVAL;

    for (j = 0; j < NUM_NL80211_IFTYPES; j++) {
         if (!((j == NL80211_IFTYPE_AP) || (j == NL80211_IFTYPE_STATION)))
             continue;

         eht_cap = &(iftype_data[idx].eht_cap);
         eht_cap->has_eht = (ic->ic_caps_ext & IEEE80211_CEXT_11BE) ? 1 : 0;

         if (!eht_cap->has_eht)
             return -EOPNOTSUPP;

         band->n_iftype_data = 2;
         iftype_data[idx].types_mask = BIT(j);

         /* EHT MAC capabilities */
         for (i=0; i<EHTHANDLE_CAP_MACINFO_SIZE; i++) {
              ehtcap_macinfo[i] = cpu_to_le32(ic_eht->ehtcap_macinfo[i]);
         }
         qdf_mem_copy(&eht_cap->eht_cap_elem.mac_cap_info[0],
                      ehtcap_macinfo, WLAN_EHT_MACCAP_LEN);
         /* EHT Phy capabilities */
         for (i=0; i<EHTHANDLE_CAP_PHYINFO_SIZE; i++) {
              ehtcap_phyinfo[i] = cpu_to_le32(ic_eht->ehtcap_phyinfo[i]);
         }

         qdf_mem_copy(&eht_cap->eht_cap_elem.phy_cap_info[0],
                      ehtcap_phyinfo, WLAN_EHT_PHYCAP_LEN);

         /* EHT Rx/Tx MCS map */
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
         eht_cap->eht_mcs_nss_supp.rx_mcs_80 =
            cpu_to_le16(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_80]);
         eht_cap->eht_mcs_nss_supp.tx_mcs_80 =
            cpu_to_le16(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_80]);

         eht_cap->eht_mcs_nss_supp.rx_mcs_160 =
            cpu_to_le16(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_160]);
         eht_cap->eht_mcs_nss_supp.tx_mcs_160 =
            cpu_to_le16(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_160]);

         eht_cap->eht_mcs_nss_supp.rx_mcs_320 =
            cpu_to_le16(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_320]);
         eht_cap->eht_mcs_nss_supp.tx_mcs_320 =
            cpu_to_le16(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_320]);
#else
         eht_cap->eht_mcs_nss_supp.bw._80.rx_tx_mcs9_max_nss =
            IEEE80211_GET_BITS(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_80],
                               EHT_MCS_MAP_RX_MCS_0_9);
         eht_cap->eht_mcs_nss_supp.bw._80.rx_tx_mcs9_max_nss |=
            (IEEE80211_GET_BITS(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_80],
                                EHT_MCS_MAP_TX_MCS_0_9) << 4);

         eht_cap->eht_mcs_nss_supp.bw._80.rx_tx_mcs11_max_nss =
            IEEE80211_GET_BITS(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_80],
                               EHT_MCS_MAP_RX_MCS_10_11);
         eht_cap->eht_mcs_nss_supp.bw._80.rx_tx_mcs11_max_nss |=
            (IEEE80211_GET_BITS(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_80],
                                EHT_MCS_MAP_TX_MCS_10_11) << 4);

         eht_cap->eht_mcs_nss_supp.bw._80.rx_tx_mcs13_max_nss =
            IEEE80211_GET_BITS(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_80],
                               EHT_MCS_MAP_RX_MCS_12_13);
         eht_cap->eht_mcs_nss_supp.bw._80.rx_tx_mcs13_max_nss |=
            (IEEE80211_GET_BITS(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_80],
                                EHT_MCS_MAP_TX_MCS_12_13) << 4);

         eht_cap->eht_mcs_nss_supp.bw._160.rx_tx_mcs9_max_nss =
            IEEE80211_GET_BITS(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_160],
                               EHT_MCS_MAP_RX_MCS_0_9);
         eht_cap->eht_mcs_nss_supp.bw._160.rx_tx_mcs9_max_nss |=
            (IEEE80211_GET_BITS(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_160],
                                EHT_MCS_MAP_TX_MCS_0_9) << 4);

         eht_cap->eht_mcs_nss_supp.bw._160.rx_tx_mcs11_max_nss =
            IEEE80211_GET_BITS(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_160],
                               EHT_MCS_MAP_RX_MCS_10_11);
         eht_cap->eht_mcs_nss_supp.bw._160.rx_tx_mcs11_max_nss |=
            (IEEE80211_GET_BITS(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_160],
                                EHT_MCS_MAP_TX_MCS_10_11) << 4);

         eht_cap->eht_mcs_nss_supp.bw._160.rx_tx_mcs13_max_nss =
            IEEE80211_GET_BITS(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_160],
                               EHT_MCS_MAP_RX_MCS_12_13);
         eht_cap->eht_mcs_nss_supp.bw._160.rx_tx_mcs13_max_nss |=
            (IEEE80211_GET_BITS(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_160],
                                EHT_MCS_MAP_TX_MCS_12_13) << 4);

         eht_cap->eht_mcs_nss_supp.bw._320.rx_tx_mcs9_max_nss =
            IEEE80211_GET_BITS(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_320],
                               EHT_MCS_MAP_RX_MCS_0_9);
         eht_cap->eht_mcs_nss_supp.bw._320.rx_tx_mcs9_max_nss |=
            (IEEE80211_GET_BITS(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_320],
                                EHT_MCS_MAP_TX_MCS_0_9) << 4);

         eht_cap->eht_mcs_nss_supp.bw._320.rx_tx_mcs11_max_nss =
            IEEE80211_GET_BITS(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_320],
                               EHT_MCS_MAP_RX_MCS_10_11);
         eht_cap->eht_mcs_nss_supp.bw._320.rx_tx_mcs11_max_nss |=
            (IEEE80211_GET_BITS(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_320],
                                EHT_MCS_MAP_TX_MCS_10_11) << 4);

         eht_cap->eht_mcs_nss_supp.bw._320.rx_tx_mcs13_max_nss =
            IEEE80211_GET_BITS(ic_eht->ehtcap_rxmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_320],
                               EHT_MCS_MAP_RX_MCS_12_13);
         eht_cap->eht_mcs_nss_supp.bw._320.rx_tx_mcs13_max_nss |=
            (IEEE80211_GET_BITS(ic_eht->ehtcap_txmcsnssmap[EHTCAP_TXRX_MCS_NSS_IDX_320],
                                EHT_MCS_MAP_TX_MCS_12_13) << 4);
#endif
         idx++;
    }
    return 0;
}
#endif /* WLAN_FEATURE_11BE */


/**
 *   wlan_cfg80211_populate_band_2g: This function populates ieee80211_supported_band
 *   data struccture, ic contains list of channel that are supported for that radio.
 *   populate channels, bitrates, HTcap and VHTcap for this radio.
 *   @ic: pointer to ieee80211com.
 *   @band: pointer to ieee80211_supported_band.
 *   @channel_list: pointer to channel list wihch needs to be filled.
 *   @max_channels: maximum channels allowed to be added to @channel_list
 *
 *   Return - number of channels updated in channel list
 */
int wlan_cfg80211_populate_band_2g(struct ieee80211com *ic,
        struct ieee80211_supported_band *band,
        struct ieee80211_channel *channel_list,
        uint32_t max_channels,
        struct ieee80211_sband_iftype_data *iftype_data)
{
    /* Fill band data struture */
    u16 mcs_map = 0, i = 0;

    if ((ic == NULL) || (band == NULL) || (channel_list == NULL) ||
         (iftype_data == NULL))
        return -EINVAL;

    band->channels = channel_list;
    band->n_channels = wlan_cfg80211_populate_channels(ic, REG_BAND_2G,
                                                       channel_list, max_channels);
    band->band = IEEE80211_BAND_2GHZ;
    band->bitrates = wlan_cfg80211_rates_2g;
    band->n_bitrates = wlan_cfg80211_rates_2g_size;
    band->ht_cap.ht_supported = (ic->ic_caps & IEEE80211_C_HT) ? 1 : 0;
    band->ht_cap.cap = ic->ic_htcap;
    band->ht_cap.ampdu_factor = ic->ic_maxampdu;
    band->ht_cap.ampdu_density = ic->ic_mpdudensity;
    for (i = 0; i < MIN(ic->ic_num_rx_chain, IEEE80211_MAX_11N_CHAINS); i++) {
        band->ht_cap.mcs.rx_mask[i] = 0xFF;
    }
    band->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
    /* vht not supported in 2G ???*/
    band->vht_cap.vht_supported = (ic->ic_caps_ext & IEEE80211_CEXT_11AC) ? 1 : 0;
    band->vht_cap.cap = ic->ic_vhtcap;

    for (i = 0; i < 8; i++) {
        if (i < ic->ic_num_rx_chain)
            mcs_map |= IEEE80211_VHT_MCS_SUPPORT_0_9 << (i*2);
        else
            mcs_map |= IEEE80211_VHT_MCS_NOT_SUPPORTED << (i*2);
    }

    band->vht_cap.vht_mcs.rx_mcs_map = cpu_to_le16(mcs_map);
    band->vht_cap.vht_mcs.tx_mcs_map = cpu_to_le16(mcs_map);
#if CFG80211_SUPPORT_11AX_HOSTAPD
    /* Fill HE cap capabilites */
    if (!wlan_cfg80211_populate_he_caps(ic, band, iftype_data)) {
        band->iftype_data = iftype_data;
    }
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */
#ifdef WLAN_FEATURE_11BE
    /* Fill EHT cap capabilites */
    if (!wlan_cfg80211_populate_eht_caps(ic, band, iftype_data)) {
        band->iftype_data = iftype_data;
    }
#endif /* WLAN_FEATURE_11BE */

    if (band->n_channels)
        ic->ic_supported_freq_bands.band_2ghz = true;

    return band->n_channels;
}

/**
 *   wlan_cfg80211_populate_band_5g: This function populates ieee80211_supported_band
 *   data struccture, ic contains list of channel that are supported for that radio.
 *   populate channels, bitrates, HTcap and VHTcap for this radio.
 *   @ic: pointer to ieee80211com.
 *   @band: pointer to ieee80211_supported_band.
 *   @channel_list: pointer to channel list wihch needs to be filled.
 *   @max_channels: maximum channels allowed to be added to @channel_list
 *
 *   Return - number of channels updated in channel list
 */
int wlan_cfg80211_populate_band_5g(struct ieee80211com *ic,
        struct ieee80211_supported_band *band,
        struct ieee80211_channel *channel_list,
        uint32_t max_channels,
        struct ieee80211_sband_iftype_data *iftype_data)
{
    /* Fill band data struture */
    u16 mcs_map = 0, i = 0;

    if ((ic == NULL) || (band == NULL) || (channel_list == NULL) ||
         (iftype_data == NULL))
        return -EINVAL;

    band->channels = channel_list;
    band->n_channels = wlan_cfg80211_populate_channels(ic, REG_BAND_5G, channel_list, max_channels);
    if (band->n_channels)
        ic->ic_supported_freq_bands.band_5ghz = true;
#if !CFG80211_SUPPORT_11AX_HOSTAPD
    /*
     * use 5 GHz band to populate 6 GHz channels if kernel does not
     * support 6GHz
     */
    band->n_channels += wlan_cfg80211_populate_channels(ic, REG_BAND_6G,
                                                        (channel_list + band->n_channels),
                                                        max_channels - band->n_channels);
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */
    band->band = IEEE80211_BAND_5GHZ;

    if (WLAN_REG_IS_49GHZ_FREQ(band->channels[i].center_freq)) {
        if (IEEE80211_IS_FLAG_HALF(ic->ic_chanbwflag)) {
            band->bitrates = wlan_cfg80211_rates_49g_half;
            band->n_bitrates = wlan_cfg80211_rates_49g_half_size;
        } else if (IEEE80211_IS_FLAG_QUARTER(ic->ic_chanbwflag)) {
            band->bitrates = wlan_cfg80211_rates_49g_quarter;
            band->n_bitrates = wlan_cfg80211_rates_49g_quarter_size;
        } else {
            band->bitrates = wlan_cfg80211_rates_5g;
            band->n_bitrates = wlan_cfg80211_rates_5g_size;
        }
    } else {
        band->bitrates = wlan_cfg80211_rates_5g;
        band->n_bitrates = wlan_cfg80211_rates_5g_size;
    }

    band->ht_cap.ht_supported = (ic->ic_caps & IEEE80211_C_HT) ? 1 : 0;
    band->ht_cap.cap = ic->ic_htcap;
    band->ht_cap.ampdu_factor = ic->ic_maxampdu;
    band->ht_cap.ampdu_density = ic->ic_mpdudensity;
    for (i = 0; i < MIN(ic->ic_num_rx_chain, IEEE80211_MAX_11N_CHAINS); i++) {
        band->ht_cap.mcs.rx_mask[i] = 0xFF;
    }
    band->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
    band->vht_cap.vht_supported = (ic->ic_caps_ext & IEEE80211_CEXT_11AC) ? 1 : 0;
    band->vht_cap.cap = ic->ic_vhtcap;

    for (i = 0; i < 8; i++) {
        if (i < ic->ic_num_rx_chain)
            mcs_map |= IEEE80211_VHT_MCS_SUPPORT_0_9 << (i*2);
        else
            mcs_map |= IEEE80211_VHT_MCS_NOT_SUPPORTED << (i*2);
    }

    band->vht_cap.vht_mcs.rx_mcs_map = cpu_to_le16(mcs_map);
    band->vht_cap.vht_mcs.tx_mcs_map = cpu_to_le16(mcs_map);
#if CFG80211_SUPPORT_11AX_HOSTAPD
    /* Fill HE cap capabilites */
    if (!wlan_cfg80211_populate_he_caps(ic, band, iftype_data)) {
        band->iftype_data = iftype_data;
    }
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */
#ifdef WLAN_FEATURE_11BE
    /* Fill EHT cap capabilites */
    if (!wlan_cfg80211_populate_eht_caps(ic, band, iftype_data)) {
        band->iftype_data = iftype_data;
    }
#endif /* WLAN_FEATURE_11BE */

    return band->n_channels;
}

#if CFG80211_SUPPORT_11AX_HOSTAPD
/**
 *   wlan_cfg80211_populate_band_6g: This function populates ieee80211_supported_band
 *   data struccture, ic contains list of channel that are supported for that radio.
 *   populate channels, bitrates and HE caps for this radio.
 *   @ic: pointer to ieee80211com.
 *   @band: pointer to ieee80211_supported_band.
 *   @channel_list: pointer to channel list wihch needs to be filled.
 *   @max_channels: maximum channels allowed to be added to @channel_list
 *
 *   Return - number of channels updated in channel list
 *			- Error value in case of any errors.
 */
int wlan_cfg80211_populate_band_6g(struct ieee80211com *ic,
        struct ieee80211_supported_band *band,
        struct ieee80211_channel *channel_list,
        uint32_t max_channels,
        struct ieee80211_sband_iftype_data *iftype_data)
{
    if ((ic == NULL) || (band == NULL) || (channel_list == NULL) ||
         (iftype_data == NULL))
        return -EINVAL;

    /* Fill band data struture */
    band->channels = channel_list;
    band->n_channels = wlan_cfg80211_populate_channels(ic, REG_BAND_6G,
                                                       channel_list, max_channels);

    band->band = IEEE80211_BAND_6GHZ;
    band->bitrates = wlan_cfg80211_rates_5g;
    band->n_bitrates = wlan_cfg80211_rates_5g_size;

    /* Fill HE cap capabilites */
    if (!wlan_cfg80211_populate_he_caps(ic, band, iftype_data)) {
        band->iftype_data = iftype_data;
    }

#ifdef WLAN_FEATURE_11BE
    /* Fill EHT cap capabilites */
    if (!wlan_cfg80211_populate_eht_caps(ic, band, iftype_data)) {
        band->iftype_data = iftype_data;
    }
#endif /* WLAN_FEATURE_11BE */

    if (band->n_channels)
        ic->ic_supported_freq_bands.band_6ghz = true;

    return band->n_channels;
}
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */

static void map_nl_reg_rule_flags(uint16_t drv_reg_rule_flag,
                                  uint32_t *regd_rule_flag)
{
    if (drv_reg_rule_flag & REGULATORY_CHAN_NO_IR)
        *regd_rule_flag |= NL80211_RRF_NO_IR;
    if (drv_reg_rule_flag & REGULATORY_CHAN_INDOOR_ONLY)
        *regd_rule_flag |= NL80211_RRF_NO_OUTDOOR;
    if (drv_reg_rule_flag & REGULATORY_CHAN_NO_OFDM)
        *regd_rule_flag |= NL80211_RRF_NO_OFDM;
    *regd_rule_flag |= NL80211_RRF_AUTO_BW;
}

/**
 * dfs_reg_to_nl80211_dfs_regions() - convert dfs_reg to nl80211_dfs_regions
 * @dfs_region: DFS region
 *
 * Return: nl80211_dfs_regions
 */
static enum nl80211_dfs_regions
dfs_reg_to_nl80211_dfs_regions(enum dfs_reg dfs_region)
{
    switch (dfs_region) {
        case DFS_UNINIT_REGION:
            return NL80211_DFS_UNSET;
        case DFS_FCC_REGION:
            return NL80211_DFS_FCC;
        case DFS_ETSI_REGION:
            return NL80211_DFS_ETSI;
        case DFS_MKK_REGION:
            return NL80211_DFS_JP;
        default:
            return NL80211_DFS_UNSET;
    }
}

/**
 * wlan_cfg80211_send_wiphy_regd_sync_event: set wiphy regd
 * @ic: pointer to ieee80211come structure
 * returns 0 on success and -1 on failure
 */
void wlan_cfg80211_send_wiphy_regd_sync_event(struct ieee80211com *ic)
{
    struct ieee80211_regdomain *regd;
    struct ieee80211_reg_rule *regd_rules;
    struct reg_rule_info reg_rules_struct;
    struct reg_rule_info *reg_rules;
    QDF_STATUS  status;
    uint8_t i, j = 0;
    bool is_unii1_found = false;
    bool stitch_unii_1_and_2_band = false;

    status = ucfg_reg_get_regd_rules(ic->ic_pdev_obj, &reg_rules_struct);
    if (QDF_IS_STATUS_ERROR(status)) {
        qdf_err("could not get reg rules");
        return;
    }

    reg_rules = &reg_rules_struct;
    if (!reg_rules->num_of_reg_rules) {
        qdf_err("no reg rules %d", reg_rules->num_of_reg_rules);
        return;
    }

    regd = qdf_mem_malloc((reg_rules->num_of_reg_rules *
                          sizeof(*regd_rules) + sizeof(*regd)));
    if (!regd) {
        qdf_err("memory allocation failed");
        return;
    }

    qdf_mem_copy(regd->alpha2, reg_rules->alpha2, REG_ALPHA2_LEN + 1);
    regd->dfs_region =
        dfs_reg_to_nl80211_dfs_regions(reg_rules->dfs_region);

    regd_rules = regd->reg_rules;
    qdf_debug("Regulatory Domain %s\n", regd->alpha2);
    qdf_debug("start freq\tend freq\t@ max_bw\tant_gain\tpwr\tflags\n");

    for (i = 0; i < reg_rules->num_of_reg_rules; i++) {
        if (reg_rules->reg_rules[i].start_freq == 5170 &&
            reg_rules->reg_rules[i].end_freq == 5250)
            is_unii1_found = true;
        if (reg_rules->reg_rules[i].start_freq  == 5250 &&
            reg_rules->reg_rules[i].end_freq == 5330 && is_unii1_found)
            stitch_unii_1_and_2_band = true;
    }

    for (i = 0; i < reg_rules->num_of_reg_rules; i++) {
        if (reg_rules->reg_rules[i].start_freq == 5170 &&
            reg_rules->reg_rules[i].end_freq == 5250 &&
            stitch_unii_1_and_2_band)
            continue;

        if (reg_rules->reg_rules[i].start_freq  == 5250 &&
            reg_rules->reg_rules[i].end_freq == 5330 &&
            stitch_unii_1_and_2_band) {
            reg_rules->reg_rules[i].start_freq  = 5170;
            reg_rules->reg_rules[i].max_bw  = 160;
        }

        regd_rules[j].freq_range.start_freq_khz =
            reg_rules->reg_rules[i].start_freq * 1000;
        regd_rules[j].freq_range.end_freq_khz =
            reg_rules->reg_rules[i].end_freq * 1000;
        regd_rules[j].freq_range.max_bandwidth_khz =
            reg_rules->reg_rules[i].max_bw * 1000;
        regd_rules[j].power_rule.max_antenna_gain =
            reg_rules->reg_rules[i].ant_gain * 100;
        regd_rules[j].power_rule.max_eirp =
            reg_rules->reg_rules[i].reg_power * 100;
        map_nl_reg_rule_flags(reg_rules->reg_rules[i].flags,
                              &regd_rules[j].flags);
        qdf_debug("Rule id : %d, %d KHz\t%d KHz\t@ %d KHz\t%d\t\t%d\t%d\n", j,
                  regd_rules[j].freq_range.start_freq_khz,
                  regd_rules[j].freq_range.end_freq_khz,
                  regd_rules[j].freq_range.max_bandwidth_khz,
                  regd_rules[j].power_rule.max_antenna_gain,
                  regd_rules[j].power_rule.max_eirp,
                  regd_rules[j].flags);
        j++;
    }
    regd->n_reg_rules = j;

    regulatory_set_wiphy_regd(ic->ic_wiphy, regd);

    qdf_mem_free(regd);
}

/**
 * wlan_cfg80211_update_channel_list: populate update channelist in wiphy
 * @ic: pointer to ieee80211come structure
 * returns 0 on success and -1 on failure
 */

int wlan_cfg80211_update_channel_list(struct ieee80211com *ic)
{
    struct ieee80211_supported_band *wlan_band_2g;
    struct ieee80211_supported_band *wlan_band_5g;
#if CFG80211_SUPPORT_11AX_HOSTAPD
    struct ieee80211_supported_band *wlan_band_6g;
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */
    unsigned int num_2g_channels = 0;
    unsigned int num_5g_channels = 0;
    unsigned int num_6g_channels = 0;
    struct wiphy *wiphy = NULL;

    if (!ic->ic_cfg80211_config ) {
        return -EINVAL;
    }

    wiphy = ic->ic_wiphy;
    wlan_band_2g = wiphy->bands[IEEE80211_BAND_2GHZ];
    wlan_band_5g = wiphy->bands[IEEE80211_BAND_5GHZ];
#if CFG80211_SUPPORT_11AX_HOSTAPD
    wlan_band_6g = wiphy->bands[IEEE80211_BAND_6GHZ];
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */

    /* Band and Channel information */
    num_2g_channels = wlan_cfg80211_get_num_channels(ic, REG_BAND_2G);
    if (num_2g_channels && (wlan_band_2g != NULL))
        wlan_cfg80211_populate_band_2g(ic, wlan_band_2g,
                ic->channel_list_g.channel_list, ic->channel_list_g.channel_list_size,
                ic->iftype_data_2g);

    num_5g_channels = wlan_cfg80211_get_num_channels(ic, REG_BAND_5G);
    num_6g_channels = wlan_cfg80211_get_num_channels(ic, REG_BAND_6G);
#if CFG80211_SUPPORT_11AX_HOSTAPD
    if (num_5g_channels && (wlan_band_5g != NULL)) {
        wlan_cfg80211_populate_band_5g(ic,
                &ic->wlan_band_5g, ic->channel_list_a.channel_list, ic->channel_list_a.channel_list_size,
                ic->iftype_data_5g);
    }

    if (num_6g_channels && (wlan_band_6g != NULL)) {
        wlan_cfg80211_populate_band_6g(ic,
                &ic->wlan_band_6g, ic->channel_list_6g.channel_list, ic->channel_list_6g.channel_list_size,
                ic->iftype_data_6g);
    }
#else
    /*
     * use 5 GHz band to populate 6 GHz channels if kernel does not
     * support 6GHz
     */
    if ((num_5g_channels + num_6g_channels) && (wlan_band_5g != NULL)) {
        wlan_cfg80211_populate_band_5g(ic,
                &ic->wlan_band_5g, ic->channel_list_a.channel_list, ic->channel_list_a.channel_list_size,
                ic->iftype_data_5g);
    }
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */
    QDF_TRACE(QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO,
            "number of channels: 2G = %d 5G = %d, 6G = %d",
            num_2g_channels, num_5g_channels, num_6g_channels);

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
    wlan_cfg80211_send_wiphy_regd_sync_event(ic);
#endif

    return 0;
}
qdf_export_symbol(wlan_cfg80211_update_channel_list);

int wlan_cfg80211_sched_mode_probe_resp_handler(
                wlan_if_t vap,
                struct wlan_host_sched_mode_probe_resp_event *evt_params)
{
    int ret = 0;
    struct ieee80211com *ic;
    osif_dev *osif;
    struct net_device *dev;

    if (!vap || !evt_params) {
        qdf_err("Invalid argument(s)");
        return -EINVAL;
    }

    ic = vap->iv_ic;
    if (!ic) {
        qdf_err("ic is null");
        return -EINVAL;
    }

    osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    if (!osif) {
        qdf_err("osif handle not found");
        return -EINVAL;
    }

    dev = osif->netdev;
    if (!dev) {
        qdf_err("netdev is null");
        return -EINVAL;
    }

    ret = send_sched_mode_probe_resp_event(ic->ic_wiphy,
                                           dev->ieee80211_ptr,
                                           evt_params);
    return ret;

}

#ifdef WLAN_FEATURE_11BE_MLO
QDF_STATUS wlan_cfg80211_mlo_link_removal_evt_handler(
                wlan_if_t vap,
                struct cfg80211_mlo_link_removal_evt_params *evt_params)
{
    int ret;
    struct ieee80211com *ic;
    osif_dev *osif;
    struct net_device *dev;

    if (!vap || !evt_params) {
        qdf_err("Invalid argument(s)");
        return QDF_STATUS_E_NULL_VALUE;
    }

    ic = vap->iv_ic;
    if (!ic) {
        qdf_err("ic is null");
        return QDF_STATUS_E_NULL_VALUE;
    }

    osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    dev = osif->netdev;

    ret = send_link_removal_tbtt_update_event(ic->ic_wiphy,
                                              dev->ieee80211_ptr,
                                              evt_params);

    return qdf_status_from_os_return(ret);
}
#endif

void wlan_cfg80211_register_vendor_cmd_event_handlers(struct ieee80211com *ic)
{
    ic->ic_wiphy->n_vendor_commands =
            ARRAY_SIZE(wlan_cfg80211_vendor_commands);
    ic->ic_wiphy->n_vendor_events   =
            ARRAY_SIZE(wlan_cfg80211_vendor_events);
    ic->ic_wiphy->vendor_commands   = wlan_cfg80211_vendor_commands;
    ic->ic_wiphy->vendor_events     = wlan_cfg80211_vendor_events;
}
qdf_export_symbol(wlan_cfg80211_register_vendor_cmd_event_handlers);

void wlan_cfg80211_unregister_vendor_cmd_event_handlers(struct ieee80211com *ic)
{
    ic->ic_wiphy->n_vendor_commands = 0;
    ic->ic_wiphy->n_vendor_events   = 0;
    ic->ic_wiphy->vendor_commands   = NULL;
    ic->ic_wiphy->vendor_events     = NULL;
}
qdf_export_symbol(wlan_cfg80211_unregister_vendor_cmd_event_handlers);

/**
 *   wlan_cfg80211_init: This function initilizes below wiphy params
 *   regulatory_flags, supported features, supported operating modes,
 *   channels supported and vendor commands/events.
 *   @dev: pointer to bus device structure.
 *   @net_dev: pointer to allocated netdevice for radio.
 *   @ic: pointer to ieee80211com.
 *
 *   returns 0/Error.
 */

int wlan_cfg80211_init(struct net_device *dev, struct wiphy *wiphy, struct ieee80211com *ic)
{
    int num_channels = 0;
    int num_5g_channels = 0;
    int num_6g_channels = 0;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
    struct ieee80211_regdomain *reg_domain = &wlan_cfg80211_world_regdom_60_61_62;
#endif
    struct wlan_objmgr_psoc *psoc = NULL;

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if (!psoc)
        return -1;

    wiphy->mgmt_stypes = wlan_cfg80211_txrx_stypes;

    /* This will disable updating of NL channels from passive to
     * active if a beacon is received on passive channel.*/

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
    wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;
#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
    wiphy->regulatory_flags = REGULATORY_COUNTRY_IE_IGNORE;
    wiphy->regulatory_flags |= REGULATORY_DISABLE_BEACON_HINTS;
    wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
#else
    wiphy->flags |= WIPHY_FLAG_DISABLE_BEACON_HINTS;
    wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
    wiphy->country_ie_pref = NL80211_COUNTRY_IE_IGNORE_CORE;
#endif

    /*
     * cfg80211 enables ps by default, clear WIPHY_FLAG_PS_ON_BY_DEFAULT
     * flag.
     */
    wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
    wiphy->flags |=  WIPHY_FLAG_4ADDR_AP
        | WIPHY_FLAG_AP_UAPSD
        | WIPHY_FLAG_REPORTS_OBSS
        | WIPHY_FLAG_4ADDR_STATION
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
        | WIPHY_FLAG_HAS_CHANNEL_SWITCH
#endif
        | WIPHY_FLAG_OFFCHAN_TX
        | WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
#endif

    wiphy->features = 0;    /* enum nl80211_feature_flags */
    wiphy->max_num_csa_counters = IEEE80211_MAX_CSA_TBTTCOUNT;
    /* scan params */
    wiphy->max_scan_ssids = IEEE80211_SCAN_MAX_SSID;
    wiphy->max_scan_ie_len = IEEE80211_MAX_IE_LEN;

    /* Regulatory callback */
    wiphy->reg_notifier = wlan_regulatory_notifier; /* not handling regulatory notifcation */
    wiphy->features |= NL80211_FEATURE_SK_TX_STATUS;    /* enum nl80211_feature_flags */
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
    wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS;
#endif

    wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE;
    wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;
    wiphy->features |= NL80211_FEATURE_FULL_AP_CLIENT_STATE;
    wiphy->features |= NL80211_FEATURE_SAE;
    /* driver supports per-vif TX power setting */
    wiphy->features |= NL80211_FEATURE_VIF_TXPOWER;

    /*
     * Supports AP and WDS-STA modes right now
     * enum nl80211_iftype
     */
    wiphy->interface_modes = BIT(NL80211_IFTYPE_AP)
        | BIT(NL80211_IFTYPE_STATION)
        | BIT(NL80211_IFTYPE_AP_VLAN)
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
#ifdef CONFIG_WIRELESS_WDS
        | BIT(NL80211_IFTYPE_WDS)
#endif
#else
        | BIT(NL80211_IFTYPE_WDS)
#endif
        | BIT(NL80211_IFTYPE_MONITOR);
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
    wiphy->n_iface_combinations =
        ARRAY_SIZE(wlan_cfg80211_iface_combination);
    wiphy->iface_combinations = wlan_cfg80211_iface_combination;
#endif

   wiphy->max_remain_on_channel_duration = IEEE80211_MAX_REMAIN_ON_CHANNEL;

    /* Band and Channel information */
    num_channels = wlan_cfg80211_get_num_channels(ic, REG_BAND_2G);
    if (num_channels) {
        qdf_debug("Number of 2G channels: %d ", num_channels);
        ic->channel_list_g.channel_list = (struct ieee80211_channel *)
            qdf_mem_malloc((sizeof(struct ieee80211_channel) * CFG80211_MAX_CHANNELS_2G));
        if (ic->channel_list_g.channel_list == NULL) {
            ic->channel_list_g.channel_list_size = 0;
            qdf_print("%s: Memory allocation failed ", __func__);
            return -1;
        }
        ic->channel_list_g.channel_list_size = CFG80211_MAX_CHANNELS_2G;
        ic->wlan_band_2g.channels = ic->channel_list_g.channel_list;
        ic->wlan_band_2g.n_channels = wlan_cfg80211_populate_band_2g(ic,
                &ic->wlan_band_2g, ic->channel_list_g.channel_list, ic->channel_list_g.channel_list_size,
                ic->iftype_data_2g);
        wiphy->bands[IEEE80211_BAND_2GHZ] = &ic->wlan_band_2g;
    }

    num_5g_channels = wlan_cfg80211_get_num_channels(ic, REG_BAND_5G);
    num_6g_channels = wlan_cfg80211_get_num_channels(ic, REG_BAND_6G);

#if CFG80211_SUPPORT_11AX_HOSTAPD
    if (num_5g_channels) {
        num_channels = CFG80211_MAX_CHANNELS_5G;
        ic->channel_list_a.channel_list = (struct ieee80211_channel *)
            qdf_mem_malloc((sizeof(struct ieee80211_channel) * num_channels));
        if (ic->channel_list_a.channel_list == NULL) {
            ic->channel_list_a.channel_list_size = 0;
            if (ic->channel_list_g.channel_list) {
                ic->channel_list_g.channel_list_size = 0;
                qdf_mem_free(ic->channel_list_g.channel_list);
                ic->channel_list_g.channel_list = NULL;
            }
            qdf_err("Memory allocation failed");
            return -ENOMEM;
        }
        ic->channel_list_a.channel_list_size = num_channels;
        wlan_cfg80211_populate_band_5g(ic,
                &ic->wlan_band_5g, ic->channel_list_a.channel_list, ic->channel_list_a.channel_list_size,
                ic->iftype_data_5g);

        wiphy->bands[IEEE80211_BAND_5GHZ] = &ic->wlan_band_5g;
    }

    if (num_6g_channels) {
        num_channels = CFG80211_MAX_CHANNELS_6G;
        ic->channel_list_6g.channel_list = (struct ieee80211_channel *)
            qdf_mem_malloc((sizeof(struct ieee80211_channel) * num_channels));
        if (ic->channel_list_6g.channel_list == NULL) {
            ic->channel_list_6g.channel_list_size = 0;
            if (ic->channel_list_g.channel_list) {
                ic->channel_list_g.channel_list_size = 0;
                qdf_mem_free(ic->channel_list_g.channel_list);
                ic->channel_list_g.channel_list = NULL;
            }
            if (ic->channel_list_a.channel_list) {
                ic->channel_list_a.channel_list_size = 0;
                qdf_mem_free(ic->channel_list_a.channel_list);
                ic->channel_list_a.channel_list = NULL;
            }
            qdf_err("Memory allocation failed");
            return -ENOMEM;
        }
        ic->channel_list_6g.channel_list_size = num_channels;
        wlan_cfg80211_populate_band_6g(ic,
                &ic->wlan_band_6g, ic->channel_list_6g.channel_list, ic->channel_list_6g.channel_list_size,
                ic->iftype_data_6g);

        wiphy->bands[IEEE80211_BAND_6GHZ] = &ic->wlan_band_6g;
    }
#else
    /*
     * use 5 GHz band to populate 6 GHz channels if kernel does not
     * support 6GHz
     */
    if (num_5g_channels || num_6g_channels) {
        num_channels = CFG80211_MAX_CHANNELS_5G + CFG80211_MAX_CHANNELS_6G;
        ic->channel_list_a.channel_list = (struct ieee80211_channel *)
            qdf_mem_malloc((sizeof(struct ieee80211_channel) * num_channels));
        if (ic->channel_list_a.channel_list == NULL) {
            ic->channel_list_a.channel_list_size = 0;
            if (ic->channel_list_g.channel_list) {
                ic->channel_list_g.channel_list_size = 0;
                qdf_mem_free(ic->channel_list_g.channel_list);
                ic->channel_list_g.channel_list = NULL;
            }
            qdf_err("Memory allocation failed");
            return -ENOMEM;
        }
        ic->channel_list_a.channel_list_size = num_channels;

        wlan_cfg80211_populate_band_5g(ic,
                &ic->wlan_band_5g, ic->channel_list_a.channel_list, ic->channel_list_a.channel_list_size);

        wiphy->bands[IEEE80211_BAND_5GHZ] = &ic->wlan_band_5g;
    }
#endif /* CFG80211_SUPPORT_11AX_HOSTAPD */

    /* Initialise the supported cipher suite details */
    wiphy->cipher_suites = wlan_cfg80211_cipher_suites;
    wiphy->n_cipher_suites = ARRAY_SIZE(wlan_cfg80211_cipher_suites);

    /*signal strength in mBm (100*dBm) */
    wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
    /* Initilize TX/RX chain masks */
    wiphy->available_antennas_tx = ic->ic_tx_chainmask;
    wiphy->available_antennas_rx = ic->ic_rx_chainmask;

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
    wiphy->n_vendor_commands =
        ARRAY_SIZE(wlan_cfg80211_vendor_commands);
    wiphy->vendor_commands = wlan_cfg80211_vendor_commands;

    wiphy->vendor_events = wlan_cfg80211_vendor_events;
    wiphy->n_vendor_events =
        ARRAY_SIZE(wlan_cfg80211_vendor_events);
#endif

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
    /*TODO: lets populate max peers in ic for both DC and OL */;
    wiphy->max_ap_assoc_sta = CFG_TGT_NUM_PEERS_MAX;
#endif

#if defined(WLAN_SUPPORT_FILS) && !defined(ATH_SUPPORT_DISABLE_FILSCRYPTO_OFFLOAD)
    wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_FILS_CRYPTO_OFFLOAD);
#endif /* defined(WLAN_SUPPORT_FILS) && !defined(ATH_SUPPORT_DISABLE_FILSCRYPTO_OFFLOAD) */

#if QCA_MULTIPASS_SUPPORT
    wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_VLAN_OFFLOAD);
#endif

    if (wlan_pdev_nif_feat_cap_get(ic->ic_pdev_obj,
                                   WLAN_PDEV_F_BEACON_PROTECTION))
    {
        wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_PROTECTION);
    }
#ifdef QCA_SUPPORT_EAPOL_OVER_CONTROL_PORT
    if (ic->enable_eapol_over_nl) {
        wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS);
        wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH);
        wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211);
    }
#endif
#if defined(WLAN_FEATURE_11BE)
    /*
     * This feature flag need to be set based on IEEE80211_CEXT_11BE_MLO flag
     * in ic_caps_ext.
     * Once IEEE80211_CEXT_11BE_MLO is populated in taget_if layer this will be
     * updated.
     */
#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
    wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_MLO);
#else
    wiphy->flags |= WIPHY_FLAG_SUPPORTS_MLO;
#endif
#endif
#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
    wiphy_apply_custom_regulatory(wiphy, reg_domain);
#endif

#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT)
    wlan_wifi_pos_cfg80211_set_wiphy_ext_feature(wiphy, psoc);
#endif

    /* Register to cfg80211 */
    wlan_cfg80211_register(wiphy);

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
    wlan_cfg80211_send_wiphy_regd_sync_event(ic);
#endif

#ifdef WLAN_FEATURE_11BE
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
#ifdef CFG80211_PUNCTURING_SINGLE_NETDEV_API
    wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_PUNCT);
#endif
#endif
#endif
    wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_SET_SCAN_DWELL);

    return 0;
}

#ifdef WLAN_MLO_MULTI_CHIP
/**
 *   ieee80211_cfg80211_mld_wiphy_detach: detach wiphy/cfg80211 device
 *   This function unregisters and frees datastructures.
 *   @psoc: pointer to psoc
 *   @setup_mlo: pointer to mlo setup status
 *
 *   returns 0/Error.
 */
int ieee80211_cfg80211_mld_wiphy_detach(struct wlan_objmgr_psoc *psoc,
                                        struct mlo_setup_info *setup_mlo,
                                        struct ieee80211com *ic)
{
    struct cfg80211_mld_wiphy_context *mld_cfg_ctx;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct cfg80211_context *mld_wiphy_priv = NULL;
#else
    struct cfg80211_mld_wiphy_priv *mld_wiphy_priv = NULL;
#endif
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    struct net_device *netdev;
#endif
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct net_device *reg_netdev;
    uint32_t netdev_count;
#endif
    bool is_mlo_capable;
    uint8_t grp_id;
    uint8_t mld_interface_remain = 0;
    struct osif_mldev *mldev;
    int i;

    grp_id = wlan_mlo_get_psoc_group_id(psoc);
    if (grp_id >= WLAN_MAX_MLO_GROUPS) {
        qdf_err("grp_id is invalid");
        return 0;
    }

    mld_cfg_ctx = &mld_wiphy_ctx[grp_id];

    qdf_debug("The group_id of the psoc is:%d", grp_id);

    if (!mld_cfg_ctx->mld_wiphy) {
        return 0;
    }

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    mld_wiphy_priv = (struct cfg80211_context *)wiphy_priv(mld_cfg_ctx->mld_wiphy);
#else
    mld_wiphy_priv = (struct cfg80211_mld_wiphy_priv *)wiphy_priv(mld_cfg_ctx->mld_wiphy);
#endif

    is_mlo_capable = ic->ic_mlo_capable(psoc);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    reg_netdev = ic->ic_wdev.netdev;

    if (reg_netdev && reg_netdev->reg_state == NETREG_REGISTERED) {
        unregister_netdev(reg_netdev);
    }

    wlan_cfg80211_free_clone_params_list(ic);

    qdf_atomic_dec(&mld_wiphy_priv->netdev_count);
    netdev_count = qdf_atomic_read(&mld_wiphy_priv->netdev_count);
    if (is_mlo_capable && netdev_count == 0) {
#else
    if (is_mlo_capable) {
#endif
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
        netdev = mld_wiphy_priv->mld_netdev;
#endif
        /* Check for any MLDs still present and remove them */
        mld_interface_remain = qdf_atomic_read(&mld_wiphy_priv->mld_count);
        if (mld_interface_remain) {
            qdf_err("Number of MLD intefaces still not deleted: %d\n", mld_interface_remain);
            for (i=0; i<MAX_OSIF_MLDEV; i++) {
                if (mld_wiphy_priv->mldev[i]) {
                    mldev = mld_wiphy_priv->mldev[i];
                    if (mldev->mld_dev) {
                        qdf_debug("mld_mac_addr %s, dev_mac_addr %s\n", ether_sprintf(mldev->mld_mac_addr), ether_sprintf(mldev->mld_dev->dev_addr));
                    }
                }
            }
        } else {
            qdf_debug("All MLD intefaces are deleted");
        }

#ifndef ENABLE_CFG80211_BACKPORTS_MLO
        if (netdev && netdev->reg_state == NETREG_REGISTERED) {
            unregister_netdev(netdev);
        }
#endif

#if DBDC_REPEATER_SUPPORT
        qca_multi_link_del_mld_wiphy(mld_cfg_ctx->mld_wiphy);
#endif

        wlan_cfg80211_unregister(mld_cfg_ctx->mld_wiphy);
        wlan_cfg80211_free(mld_cfg_ctx->mld_wiphy);

#ifndef ENABLE_CFG80211_BACKPORTS_MLO
        if (netdev) {
            free_netdev(netdev);
        }
#endif

        if (mld_cfg_ctx->channel_list_g.channel_list) {
            qdf_mem_free(mld_cfg_ctx->channel_list_g.channel_list);
            mld_cfg_ctx->channel_list_g.channel_list_size = 0;
            mld_cfg_ctx->channel_list_g.channel_list = NULL;
        }
        if (mld_cfg_ctx->channel_list_a.channel_list) {
            qdf_mem_free(mld_cfg_ctx->channel_list_a.channel_list);
            mld_cfg_ctx->channel_list_a.channel_list_size = 0;
            mld_cfg_ctx->channel_list_a.channel_list = NULL;
        }
        if (mld_cfg_ctx->channel_list_6g.channel_list) {
            qdf_mem_free(mld_cfg_ctx->channel_list_6g.channel_list);
            mld_cfg_ctx->channel_list_6g.channel_list_size = 0;
            mld_cfg_ctx->channel_list_6g.channel_list = NULL;
        }

        mld_cfg_ctx->mld_wiphy = NULL;
    }

    return 0;
}
qdf_export_symbol(ieee80211_cfg80211_mld_wiphy_detach);

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
/**
 *   ieee80211_cfg80211_mld_update_wiphy_caps: update mld_wiphy caps for
 *   successive radios. This function updates the wiphy flags and caps if
 *   specific to radio update is needed.
 *   @wiphy: pointer to wiphy
 *   @mld_cfg_ctx: pointer to mld wiphy context
 *   @ic: ieee80211com pointer
 *   @setup_mlo: pointer to mlo setup status
 *
 *   returns 0/Error.
 */
int ieee80211_cfg80211_mld_wiphy_update_caps(struct wiphy *wiphy,
      struct cfg80211_mld_wiphy_context *mld_cfg_ctx, struct ieee80211com *ic,
      struct mlo_setup_info *setup_mlo)
{
    if (wiphy->available_antennas_tx < ic->ic_tx_chainmask) {
        wiphy->available_antennas_tx = ic->ic_tx_chainmask;
    }

    if (wiphy->available_antennas_rx < ic->ic_rx_chainmask) {
        wiphy->available_antennas_rx = ic->ic_rx_chainmask;
    }

    return 0;
}
#endif

/**
 *   ieee80211_cfg80211_mld_wiphy_update_band: update band info for mld_wiphy
 *   This function updates channels and band information for mld_wiphy
 *   @wiphy: pointer to wiphy
 *   @mld_cfg_ctx: pointer to mld wiphy context
 *   @ic: ieee80211com pointer
 *   @setup_mlo: pointer to mlo setup status
 *
 *   returns 0/Error.
 */
int ieee80211_cfg80211_mld_wiphy_update_band (struct wiphy *wiphy,
       struct cfg80211_mld_wiphy_context *mld_cfg_ctx, struct ieee80211com *ic,
       struct mlo_setup_info *setup_mlo)
{
    uint8_t num_2g_channels = 0, num_5g_channels = 0, num_6g_channels = 0;
    uint8_t  idx_2g_chan  = 0, idx_5g_chan = 0, idx_6g_chan = 0;

    num_2g_channels = wlan_cfg80211_get_num_channels(ic, REG_BAND_2G);
    if (num_2g_channels) {
        wiphy->bands[IEEE80211_BAND_2GHZ] = &mld_cfg_ctx->wlan_band_2g;
        wlan_cfg80211_populate_band_2g(ic,
                &mld_cfg_ctx->wlan_band_2g,
                &mld_cfg_ctx->channel_list_g.channel_list[idx_2g_chan],
                mld_cfg_ctx->channel_list_g.channel_list_size,
                mld_cfg_ctx->iftype_data_2g);
    }

    num_5g_channels = wlan_cfg80211_get_num_channels(ic, REG_BAND_5G);
    if (num_5g_channels) {
        wiphy->bands[IEEE80211_BAND_5GHZ] = &mld_cfg_ctx->wlan_band_5g;
        wlan_cfg80211_populate_band_5g(ic,
                &mld_cfg_ctx->wlan_band_5g,
                &mld_cfg_ctx->channel_list_a.channel_list[idx_5g_chan],
                mld_cfg_ctx->channel_list_a.channel_list_size,
                mld_cfg_ctx->iftype_data_5g);
    }

    num_6g_channels = wlan_cfg80211_get_num_channels(ic, REG_BAND_6G);
    if (num_6g_channels) {
        wiphy->bands[IEEE80211_BAND_6GHZ] = &mld_cfg_ctx->wlan_band_6g;
        wlan_cfg80211_populate_band_6g(ic,
                &mld_cfg_ctx->wlan_band_6g,
                &mld_cfg_ctx->channel_list_6g.channel_list[idx_6g_chan],
                mld_cfg_ctx->channel_list_6g.channel_list_size,
                mld_cfg_ctx->iftype_data_6g);
    }

    if (mld_cfg_ctx->radio_cnt >= NUM_MAX_RADIOS) {
       qdf_err("INVALID MLD GROUP INDEX");
    } else {
       mld_cfg_ctx->ic[mld_cfg_ctx->radio_cnt] = ic;
       mld_cfg_ctx->radio_cnt++;
    }

    qdf_info("Number of 2G Channels: %d 5G Channels: %d 6G Channels: %d ",
             num_2g_channels, num_5g_channels, num_6g_channels);

    return 0;
}

/**
 *   ieee80211_cfg80211_mld_wiphy_alloc_register: allocate memory for mld_wiphy
 *   and update flags for mld_wiphy
 *   @dev: pointer to bus device structure
 *   @net_dev: pointer to allocated netdevice for radio.
 *   @ic: ieee80211com pointer
 *   @setup_mlo: pointer to mlo setup status
 *
 *   returns 0/Error.
 */
int ieee80211_cfg80211_mld_wiphy_alloc_register (struct device *dev,
                           struct net_device *net_dev, struct ieee80211com *ic,
                           struct mlo_setup_info *setup_mlo)
{
    struct cfg80211_mld_wiphy_context *mld_cfg_ctx = NULL;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct cfg80211_context *mld_wiphy_priv = NULL;
#else
    struct cfg80211_mld_wiphy_priv *mld_wiphy_priv = NULL;
#endif

    struct wiphy *wiphy = NULL;
    uint8_t grp_id;
    char string[MLD_PHY_NAME];
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    char netdev_name[MLD_PHY_NAME];
    struct net_device *singlewiphy_net_dev = NULL;
    struct singlewiphy_netdev_ctx *singlewiphy_mld_ctx;
    int error = 0;
#endif
#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
    struct ieee80211_regdomain *reg_domain = &wlan_cfg80211_world_regdom_60_61_62;
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct wlan_objmgr_psoc *psoc = NULL;

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if (!psoc)
        return -1;
#endif

    grp_id = setup_mlo->ml_grp_id;
    qdf_debug("The group_id of the psoc is:%d", grp_id);

    snprintf(string, MLD_PHY_NAME, "mld-phy%d", grp_id);

#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    snprintf(netdev_name, MLD_PHY_NAME, "mld-wifi%d", grp_id);

    singlewiphy_net_dev = alloc_netdev(sizeof(struct singlewiphy_netdev_ctx), netdev_name, 0, ether_setup);
    if (singlewiphy_net_dev == NULL) {
        qdf_err("Failed to create netdevice for mld-wifi%d", grp_id);
        return -1;
    }

#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    wiphy = wiphy_new_nm(&wlan_cfg80211_ops, sizeof(struct cfg80211_context), string);
#else
    wiphy = wiphy_new_nm(&wlan_mld_cfg80211_ops, sizeof(struct cfg80211_mld_wiphy_priv), string);
    singlewiphy_mld_ctx = ath_netdev_priv(singlewiphy_net_dev);

    if (singlewiphy_mld_ctx == NULL) {
        qdf_err("singlewiphy_mld_ctx is NULL");
        return -1;
    }

    memset(singlewiphy_mld_ctx, 0, sizeof(struct singlewiphy_netdev_ctx));
#endif

    if (wiphy == NULL) {
        qdf_err("wiphy is not created");
        return -1;
    }

#if DBDC_REPEATER_SUPPORT
    qca_multi_link_add_mld_wiphy(wiphy);
#endif

#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    /* Link allocated singlewiphy netdev context with wiphy */
    singlewiphy_mld_ctx->wdev.wiphy = wiphy;
    singlewiphy_mld_ctx->wdev.iftype = NL80211_IFTYPE_AP;
    singlewiphy_mld_ctx->wdev.netdev = singlewiphy_net_dev;
    singlewiphy_mld_ctx->mld_dev = singlewiphy_net_dev;

    singlewiphy_net_dev->ieee80211_ptr = &singlewiphy_mld_ctx->wdev;
    singlewiphy_net_dev->netdev_ops = &singlewiphy_netdev;
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    mld_wiphy_priv = (struct cfg80211_context *)wiphy_priv(wiphy);
#else
    mld_wiphy_priv = (struct cfg80211_mld_wiphy_priv *)wiphy_priv(wiphy);
#endif

    mld_wiphy_priv->mld_wiphy = wiphy;
#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    mld_wiphy_priv->mld_netdev = singlewiphy_net_dev;
#endif
    mld_wiphy_priv->ml_grp_id = grp_id;
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    mld_wiphy_priv->is_mld_phy = true;
#endif
    qdf_atomic_init(&mld_wiphy_priv->mld_count);

    mld_cfg_ctx = &mld_wiphy_ctx[grp_id];
    mld_cfg_ctx->mld_wiphy = wiphy;
    mld_cfg_ctx->is_created = true;

    wiphy->mgmt_stypes = wlan_cfg80211_txrx_stypes;

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
    wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;
#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
    wiphy->regulatory_flags = REGULATORY_COUNTRY_IE_IGNORE;
    wiphy->regulatory_flags |= REGULATORY_DISABLE_BEACON_HINTS;
    wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
#else
    wiphy->flags |= WIPHY_FLAG_DISABLE_BEACON_HINTS;
    wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
    wiphy->country_ie_pref = NL80211_COUNTRY_IE_IGNORE_CORE;
#endif

    /*
     * cfg80211 enables ps by default, clear WIPHY_FLAG_PS_ON_BY_DEFAULT
     * flag.
     */
    wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
    wiphy->flags |=  WIPHY_FLAG_4ADDR_AP
        | WIPHY_FLAG_AP_UAPSD
        | WIPHY_FLAG_REPORTS_OBSS
        | WIPHY_FLAG_4ADDR_STATION
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
        | WIPHY_FLAG_HAS_CHANNEL_SWITCH
#endif
        | WIPHY_FLAG_OFFCHAN_TX
        | WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    wiphy->flags |=  WIPHY_FLAG_SUPPORTS_MLO;
#endif

#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_PUNCT);
#endif

    wiphy->features = 0;
    wiphy->max_num_csa_counters = IEEE80211_MAX_CSA_TBTTCOUNT;
    /* scan params */
    wiphy->max_scan_ssids = IEEE80211_SCAN_MAX_SSID;
    wiphy->max_scan_ie_len = IEEE80211_MAX_IE_LEN;

    /* Regulatory callback */
    wiphy->reg_notifier = wlan_regulatory_notifier; /* not handling regulatory notifcation */
    wiphy->features |= NL80211_FEATURE_SK_TX_STATUS;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
    wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS;
#endif

    wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE;
    wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;
    wiphy->features |= NL80211_FEATURE_FULL_AP_CLIENT_STATE;
    wiphy->features |= NL80211_FEATURE_SAE;

    /* driver supports per-vif TX power setting */
    wiphy->features |= NL80211_FEATURE_VIF_TXPOWER;

    /*
     * Supports AP and WDS-STA modes right now
     * enum nl80211_iftype
     */
    wiphy->interface_modes = BIT(NL80211_IFTYPE_AP)
        | BIT(NL80211_IFTYPE_STATION)
        | BIT(NL80211_IFTYPE_AP_VLAN)
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
#ifdef CONFIG_WIRELESS_WDS
        | BIT(NL80211_IFTYPE_WDS)
#endif
#else
        | BIT(NL80211_IFTYPE_WDS)
#endif
        | BIT(NL80211_IFTYPE_MONITOR);
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
    wiphy->n_iface_combinations =
        ARRAY_SIZE(wlan_cfg80211_iface_combination);
    wiphy->iface_combinations = wlan_cfg80211_iface_combination;
#endif
    wiphy->max_remain_on_channel_duration = IEEE80211_MAX_REMAIN_ON_CHANNEL;

    /*
     * Allocate all channel list for 2G, 5G and 6G
     */
    mld_cfg_ctx->channel_list_g.channel_list = (struct ieee80211_channel *)
        qdf_mem_malloc((sizeof(struct ieee80211_channel) * CFG80211_MAX_CHANNELS_2G));

    if (mld_cfg_ctx->channel_list_g.channel_list == NULL) {
        mld_cfg_ctx->channel_list_g.channel_list_size = 0;
        qdf_err("%s: Memory allocation failed ", __func__);
        return -1;
    } else {
        mld_cfg_ctx->channel_list_g.channel_list_size = CFG80211_MAX_CHANNELS_2G;
        mld_cfg_ctx->wlan_band_2g.channels = mld_cfg_ctx->channel_list_g.channel_list;
    }

    mld_cfg_ctx->channel_list_a.channel_list = (struct ieee80211_channel *)
        qdf_mem_malloc((sizeof(struct ieee80211_channel) * CFG80211_MAX_CHANNELS_5G));
    if (mld_cfg_ctx->channel_list_a.channel_list == NULL) {
        mld_cfg_ctx->channel_list_a.channel_list_size = 0;
        qdf_err("%s: Memory allocation failed ", __func__);
        qdf_mem_free(mld_cfg_ctx->channel_list_g.channel_list);
        return -1;
    } else {
        mld_cfg_ctx->channel_list_a.channel_list_size = CFG80211_MAX_CHANNELS_5G;
        mld_cfg_ctx->wlan_band_5g.channels = mld_cfg_ctx->channel_list_a.channel_list;
    }

    mld_cfg_ctx->channel_list_6g.channel_list = (struct ieee80211_channel *)
        qdf_mem_malloc((sizeof(struct ieee80211_channel) * CFG80211_MAX_CHANNELS_6G));
    if (mld_cfg_ctx->channel_list_6g.channel_list == NULL) {
        mld_cfg_ctx->channel_list_6g.channel_list_size = 0;
        qdf_err("%s: Memory allocation failed ", __func__);
        qdf_mem_free(mld_cfg_ctx->channel_list_g.channel_list);
        qdf_mem_free(mld_cfg_ctx->channel_list_a.channel_list);
        return -1;
    } else {
        mld_cfg_ctx->channel_list_6g.channel_list_size = CFG80211_MAX_CHANNELS_6G;
        mld_cfg_ctx->wlan_band_6g.channels = mld_cfg_ctx->channel_list_6g.channel_list;
    }

    /* Initialise the supported cipher suite details */
    wiphy->cipher_suites = wlan_cfg80211_cipher_suites;
    wiphy->n_cipher_suites = ARRAY_SIZE(wlan_cfg80211_cipher_suites);

    /*signal strength in mBm (100*dBm) */
    wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
    /* Initilize TX/RX chain masks */
    wiphy->available_antennas_tx = ic->ic_tx_chainmask;
    wiphy->available_antennas_rx = ic->ic_rx_chainmask;

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
    wiphy->n_vendor_commands =
        ARRAY_SIZE(wlan_cfg80211_vendor_commands);
    wiphy->vendor_commands = wlan_cfg80211_vendor_commands;

    wiphy->vendor_events = wlan_cfg80211_vendor_events;
    wiphy->n_vendor_events =
        ARRAY_SIZE(wlan_cfg80211_vendor_events);
#endif

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
    wiphy->max_ap_assoc_sta = CFG_TGT_NUM_PEERS_MAX;
#endif

#if defined(WLAN_SUPPORT_FILS) && !defined(ATH_SUPPORT_DISABLE_FILSCRYPTO_OFFLOAD)
    wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_FILS_CRYPTO_OFFLOAD);
#endif /* defined(WLAN_SUPPORT_FILS) && !defined(ATH_SUPPORT_DISABLE_FILSCRYPTO_OFFLOAD) */

#if QCA_MULTIPASS_SUPPORT
    wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_VLAN_OFFLOAD);
#endif

    if (wlan_pdev_nif_feat_cap_get(ic->ic_pdev_obj,
                                   WLAN_PDEV_F_BEACON_PROTECTION))
    {
        wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_PROTECTION);
    }
#ifdef QCA_SUPPORT_EAPOL_OVER_CONTROL_PORT
    if (ic->enable_eapol_over_nl) {
        wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS);
        wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH);
        wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211);
    }
#endif

    /*
     * This feature flag need to be set based on IEEE80211_CEXT_11BE_MLO flag
     * in ic_caps_ext.
     * Once IEEE80211_CEXT_11BE_MLO is populated in taget_if layer this will be
     * updated.
     */
#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
    wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_MLO);
#else
    wiphy->flags |= WIPHY_FLAG_SUPPORTS_MLO;
#endif

#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
    wiphy_apply_custom_regulatory(wiphy, reg_domain);
#endif

#if defined(WIFI_POS_CONVERGED) && defined(WLAN_FEATURE_RTT_11AZ_SUPPORT) && defined(ENABLE_CFG80211_BACKPORTS_MLO)
    wlan_wifi_pos_cfg80211_set_wiphy_ext_feature(wiphy, psoc);
#endif

    ieee80211_cfg80211_mld_wiphy_update_band(wiphy, mld_cfg_ctx, ic, setup_mlo);
    /* Register to cfg80211 */
    wlan_cfg80211_register(wiphy);

#ifndef ENABLE_CFG80211_BACKPORTS_MLO
    /* Register singlewiphy netdev */
    if ((error = register_netdev(singlewiphy_net_dev)) != 0) {
        qdf_err("Couldn't register netdev");
        return -1;
    }
#endif

    return 0;
}

/**
 *   ieee80211_cfg80211_mld_wiphy_attach: allocate memory and update bands for
 *   mld_wiphy
 *   @dev: pointer to bus device structure
 *   @net_dev: pointer to allocated netdevice for radio
 *   @ic: ieee80211com pointer
 *   @setup_mlo: pointer to mlo setup status
 *
 *   returns 0/Error.
 */
int ieee80211_cfg80211_mld_wiphy_attach(struct device *dev,
                           struct net_device *net_dev, struct ieee80211com *ic,
                           struct mlo_setup_info *setup_mlo)
{
    struct cfg80211_mld_wiphy_context *mld_cfg_ctx = NULL;
    struct wiphy *wiphy = NULL;
    uint8_t grp_id;

    grp_id = setup_mlo->ml_grp_id;

    qdf_debug("The group_id of the psoc is:%d", grp_id);

    mld_cfg_ctx = &mld_wiphy_ctx[grp_id];

    if (mld_cfg_ctx == NULL) {
        qdf_err("mld_cfg_ctx is NULL");
        return -1;
    }

    wiphy = mld_cfg_ctx->mld_wiphy;

    if (wiphy == NULL) {
        ieee80211_cfg80211_mld_wiphy_alloc_register(dev, net_dev, ic, setup_mlo);
    } else {
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
        ieee80211_cfg80211_mld_wiphy_update_caps(wiphy, mld_cfg_ctx, ic, setup_mlo);
#endif
        ieee80211_cfg80211_mld_wiphy_update_band(wiphy, mld_cfg_ctx, ic, setup_mlo);
    }

    return 0;
}
qdf_export_symbol(ieee80211_cfg80211_mld_wiphy_attach);
#endif

#ifdef WLAN_MLO_MULTI_CHIP
/**
 *   ieee80211_cfg80211_radio_attach: Attach wiphy/cfg80211 dev to kernel.
 *   This function initilizes wiphy data structures, callback etc .. and registers
 *   with kernel.
 *   @dev: pointer to bus device structure.
 *   @net_dev: pointer to allocated netdevice for radio.
 *   @ic: pointer to ieee80211com.
 *   @setup_mlo: pointer to mlo setup status
 *
 *   returns 0/Error.
 */
int ieee80211_cfg80211_radio_attach(struct device *dev,
                           struct net_device *net_dev, struct ieee80211com *ic,
                           struct mlo_setup_info *setup_mlo)
#else
/**
 *   ieee80211_cfg80211_radio_attach: Attach wiphy/cfg80211 dev to kernel.
 *   This function initilizes wiphy data structures, callback etc .. and registers
 *   with kernel.
 *   @dev: pointer to bus device structure.
 *   @net_dev: pointer to allocated netdevice for radio.
 *   @ic: pointer to ieee80211com.
 *
 *   returns 0/Error.
 */
int ieee80211_cfg80211_radio_attach(struct device *dev,
                           struct net_device *net_dev, struct ieee80211com *ic)
#endif
{

    struct cfg80211_context *cfg_ctx = NULL;
    struct wiphy *wiphy = NULL;
    struct wlan_objmgr_pdev *pdev = NULL;
    struct wlan_objmgr_psoc *psoc = NULL;
    struct pdev_osif_priv *pdev_ospriv = NULL;
    QDF_STATUS status;

#ifdef WLAN_MLO_MULTI_CHIP
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    struct cfg80211_mld_wiphy_context *mld_cfg_ctx;
    struct cfg80211_context *mld_wiphy_priv;
    uint8_t grp_id;
    uint32_t netdev_count;
#endif

    if(setup_mlo && setup_mlo->tot_links) {
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
        grp_id = setup_mlo->ml_grp_id;
        mld_cfg_ctx = &mld_wiphy_ctx[grp_id];
#endif
        qdf_debug("The number of tot_links is:%d and num_links is:%d", setup_mlo->tot_links, setup_mlo->num_links);
        ieee80211_cfg80211_mld_wiphy_attach(dev, net_dev, ic, setup_mlo);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
        wiphy = mld_cfg_ctx->mld_wiphy;
        mld_wiphy_priv = (struct cfg80211_context*)wiphy_priv(wiphy);
        qdf_atomic_inc(&mld_wiphy_priv->netdev_count);
        netdev_count = qdf_atomic_read(&mld_wiphy_priv->netdev_count);
        /* Store cfg80211 data struct in ic */
        ic->ic_wiphy = wiphy;
        mld_wiphy_priv->ic_list[netdev_count - 1] = ic;


#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
    wlan_cfg80211_send_wiphy_regd_sync_event(ic);
#endif
#endif
    }
#endif
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    else {
#endif
        wiphy = wlan_cfg80211_wiphy_alloc(&wlan_cfg80211_ops, sizeof(struct cfg80211_context));
        if (wiphy == NULL){
            return -1;
        }

        cfg_ctx = (struct cfg80211_context *)wiphy_priv(wiphy);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
        cfg_ctx->ic_list[0] = ic;
#else
        cfg_ctx->ic = ic;
#endif

        /* Store cfg80211 data struct in ic */
        ic->ic_wiphy = wiphy;
        /* bind the underlying wlan device with wiphy */
        wlan_cfg8011_set_wiphy_dev(wiphy, dev);
        wlan_cfg80211_init(net_dev, wiphy, ic);
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    }
#endif
    LIST_INIT(&ic->ic_cp);

    /* Link allocated netdev with wiphy */
    ic->ic_wdev.wiphy  = wiphy;
    ic->ic_wdev.netdev = net_dev;
    ic->ic_wdev.iftype = NL80211_IFTYPE_AP;
    net_dev->ieee80211_ptr = &ic->ic_wdev;
    qdf_debug("ic: 0x%pK, wdev: 0x%pK, wiphy: 0x%pK, netdev: 0x%pk ",
             ic, &ic->ic_wdev, wiphy, net_dev);

    pdev = ic->ic_pdev_obj;
    pdev_ospriv = wlan_pdev_get_ospriv(pdev);
    pdev_ospriv->wiphy = wiphy;
    status = wlan_cfg80211_scan_priv_init(ic->ic_pdev_obj);
    if (QDF_IS_STATUS_ERROR(status)) {
        qdf_print("%s: cfg80211_scan_priv_init failed (status: %d), ic: 0x%pK, pdev: 0x%pK",
                __func__, status, ic, pdev);
        return -1;
    }

#ifdef WLAN_SUPPORT_TELEMETRY
    /* Initialize work for stats*/
    wlan_stats_nb_stats_work_attach();
#endif

    psoc = wlan_pdev_get_psoc(pdev);

#ifdef CONFIG_AFC_SUPPORT
    /* If the AFC event was received from the FW during bootup
     * make sure to trigger the request send to user application
     */
    if (wlan_reg_is_afc_expiry_event_received(pdev)) {
        uint64_t afc_req_id = 0;
        /* Retrieve the AFC req ID */
        if (0 <= wlan_reg_get_afc_req_id(pdev, &afc_req_id)) {
            /* Trigger AFC start */
            ucfg_reg_afc_start(pdev, afc_req_id);
        }
    }
#endif /* CONFIG_AFC_SUPPORT */

    /* cfg80211 inform bss callback */
    ucfg_scan_register_bcn_cb(psoc,
        wlan_cfg80211_inform_bss_frame, SCAN_CB_TYPE_INFORM_BCN);

    ic->ic_cfg80211_compliance_mode = cfg_get(psoc, CFG_CFG80211_COMPLIANCE);

    return 0;
}
qdf_export_symbol(ieee80211_cfg80211_radio_attach);

#ifdef WLAN_MLO_MULTI_CHIP
/**
 *   ieee80211_cfg80211_radio_detach: detach wiphy/cfg80211 device
 *   This function unregisters and frees datastructures.
 *   @ic: pointer to ieee80211com.
 *   @setup_mlo: pointer to mlo setup status
 *
 *   returns 0/Error.
 */
int ieee80211_cfg80211_radio_detach(struct ieee80211com *ic,
                                    struct mlo_setup_info *setup_mlo)
#else
/**
 *   ieee80211_cfg80211_radio_detach: detach wiphy/cfg80211 device
 *   This function unregisters and frees datastructures.
 *   @ic: pointer to ieee80211com.
 *
 *   returns 0/Error.
 */
int ieee80211_cfg80211_radio_detach(struct ieee80211com *ic)
#endif
{
    struct net_device *netdev;
    struct wlan_objmgr_pdev *pdev;
    struct wlan_objmgr_psoc *psoc;

    qdf_print("%s: ic: 0x%pK, wdev: 0x%pK, netdev: 0x%pk ",
            __func__, ic, &ic->ic_wdev, ic->ic_wdev.netdev);

    pdev = ic->ic_pdev_obj;
    psoc = wlan_pdev_get_psoc(pdev);
    /* Clear inform bss callback as it accesses wiphy but we free wiphy below */
    ucfg_scan_register_bcn_cb(psoc, NULL, SCAN_CB_TYPE_INFORM_BCN);

    netdev = ic->ic_wdev.netdev;

    wlan_cfg80211_scan_priv_deinit(ic->ic_pdev_obj);
#ifdef WLAN_MLO_MULTI_CHIP
    if(setup_mlo && setup_mlo->tot_links) {
        qdf_debug("The number of tot_links is:%d and setup_mlo->num_links:%d", setup_mlo->tot_links, setup_mlo->num_links);
        ieee80211_cfg80211_mld_wiphy_detach(psoc, setup_mlo, ic);
    }
#endif
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    else {
#endif
        if (netdev && netdev->reg_state == NETREG_REGISTERED)
            unregister_netdev(netdev);
        wlan_cfg80211_unregister(ic->ic_wiphy);
        wlan_cfg80211_free(ic->ic_wiphy);

        wlan_cfg80211_free_clone_params_list(ic);
        if (ic->channel_list_g.channel_list) {
            qdf_mem_free(ic->channel_list_g.channel_list);
            ic->channel_list_g.channel_list_size = 0;
            ic->channel_list_g.channel_list = NULL;
        }
        if (ic->channel_list_a.channel_list) {
            ic->channel_list_a.channel_list_size = 0;
            qdf_mem_free(ic->channel_list_a.channel_list);
            ic->channel_list_a.channel_list = NULL;
        }

#if CFG80211_SUPPORT_11AX_HOSTAPD
        if (ic->channel_list_6g.channel_list) {
            ic->channel_list_6g.channel_list_size = 0;
            qdf_mem_free(ic->channel_list_6g.channel_list);
            ic->channel_list_6g.channel_list = NULL;
        }
#endif
#ifdef ENABLE_CFG80211_BACKPORTS_MLO
    }
#endif
#ifdef WLAN_SUPPORT_TELEMETRY
    wlan_stats_nb_stats_work_detach();
#endif

    return 0;
}
qdf_export_symbol(ieee80211_cfg80211_radio_detach);


/**
 * wlan_copy_bssid() - API to copy the bssid to vendor Scan request
 * @request: Pointer to vendor scan request
 * @bssid: Pointer to BSSID
 *
 * This API copies the specific BSSID received from Supplicant and copies it to
 * the vendor Scan request
 *
 * Return: None
 */
#if defined(CFG80211_SCAN_BSSID) || \
    (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
static inline void wlan_copy_bssid(struct cfg80211_scan_request *request,
                    uint8_t *bssid)
{
    qdf_mem_copy(request->bssid, bssid, QDF_MAC_ADDR_SIZE);
}
#else
static inline void wlan_copy_bssid(struct cfg80211_scan_request *request,
                    uint8_t *bssid)
{
}
#endif

/**
 * wlan_get_rates() -API to get the rates from scan request
 * @wiphy: Pointer to wiphy
 * @band: Band
 * @rates: array of rates
 * @rate_count: number of rates
 *
 * Return: o for failure, rate bitmap for success
 */
static uint32_t wlan_get_rates(struct wiphy *wiphy,
    enum nl80211_band band,
    const u8 *rates, unsigned int rate_count)
{
    uint32_t j, count, rate_bitmap = 0;
    uint32_t rate;
    bool found;

    for (count = 0; count < rate_count; count++) {
        rate = ((rates[count]) & RATE_MASK) * 5;
        found = false;
        for (j = 0; j < wiphy->bands[band]->n_bitrates; j++) {
            if (wiphy->bands[band]->bitrates[j].bitrate == rate) {
                found = true;
                rate_bitmap |= (1 << j);
                break;
            }
        }
        if (!found)
            return 0;
    }
    return rate_bitmap;
}


/**
 * wlan_send_scan_start_event() -API to send the scan start event
 * @wiphy: Pointer to wiphy
 * @wdev: Pointer to net device
 * @cookie: scan identifier
 *
 * Return: return 0 on success and negative error code on failure
 */
static int wlan_send_scan_start_event(struct wiphy *wiphy,
        struct wireless_dev *wdev, uint64_t cookie)
{
    struct sk_buff *skb;
    int ret;
    QDF_STATUS status;

    skb = wlan_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, sizeof(u64) +
                     NLA_HDRLEN + NLMSG_HDRLEN);
    if (!skb) {
        qdf_print(" reply skb alloc failed");
        return -ENOMEM;
    }

    if (wlan_nla_put_u64(skb, QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE,
                 cookie)) {
        qdf_print("nla put fail");
        wlan_cfg80211_vendor_free_skb(skb);
        return -EINVAL;
    }

    status = wlan_cfg80211_qal_devcfg_send_response((qdf_nbuf_t)skb);
    ret = qdf_status_to_os_return(status);

    /* Send a scan started event to supplicant */
    skb = wlan_cfg80211_vendor_event_alloc(wiphy, wdev,
               sizeof(u64) + 4 + NLMSG_HDRLEN,
               QCA_NL80211_VENDOR_SUBCMD_SCAN_INDEX, GFP_KERNEL);
    if (!skb) {
        qdf_print("skb alloc failed");
        return -ENOMEM;
    }

    if (wlan_nla_put_u64(skb, QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE,
                 cookie)) {
        wlan_cfg80211_vendor_free_skb(skb);
        return -EINVAL;
    }
    wlan_cfg80211_vendor_event(skb, GFP_KERNEL);
    if (0 == ret) {
        qdf_print("Sending scan done vendor event %s",__func__);
    } else {
        qdf_print("Failed to send scan done vendor event %s",__func__);
    }

    return ret;
}

/**
 * __wlan_cfg80211_vendor_scan() - API to process venor scan request
 * @wiphy: Pointer to wiphy
 * @wdev: Pointer to net device
 * @data : Pointer to the data
 * @data_len : length of the data
 *
 * API to process venor scan request.
 *
 * Return: return 0 on success and negative error code on failure
 */
static int __wlan_cfg80211_vendor_scan(struct wiphy *wiphy,
        struct wireless_dev *wdev, const void *data,
        int data_len)
{
    struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SCAN_MAX + 1];
    struct cfg80211_scan_request *request = NULL;
    struct nlattr *attr;
    enum nl80211_band band;
    uint8_t n_channels = 0, n_ssid = 0;
    uint16_t ie_len = 0;
    uint32_t tmp, count, j;
    unsigned int len;
    struct ieee80211_channel *chan;
    int ret;
    struct wlan_objmgr_pdev *pdev;
    struct ieee80211com *ic = NULL;
    struct net_device *dev = wdev->netdev;
    osif_dev *osifp;
    struct wlan_objmgr_vdev *vdev;
    struct scan_params params;
    uint64_t dwelltime_us = 0;
    uint32_t dwelltime_ms = 0;
    u_int8_t link_id = INVALID_LINK_ID;
#if ATH_SUPPORT_WRAP
    wlan_if_t vap;
#endif

    if (wlan_cfg80211_nla_parse(tb,
                                QCA_WLAN_VENDOR_ATTR_SCAN_MAX,
                                data,
                                data_len,
                                scan_policy)) {
        qdf_err("Invalid ATTR");
        return -EINVAL;
    }

    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_LINK_ID]) {
        link_id = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SCAN_LINK_ID]);
    }

    osifp = get_vap_device_context(wiphy, dev, link_id);

    if (!osifp) {
        qdf_err("%s: osifp NULL\n", __func__);
        return -EINVAL;
    }

    vdev = osifp->ctrl_vdev;
    qdf_mem_zero(&params, sizeof(params));

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, link_id);

    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    pdev = ic->ic_pdev_obj;

#if ATH_SUPPORT_WRAP
    /* Donot initiate scan for Proxy stations */
    vap = osifp->os_if;
    if (wlan_rptr_vdev_is_scan_allowed(vap->vdev_obj) == 0) {
        qdf_info("%s:Bypass scan for proxysta", __func__);
        return QDF_STATUS_SUCCESS;
    }
#endif

    if (ic->no_chans_available
#if ATH_SUPPORT_DFS && QCA_DFS_NOL_VAP_RESTART
            || ic->ic_pause_stavap_scan
#endif
       ) {
        return -EINVAL;
    }

    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES]) {
        nla_for_each_nested(attr,
            tb[QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES], tmp)
            n_channels++;
    } else {
        for (band = 0; band < NUM_NL80211_BANDS; band++)
            if (wiphy->bands[band])
                n_channels += wiphy->bands[band]->n_channels;
    }

    if (MAX_CHANNEL < n_channels) {
        qdf_print("Exceed max number of channels: %d", n_channels);
        return -EINVAL;
    }
    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS])
        nla_for_each_nested(attr,
            tb[QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS], tmp)
            n_ssid++;

    if (MAX_SCAN_SSID < n_ssid) {
        qdf_print("Exceed max number of SSID: %d", n_ssid);
        return -EINVAL;
    }

    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_IE])
        ie_len = nla_len(tb[QCA_WLAN_VENDOR_ATTR_SCAN_IE]);
    else
        ie_len = 0;

    if (ie_len > MAX_DEFAULT_SCAN_IE_LEN) {
       qdf_err("Error in IE length");
       return -EINVAL;
    }

    len = sizeof(*request) + (sizeof(*request->ssids) * n_ssid) +
            (sizeof(*request->channels) * n_channels) + ie_len;

    request = qdf_mem_malloc(len);
    if (!request)
        goto error;
    if (n_ssid)
        request->ssids = (void *)&request->channels[n_channels];
    request->n_ssids = n_ssid;
    if (ie_len) {
        if (request->ssids)
            request->ie = (void *)(request->ssids + n_ssid);
        else
            request->ie = (void *)(request->channels + n_channels);
    }

    count = 0;
    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES]) {
        nla_for_each_nested(attr,
                tb[QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES],
                tmp) {
            if (nla_len(attr) != sizeof(uint32_t)) {
                qdf_err("len is not correct for frequency %d",
                        count);
                goto error;
            }
            #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 24)
            chan = ieee80211_get_channel(wiphy,
                            nla_get_u32(attr));
            #else
            chan = __ieee80211_get_channel(wiphy,
                            nla_get_u32(attr));
            #endif
            if (!chan)
                goto error;
            if (chan->flags & IEEE80211_CHAN_DISABLED)
                continue;
            request->channels[count] = chan;
            count++;
        }
    } else {
        for (band = 0; band < NUM_NL80211_BANDS; band++) {
            if (!wiphy->bands[band])
                continue;
            for (j = 0; j < wiphy->bands[band]->n_channels;
                j++) {
                chan = &wiphy->bands[band]->channels[j];
                if (chan->flags & IEEE80211_CHAN_DISABLED)
                    continue;
                request->channels[count] = chan;
                count++;
            }
        }
    }

    if (!count)
        goto error;

    request->n_channels = count;
    count = 0;
    request->ie_len = ie_len;
    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS]) {
        nla_for_each_nested(attr, tb[QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS],
                tmp) {

            if (!request->ssids){
                qdf_print("%s:Returning as ssid is NULL", __func__);
                return -EINVAL;
            }

            request->ssids[count].ssid_len = nla_len(attr);
            if (request->ssids[count].ssid_len >
                SIR_MAC_MAX_SSID_LENGTH) {
                qdf_print("SSID Len %d is not correct for network %d",
                     request->ssids[count].ssid_len, count);
                goto error;
            }
            memcpy(request->ssids[count].ssid, nla_data(attr),
                    nla_len(attr));
            count++;
        }
    }

    if (ie_len) {
        nla_memcpy((void *)request->ie,
                tb[QCA_WLAN_VENDOR_ATTR_SCAN_IE],
                ie_len);
    }

    for (count = 0; count < NUM_NL80211_BANDS; count++)
        if (wiphy->bands[count])
            request->rates[count] =
                (1 << wiphy->bands[count]->n_bitrates) - 1;

    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_SUPP_RATES]) {
        nla_for_each_nested(attr,
                    tb[QCA_WLAN_VENDOR_ATTR_SCAN_SUPP_RATES],
                    tmp) {
            band = nla_type(attr);
            if (band >= NUM_NL80211_BANDS)
                continue;
            if (!wiphy->bands[band])
                continue;
            request->rates[band] =
                wlan_get_rates(wiphy,
                               band, nla_data(attr),
                               nla_len(attr));
        }
    }

    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_FLAGS]) {
        request->flags =
            nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SCAN_FLAGS]);
        if ((request->flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&
            !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) {
            qdf_print("LOW PRIORITY SCAN not supported");
            goto error;
        }
    }

    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_BSSID]) {
        if (nla_len(tb[QCA_WLAN_VENDOR_ATTR_SCAN_BSSID]) <
            QDF_MAC_ADDR_SIZE) {
            qdf_print("invalid bssid length");
            goto error;
        }
        wlan_copy_bssid(request,
            nla_data(tb[QCA_WLAN_VENDOR_ATTR_SCAN_BSSID]));
    }

    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_DWELL_TIME]) {
        dwelltime_us = nla_get_u64(tb[QCA_WLAN_VENDOR_ATTR_SCAN_DWELL_TIME]);

        if (0 == dwelltime_us) {
            qdf_err("Invalid dwell time value of 0 microseconds");
            goto error;
        }

        if (dwelltime_us < MILLISEC_TO_MICROSEC) {
            qdf_warn("Dwell time %llu microseconds is smaller than %u. The value is rounded down to the nearest millisecond value hence it will be ignored.",
                    dwelltime_us, MILLISEC_TO_MICROSEC);
        } else {
            if (qdf_do_div_rem(dwelltime_us, MILLISEC_TO_MICROSEC)) {
                qdf_warn("Dwell time %llu microseconds is not a multiple of %u. The value is rounded down to the nearest millisecond value hence the sub-millisecond portion of the value will be lost.",
                        dwelltime_us, MILLISEC_TO_MICROSEC);
            }

            dwelltime_ms = qdf_do_div(dwelltime_us, MILLISEC_TO_MICROSEC);
        }

    }

    /* Use high priority by default for vendor scan */
    params.priority = SCAN_PRIORITY_HIGH;

    /* If the priority is sent as part of the subcmd, use that */
    if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_PRIORITY]) {
        uint32_t nl_scan_priority;

        nl_scan_priority = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SCAN_PRIORITY]);
        params.priority =
            convert_nl_scan_priority_to_internal(nl_scan_priority);
    }

    request->no_cck =
        nla_get_flag(tb[QCA_WLAN_VENDOR_ATTR_SCAN_TX_NO_CCK_RATE]);
    request->wdev = wdev;
    request->wiphy = wiphy;
    request->scan_start = jiffies;

    /* Initialize driver specific scan config param */
    params.source = VENDOR_SCAN;
    params.default_ie.len = 0;
    params.default_ie.ptr = NULL;
    params.half_rate = false;
    params.quarter_rate= false;
    params.strict_pscan = false;

    if (0 != dwelltime_ms) {
        params.dwell_time_active =
            params.dwell_time_active_2g =
            params.dwell_time_active_6g =
            params.dwell_time_passive =
            params.dwell_time_passive_6g =
                dwelltime_ms;
    }

    if (request->n_channels) {
        if (IEEE80211_IS_FLAG_HALF(ic->ic_chanbwflag))
            params.half_rate = true;
        else if (IEEE80211_IS_FLAG_QUARTER(ic->ic_chanbwflag))
            params.quarter_rate= true;
    }
    if (ic->ic_strict_pscan_enable) {
        params.strict_pscan = true;
    }

    ret = wlan_objmgr_vdev_try_get_ref(vdev, WLAN_OSIF_ID);
    if (QDF_IS_STATUS_ERROR(ret)) {
        IEEE80211_DPRINTF_IC(ic, IEEE80211_VERBOSE_LOUD, IEEE80211_MSG_CFG80211,
                "%s Couldnt get vdev ref, fail new scan\n", __func__);
        goto error;
    }

    /* Update scanning bands configuration */
    ieee80211_cfg80211_update_scanband(osifp, &params);

#ifndef QCA_DYNAMIC_STA_VAP_SUPPORT
    ret = wlan_cfg80211_scan(vdev, request, &params);
#else
    ret = wlan_cfg80211_scan(vdev, request, &params,ic);
#endif

    wlan_objmgr_vdev_release_ref(vdev, WLAN_OSIF_ID);

    if (0 != ret) {
        qdf_print("Scan Failed. Ret = %d", ret);
        qdf_mem_free(request);
        return ret;
    }
    ret = wlan_send_scan_start_event(wiphy, wdev, (uintptr_t)request);

    return ret;
error:
    qdf_print("Scan Request Failed");
    qdf_mem_free(request);
    return -EINVAL;
}

/**
 * wlan_cfg80211_vendor_scan() -API to process venor scan request
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to net device
 * @data : Pointer to the data
 * @data_len : length of the data
 *
 * This is called from userspace to request scan.
 *
 * Return: Return the Success or Failure code.
 */
int wlan_cfg80211_vendor_scan(struct wiphy *wiphy,
        struct wireless_dev *wdev, const void *data,
        int data_len)
{
    int ret;

    ret = __wlan_cfg80211_vendor_scan(wiphy, wdev,
                                      data, data_len);

    return ret;
}

/*
 * CSA TBTT value to use in case external ACS requests channel change due to
 * interference. This can be made configurable in the future if required.
 */
#define QCA_WLAN_VENDOR_ACS_INTERFERENCE_CSA_TBTT    (2)

/**
 * update_vendor_acs_channel - Helper function to update channel in response to
 * external vendor ACS request
 * @vap: Handle for VAP structure
 * @reason: cfg80211 vendor reason for channel change
 * @channel_cnt: Number of channels provided in channel_list
 * @channel_list: List of channels for consideration for channel change.
 * Currently, only one is expected. This may change in the future.
 *
 * Return: QDF_STATUS_SUCCESS on success, QDF error code on failure
 */
QDF_STATUS update_vendor_acs_channel(wlan_if_t vap, uint8_t reason,
                  uint8_t channel_cnt,
                  struct vendor_chan_info *channel_list)
{
    QDF_STATUS status = QDF_STATUS_E_FAILURE;
    struct ieee80211_ath_channel l_best_chan;
    struct ieee80211_ath_channel *best_chan = &l_best_chan;
    struct ieee80211com *ic = NULL;
    struct ieee80211vap *temp_vap = NULL;
    enum ieee80211_phymode act_phymode = IEEE80211_MODE_AUTO;
    uint8_t secchanoffset = IEEE80211_SEC_CHAN_OFFSET_SCN;
    enum ieee80211_mode mode = IEEE80211_MODE_INVALID;
    u_int16_t csa_ch_width = 0;
    struct chan_params chan_p = {0};
    struct ol_ath_softc_net80211 *scn;

    if (NULL == vap) {
        qdf_err("VAP is NULL");
        status = QDF_STATUS_E_INVAL;
        goto done;
    }

    ic = vap->iv_ic;
    if (NULL == ic) {
        qdf_err("ieee80211com is NULL");
        status = QDF_STATUS_E_INVAL;
        goto done;
    }

    scn = OL_ATH_SOFTC_NET80211(vap->iv_ic);
    if (!scn) {
        status = QDF_STATUS_E_INVAL;
        goto done;
    }

    if (0 == channel_cnt) {
        qdf_err("channel_cnt is 0");
        status = QDF_STATUS_E_INVAL;
        goto done;
    }

    if (1 != channel_cnt) {
        qdf_err("channel_cnt %hhu not currently supported (only 1 is supported)",
                channel_cnt);
        status = QDF_STATUS_E_NOSUPPORT;
        goto done;
    }

    if (NULL == channel_list) {
        qdf_err("channel_list is NULL");
        status = QDF_STATUS_E_INVAL;
        goto done;
    }

    if (0 == channel_list->pri_ch_freq) {
        qdf_err("External ACS entity has failed to identify any channel including random fallbacks. Investigate.");
        status = QDF_STATUS_E_ABORTED;
        goto done;
    }

    if (channel_list->chan_width >= IEEE80211_CWM_WIDTH_MAX) {
        qdf_err("Invalid chan_width value %hhu in channel_list",
                    channel_list->chan_width);
        status = QDF_STATUS_E_INVAL;
        goto done;
    }

    if ((IEEE80211_CWM_WIDTH80_80 == channel_list->chan_width) &&
            (0 == channel_list->seg1_center_ch_freq)) {
        qdf_err("Segment 1 frequency not provided for 80+80 MHz");
        status = QDF_STATUS_E_INVAL;
        goto done;
    }

    switch (reason) {
        /* VAP init case */
        case QCA_WLAN_VENDOR_ACS_SELECT_REASON_INIT:
        {
            if (channel_list->chan_width == IEEE80211_CWM_WIDTH40) {
                    if (channel_list->sec_ch_freq > channel_list->pri_ch_freq)
                       secchanoffset = IEEE80211_SEC_CHAN_OFFSET_SCA;
                    else if (channel_list->sec_ch_freq < channel_list->pri_ch_freq)
                       secchanoffset = IEEE80211_SEC_CHAN_OFFSET_SCB;
            }

            mode = get_mode_from_phymode(vap->iv_des_mode);
            act_phymode = ieee80211_get_composite_phymode(mode,
                                                          channel_list->chan_width,
                                                          secchanoffset);

            chan_p.freq = channel_list->pri_ch_freq;
            set_chan_params_puncture_bitmap(&chan_p, channel_list->puncture_bitmap);
            if (IEEE80211_CWM_WIDTH80_80 == channel_list->chan_width) {
               chan_p.cfreq2 = channel_list->seg1_center_ch_freq;
            } else {
                chan_p.cfreq2 = 0;
            }
            *best_chan = ieee80211_find_dot11_channel(ic,
                        &chan_p, act_phymode);

#ifdef CONFIG_AFC_SUPPORT
            if (ieee80211_is_afc_capable(vap->iv_ic, act_phymode)) {
                status = ieee80211_update_mode_and_power_type(vap,
                                                              best_chan,
                                                              act_phymode);
                if (status) {
                    qdf_err("Failed to change phymode and regulatory AP power type");
                    goto done;
                }
            } else
#endif
            {
                ieee80211_ucfg_set_wirelessmode(vap, act_phymode);
            }

            if (!IEEE80211_IS_CHAN_VALID(best_chan)){
                qdf_print("%s:Finding channel failed.",__func__);
                status = QDF_STATUS_E_INVAL;
                goto done;
            }

            /* Update Hostapd with the best channel for all VAPs on the radio*/
            TAILQ_FOREACH(temp_vap, &ic->ic_vaps, iv_next) {
                 wlan_cfg80211_acs_report_channel(temp_vap, best_chan);
            }

            ic->ic_eacs_done = 1;
            status = QDF_STATUS_SUCCESS;
            break;
        }

        case QCA_WLAN_VENDOR_ACS_SELECT_REASON_80211_INTERFERENCE:
        case QCA_WLAN_VENDOR_ACS_SELECT_REASON_CW_INTERFERENCE:
#ifdef CONFIG_AFC_SUPPORT
        case QCA_WLAN_VENDOR_ACS_SELECT_REASON_AFC_TRIGGER:
#endif
        {
            if (channel_list->chan_width == IEEE80211_CWM_WIDTH40) {
                    if (channel_list->sec_ch_freq > channel_list->pri_ch_freq)
                       secchanoffset = IEEE80211_SEC_CHAN_OFFSET_SCA;
                    else if (channel_list->sec_ch_freq < channel_list->pri_ch_freq)
                       secchanoffset = IEEE80211_SEC_CHAN_OFFSET_SCB;
            }

            mode = get_mode_from_phymode(vap->iv_cur_mode);
            if (IEEE80211_MODE_INVALID == mode) {
                qdf_err("Unable to get mode from iv_cur_mode");
                status = QDF_STATUS_E_FAILURE;
                goto done;
            }

            act_phymode = ieee80211_get_composite_phymode(mode,
                                channel_list->chan_width, secchanoffset);
            if (ieee80211_is_phymode_auto(act_phymode)) {
                qdf_err("Invalid PHY mode mapped from arguments");
                status = QDF_STATUS_E_INVAL;
                goto done;
            }

            chan_p.freq = channel_list->pri_ch_freq;
            set_chan_params_puncture_bitmap(&chan_p, channel_list->puncture_bitmap);
            if (IEEE80211_CWM_WIDTH80_80 == channel_list->chan_width) {
                chan_p.cfreq2 = channel_list->seg1_center_ch_freq;
            } else {
                chan_p.cfreq2 = 0;
            }
            *best_chan = ieee80211_find_dot11_channel(ic,
                        &chan_p, act_phymode);

#ifdef CONFIG_AFC_SUPPORT
            if (ieee80211_is_afc_capable(vap->iv_ic, act_phymode)) {
                status = ieee80211_update_mode_and_power_type(vap,
                                                              best_chan,
                                                              act_phymode);
                if (status) {
                    qdf_err("Failed to change phymode and regulatory AP power type");
                    goto done;
                }
            }
#endif

            if (!IEEE80211_IS_CHAN_VALID(best_chan)){
                qdf_err("Failed to find dot11 channel structure from arguments");
                status = QDF_STATUS_E_INVAL;
                goto done;
            }

            if (ieee80211_get_csa_chwidth_from_cwm(channel_list->chan_width,
                        &csa_ch_width) != QDF_STATUS_SUCCESS) {
                qdf_err("Failed to find CSA chwidth from CWM chwidth argument");
                status = QDF_STATUS_E_INVAL;
                goto done;
            }

            /*
             * If required, a configuration can be added in the future to
             * control whether to use CSA or regular mode+channel configuration.
             * However, we currently use CSA since this can statistically
             * provide advantages.
             */
            chan_p.freq = best_chan->ic_freq;
            chan_p.cfreq2 = best_chan->ic_vhtop_freq_seg2;
            if (ieee80211_ucfg_set_chanswitch(vap,
                    &chan_p, scn->scn_dcs.dcs_csa_tbtt,
                    csa_ch_width)) {
                qdf_err("Failed to set channel switch - Recheck arguments");
                status = QDF_STATUS_E_INVAL;
                goto done;
            }

            status = QDF_STATUS_SUCCESS;
            break;
        }

        default:
            qdf_err("Invalid reason %u for channel selection", reason);
            status = QDF_STATUS_E_INVAL;
            break;
    }

done:
#ifdef CONFIG_AFC_SUPPORT
    if (status && vap != NULL && ic != NULL &&
        ieee80211_is_afc_capable(vap->iv_ic,
                                 ieee80211_chan2mode(vap->iv_ic->ic_curchan))) {
        ieee80211_update_mode_and_power_type(vap, best_chan, vap->iv_des_mode);
        vap->iv_afc_orig_mode = IEEE80211_MODE_AUTO;
    }
#endif

    if (channel_list)
        qdf_mem_free(channel_list);

    return status;
}

/**
 * Define short name for vendor channel set config
 */
#define SET_CHAN_REASON QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_CHANNEL_REASON
#define SET_CHAN_FREQ_LIST QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_FREQUENCY_LIST
#define SET_CHAN_PRIMARY_FREQUENCY \
    QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_FREQUENCY_PRIMARY
#define SET_CHAN_SECONDARY_FREQUENCY \
    QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_FREQUENCY_SECONDARY
#define SET_CHAN_SEG0_CENTER_FREQUENCY \
    QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_FREQUENCY_CENTER_SEG0
#define    SET_CHAN_SEG1_CENTER_FREQUENCY \
    QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_FREQUENCY_CENTER_SEG1
#define    SET_CHAN_PUNCTURE_BITMAP \
    QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_PUNCTURE_BITMAP
#define    SET_CHAN_CHANNEL_WIDTH \
    QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_CHANNEL_WIDTH
#define    SET_CHAN_MAX QCA_WLAN_VENDOR_ATTR_EXTERNAL_ACS_CHANNEL_MAX

/**
 * parse_vendor_acs_chan_config() - API to parse vendor acs channel config
 * @channel_list: pointer to vendor_chan_info
 * @reason: channel change reason
 * @channel_cnt: channel count
 * @data: data
 * @data_len: data len
 *
 * Return: 0 on success, negative errno on failure
 */
static int parse_vendor_acs_chan_config(struct vendor_chan_info
        **chan_list_ptr, uint8_t *reason, uint8_t *channel_cnt,
        const void *data, int data_len)
{
    int rem, i = 0;
    struct nlattr *tb[SET_CHAN_MAX + 1];
    struct nlattr *tb2[SET_CHAN_MAX + 1];
    struct nlattr *curr_attr;
    struct vendor_chan_info *channel_list;

    if (wlan_cfg80211_nla_parse(tb, SET_CHAN_MAX, data, data_len,
#if STRICT_NLPOLICY_CHECKING
                wlan_cfg80211_external_acs_policy
#else
                NULL
#endif /* STRICT_NLPOLICY_CHECKING */
                )) {
        qdf_print("Invalid ATTR");
        return -EINVAL;
    }

    if (tb[SET_CHAN_REASON])
        *reason = nla_get_u8(tb[SET_CHAN_REASON]);

    /* Hard coding the channel count to 1 for now */
    *channel_cnt = 1;
    qdf_print("channel count %d", *channel_cnt);

    if (!(*channel_cnt)) {
        qdf_print("channel count is %d", *channel_cnt);
        return -EINVAL;
    }

    channel_list = qdf_mem_malloc(sizeof(struct vendor_chan_info) *
                    (*channel_cnt));

    if (!channel_list){
        qdf_print("%s: qdf_mem_malloc failed.", __func__);
        return -EINVAL;
    }

    nla_for_each_nested(curr_attr, tb[SET_CHAN_FREQ_LIST], rem) {
        if (wlan_cfg80211_nla_parse(tb2,
                                    SET_CHAN_MAX,
                                    nla_data(curr_attr), nla_len(curr_attr),
                                    NULL)) {
            qdf_print("nla_parse failed");
            qdf_mem_free(channel_list);
            return -EINVAL;
        }
        /* Parse and Fetch allowed SSID list*/
        if (tb2[SET_CHAN_PRIMARY_FREQUENCY]) {
            channel_list[i].pri_ch_freq =
                nla_get_u32(
                    tb2[SET_CHAN_PRIMARY_FREQUENCY]);
        }
        if (tb2[SET_CHAN_SECONDARY_FREQUENCY]) {
            channel_list[i].sec_ch_freq =
                nla_get_u32(tb2[SET_CHAN_SECONDARY_FREQUENCY]);
        }
        if (tb2[SET_CHAN_SEG0_CENTER_FREQUENCY]) {
            channel_list[i].seg0_center_ch_freq =
                nla_get_u32(tb2[SET_CHAN_SEG0_CENTER_FREQUENCY]);
        }
        if (tb2[SET_CHAN_SEG1_CENTER_FREQUENCY]) {
            channel_list[i].seg1_center_ch_freq =
                nla_get_u32(tb2[SET_CHAN_SEG1_CENTER_FREQUENCY]);
        }
        if (tb2[SET_CHAN_PUNCTURE_BITMAP]) {
            channel_list[i].puncture_bitmap =
                nla_get_u32(tb2[SET_CHAN_PUNCTURE_BITMAP]);
        }
        if (tb2[SET_CHAN_CHANNEL_WIDTH]) {
            channel_list[i].chan_width =
                nla_get_u8(tb2[SET_CHAN_CHANNEL_WIDTH]);
        }

        qdf_info("index %d pri %u sec %u seg0 %u seg1 %u width %u puncture bitmap %u",
            i, channel_list[i].pri_ch_freq,
            channel_list[i].sec_ch_freq,
            channel_list[i].seg0_center_ch_freq,
            channel_list[i].seg1_center_ch_freq,
            channel_list[i].chan_width,
            channel_list[i].puncture_bitmap);
        i++;
        if (i >= *channel_cnt)
            break;
    }

    *chan_list_ptr = channel_list;

    return 0;
}

/**
 * Undef short names for vendor set channel configuration
 */
#undef SET_CHAN_REASON
#undef SET_CHAN_CHANNEL_COUNT
#undef SET_CHAN_FREQ_LIST
#undef SET_CHAN_PRIMARY_FREQUENCY
#undef SET_CHAN_SECONDARY_FREQUENCY
#undef SET_CHAN_SEG0_CENTER_FREQUENCY
#undef SET_CHAN_SEG1_CENTER_FREQUENCY
#undef SET_CHAN_CHANNEL_WIDTH
#undef SET_CHAN_PUNCTURE_BITMAP
#undef SET_CHAN_MAX

/**
 * __wlan_cfg80211_update_vendor_channel() - update vendor channel
 * @wiphy: Pointer to wireless phy
 * @wdev: Pointer to wireless device
 * @data: Pointer to data
 * @data_len: Length of @data
 *
 * Return: 0 on success, negative errno on failure
 */
static int __wlan_cfg80211_update_vendor_channel(struct wiphy *wiphy,
        struct wireless_dev *wdev,
        const void *data, int data_len)
{
    int ret_val;
    QDF_STATUS qdf_status;
    uint8_t channel_cnt = 0, reason = -1;
    struct vendor_chan_info *channel_list = NULL;
    osif_dev *osifp = get_vap_device_context(wiphy, wdev->netdev, 0);
    wlan_if_t vap;

    if (!osifp) {
        qdf_err("%s: osifp NULL\n", __func__);
        return -EINVAL;
    }

    vap = osifp->os_if;

    if (!vap) {
        qdf_err("%s: vap is NULL\n", __func__);
        return -EINVAL;
    }
    ret_val = parse_vendor_acs_chan_config(&channel_list, &reason,
                    &channel_cnt, data, data_len);
    if (ret_val)
        return ret_val;

    if ((channel_cnt <= 0) || !channel_list) {
        qdf_print("no available channel/chanlist %pK", channel_list);
        return -EINVAL;
    }

    qdf_status = update_vendor_acs_channel(vap, reason,
                      channel_cnt, channel_list);
    return qdf_status_to_os_return(qdf_status);
}

/**
 * wlan_cfg80211_update_vendor_channel() - update vendor channel
 * @wiphy: Pointer to wireless phy
 * @wdev: Pointer to wireless device
 * @data: Pointer to data
 * @data_len: Length of @data
 *
 * Return: 0 on success, negative errno on failure
 */
int wlan_cfg80211_update_vendor_channel(struct wiphy *wiphy,
                        struct wireless_dev *wdev,
                        const void *data, int data_len)
{
    int ret;

    ret = __wlan_cfg80211_update_vendor_channel(wiphy, wdev, data,
                                data_len);

    return ret;
}

/*
 * Fill the survey results (total survey time, total time channel is busy, tx time)
 * Steps to calculate time in ms from cycle count is given below
 * time = cycle_count * cycle
 * cycle = 1 / clock_freq
 * Since the unit of clock_freq reported from
 * FW is MHZ, and we want to calculate time in
 * ms level, the result is
 * time = cycle / (clock_freq * 1000)
 */
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0))
static bool wlan_fill_survey_result(struct survey_info *survey,
                                    int opfreq,
                                    struct scan_chan_info *chan_info,
                                    struct ieee80211_channel *channel)
{
    uint32_t clock_freq = chan_info->clock_freq * 1000;

    if (channel->center_freq != (uint16_t)chan_info->freq)
        return false;

    survey->channel = channel;
    survey->noise = chan_info->noise_floor;
    survey->filled = SURVEY_INFO_NOISE_DBM;

    if (opfreq == chan_info->freq)
        survey->filled |= SURVEY_INFO_IN_USE;

    if (clock_freq == 0)
        return true;

    survey->time = chan_info->cycle_count / clock_freq;
    survey->time_busy = chan_info->rx_clear_count / clock_freq;
    survey->time_tx = chan_info->tx_frame_count / clock_freq;

    survey->filled |= SURVEY_INFO_TIME |
            SURVEY_INFO_TIME_BUSY |
            SURVEY_INFO_TIME_TX;
    return true;
}
#else
static bool wlan_fill_survey_result(struct survey_info *survey,
                                    int opfreq,
                                    struct scan_chan_info *chan_info,
                                    struct ieee80211_channel *channel)
{
    uint64_t clock_freq = chan_info->clock_freq * 1000;

    if (channel->center_freq != (uint16_t)chan_info->freq)
        return false;

    survey->channel = channel;
    survey->noise = chan_info->noise_floor;
    survey->filled = SURVEY_INFO_NOISE_DBM;

    if (opfreq == chan_info->freq)
        survey->filled |= SURVEY_INFO_IN_USE;

    if (clock_freq == 0)
        return true;

    survey->channel_time = chan_info->cycle_count / clock_freq;
    survey->channel_time_busy = chan_info->rx_clear_count / clock_freq;
    survey->channel_time_tx = chan_info->tx_frame_count / clock_freq;

    survey->filled |= SURVEY_INFO_CHANNEL_TIME |
            SURVEY_INFO_CHANNEL_TIME_BUSY |
            SURVEY_INFO_CHANNEL_TIME_TX;
    return true;
}
#endif

static bool wlan_hdd_update_survey_info(struct wiphy *wiphy,
                                        struct external_acs_obj *extacs_handle,
                                        struct survey_info *survey,
                                        int idx)
{
    bool filled = false;
    int i = 0;
    int j = 0;
    int k = 0;
    uint32_t opfreq = 0;
    int valid_idx = 0;
    struct ieee80211com *ic = NULL;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, NULL, 0);

    if (!ic) {
        qdf_debug("NULL IC");
        return false;
    }
    if (IEEE80211_IS_CHAN_VALID(ic->ic_curchan))
        opfreq = ic->ic_curchan->ic_freq;

    /* find the idxth non zero element from the start of array */
    while (k < (MAX_EXTACS_CHAN_INFO_INDEX -1)) {
        if (extacs_handle->chan_info[k].freq != 0 && valid_idx++ == idx)
            break;
        k++;
    }
    if (k  != (MAX_EXTACS_CHAN_INFO_INDEX -1))
        idx = k;
    else
        return false;

    qdf_spin_lock(&extacs_handle->chan_info_lock);
    for (i = 0; i < IEEE80211_NUM_BANDS && !filled; i++) {
        if (wiphy->bands[i] == NULL)
            continue;

        for (j = 0; j < wiphy->bands[i]->n_channels && !filled; j++) {
            struct ieee80211_supported_band *band = wiphy->bands[i];
            filled = wlan_fill_survey_result(survey, opfreq,
            &extacs_handle->chan_info[idx],
            &band->channels[j]);
        }
    }
    qdf_spin_unlock(&extacs_handle->chan_info_lock);

    return filled;
}

/**
 * __wlan_hdd_cfg80211_dump_survey() - get survey related info
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @idx: Index
 * @survey: Pointer to survey info
 *
 * Return: 0 for success, non-zero for failure
 */
static int __wlan_hdd_cfg80211_dump_survey(struct wiphy *wiphy,
                                           struct net_device *dev,
                                           int idx,
                                           struct survey_info *survey)
{
    bool filled = false;
    struct ieee80211com *ic;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, dev->ieee80211_ptr, 0);

    if (!ic) {
        qdf_debug("ic NULL");
        return -EINVAL;
    }

    if (idx > NUM_MAX_CHANNELS - 1)
        return -EINVAL;

    filled = wlan_hdd_update_survey_info(wiphy, &ic->ic_extacs_obj, survey, idx);

    if (!filled) {
        return -ENONET;
    }

   return 0;
}

/**
 * wlan_hdd_cfg80211_dump_survey() - get survey related info
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @idx: Index
 * @survey: Pointer to survey info
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_hdd_cfg80211_dump_survey(struct wiphy *wiphy,
                                  struct net_device *dev,
                                  int idx,
                                  struct survey_info *survey)
{
    return  __wlan_hdd_cfg80211_dump_survey(wiphy, dev, idx, survey);
}

/**
 * _wlan_cfg80211_vendor_get_rropinfo() - Internal API to get RROP info
 * @wiphy: Pointer to wiphy
 * @wdev: Pointer to net device
 * @data: Pointer to the data
 * @data_len: length of the data
 *
 * Internal API to process vendor specific request to get Representative RF
 * Operating Parameter (RROP) information.
 *
 * Return: return 0 on success and negative error code on failure
 */
static int __wlan_cfg80211_vendor_get_rropinfo(struct wiphy *wiphy,
        struct wireless_dev *wdev, const void *data,
        int data_len)
{
    struct ieee80211com *ic = NULL;
    struct external_acs_obj *extacs_handle = NULL;
    struct sk_buff *skb = NULL;
    struct nlattr *nla_attr = NULL;
    struct nlattr *rtplinst_attr = NULL;
    struct scan_chan_info *chan_info = NULL;
    bool info_available = false;
    int ret = 0, i = 0;
    QDF_STATUS status;

/** To check linkid **/
    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, 0);
    if (!ic) {
        qdf_err("ic is null");
        return -EINVAL;
    }

    extacs_handle = &ic->ic_extacs_obj;

    skb = wlan_cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
                        RROP_REPLY_BUF_SIZE);

    if (!skb) {
        qdf_print("Reply skb alloc failed");
        return -ENOMEM;
    }

    nla_attr = nla_nest_start(skb, QCA_WLAN_VENDOR_ATTR_RROP_INFO_RTPL);

    if (!nla_attr) {
        qdf_print("nla nest start failed for RTPL info");
        ret = -EINVAL;
        goto preskbsend_fail;
    }

    qdf_spin_lock(&extacs_handle->chan_info_lock);

    for (i = 0; i < QDF_ARRAY_SIZE(ic->ic_extacs_obj.chan_info); i++) {
        chan_info = &ic->ic_extacs_obj.chan_info[i];

        /*
         * An entry is considered unpopulated if the freq and tx power fields
         * are all zero.
         * TODO: If the channel info in ic->ic_extacs_obj is later optimized to
         * explicitly indicate which channel entries have valid information, we
         * can optionally change the below check.
         */
        if ((chan_info->freq == 0) && (chan_info->tx_power_tput == 0) &&
                (chan_info->tx_power_range == 0))
            continue;

        info_available = true;

        rtplinst_attr = nla_nest_start(skb, i);

        if (!rtplinst_attr) {
            qdf_print("nla nest start failed for RTPL instance");
            ret = -EINVAL;
            qdf_spin_unlock(&extacs_handle->chan_info_lock);
            goto preskbsend_fail;
        }

        /* ic->ic_extacs_obj.chan_info is indexed by primary channel number */
        if (nla_put_u32(skb,
                    QCA_WLAN_VENDOR_ATTR_RTPLINST_PRIMARY_FREQUENCY,
                chan_info->freq) ||
            nla_put_s32(skb, QCA_WLAN_VENDOR_ATTR_RTPLINST_TXPOWER_THROUGHPUT,
                chan_info->tx_power_tput) ||
            nla_put_s32(skb, QCA_WLAN_VENDOR_ATTR_RTPLINST_TXPOWER_RANGE,
                chan_info->tx_power_range)) {
            qdf_print("put failed for RTPL instance");
            ret = -EINVAL;
            qdf_spin_unlock(&extacs_handle->chan_info_lock);
            goto preskbsend_fail;
        }

        nla_nest_end(skb, rtplinst_attr);
    }

    qdf_spin_unlock(&extacs_handle->chan_info_lock);

    if (!info_available) {
        /* The application might have made the API call in an incorrect
         * sequence.
         */
        ret = -EINVAL;
        goto preskbsend_fail;
    }

    nla_nest_end(skb, nla_attr);

    status = wlan_cfg80211_qal_devcfg_send_response((qdf_nbuf_t)skb);
    ret = qdf_status_to_os_return(status);

    if (ret == 0) {
        qdf_print("%s: Sending RROP info",__func__);
        return 0;
    } else {
        qdf_print("%s: Failed to send RROP info",__func__);
        return -EINVAL;
    }

preskbsend_fail:
    wlan_cfg80211_vendor_free_skb(skb);
    return ret;
}

/**
 * wlan_cfg80211_vendor_get_rropinfo() - API to get RROP info
 * @wiphy: Pointer to wiphy
 * @wdev: Pointer to net device
 * @data: Pointer to the data
 * @data_len: length of the data
 *
 * API to process vendor specific request to get Representative RF Operating
 * Parameter (RROP) information. This is called from userspace.
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_cfg80211_vendor_get_rropinfo(struct wiphy *wiphy,
        struct wireless_dev *wdev, const void *data,
        int data_len)
{
    return  __wlan_cfg80211_vendor_get_rropinfo(wiphy, wdev, data, data_len);
}

#define GET_BE16(a) ((u16) (((a)[0] << 8) | (a)[1]))
#define ELEMENT_TYPE 0x1012
#define FIRST_ELEMENT_TYPE_FIELD 0x6
#define ELEMENT_LENGTH_FIELD 0x3
#define ELEMENT_LENGTH 0x2
#define PASSWORD_ID_FIELD 0x4
#define PASSWORD_ID 0x0004

int push_button_method(const u_int8_t *frm)
{
     int len = FIRST_ELEMENT_TYPE_FIELD;
     int rc = 0;

     while ((len+4) < frm[1] ) {
        if((GET_BE16(frm+len) == ELEMENT_TYPE) && (frm[len+ELEMENT_LENGTH_FIELD] == ELEMENT_LENGTH)&& (GET_BE16(frm+len+PASSWORD_ID_FIELD)== PASSWORD_ID))
        {
            rc = 1;
            qdf_print("wps pb detected");
            return rc;
        } else {
          len += frm[len+ELEMENT_LENGTH_FIELD]+4;
        }
     }
     return rc;
}

/**
 * wlan_vendor_fwd_mgmt_frame() - Forward management frame event
 *
 * @vap: Pointer to vap
 * @skb: Pointer to mgmt frame
 * @subtype: frame subtype
 *
 * This function forwards management frame to NL.
 *
 * Return: none
 */
void wlan_vendor_fwd_mgmt_frame(wlan_if_t vap, struct sk_buff *skb, u_int16_t subtype)
{
    osif_dev *osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    struct net_device *dev = get_cfg80211_notification_ndev(osif);
    struct ieee80211_frame *wh;
    u_int8_t *frm, *efrm;
    bool send_to_app = false;
    u_int16_t subtype_number = (subtype & IEEE80211_FC0_SUBTYPE_MASK) >>
                               IEEE80211_FC0_SUBTYPE_SHIFT;

    do {
        if ((1 << subtype_number) & osif->wlan_vendor_fwd_mgmt_mask) {
            send_to_app = true;
            break;
        }

        if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_REQ &&
                wlan_get_param(vap, IEEE80211_WPS_MODE) &&
                IEEE80211_VAP_IS_BACKHAUL_ENABLED(vap)) {

            wh = (struct ieee80211_frame *) wbuf_header(skb);
            frm = (u_int8_t *)&wh[1];
            efrm = wbuf_header(skb) + wbuf_get_pktlen(skb);

            while (((frm+1) < efrm) && (frm + frm[1] + 1 < efrm)) {
                if (iswpsoui(frm) && push_button_method(frm))
                {
                    send_to_app = true;
                    break;
                }
                else
                    frm += frm[1] + 2;
            }
        }
    } while(0);

    if (send_to_app == false) {
        return;
    }
    wlan_cfg80211_generic_event(vap->iv_ic,
            QCA_NL80211_VENDOR_SUBCMD_FWD_MGMT_FRAME, skb->data,
            skb->len, dev, GFP_ATOMIC);
}

int wlan_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_pmksa *pmksa)
{
	return 0;
}
int wlan_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_pmksa *pmksa)
{
	return 0;
}
int wlan_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *dev)
{
	return 0;
}
/**
 * wlan_cfg80211_update_ft_ies() - Updates ft ies provided by supplicant
 *
 * @wiphy: Pointer to wiphy
 * @dev: Pointer to network device
 * @req: Pointer to cfg80211 update ft ies params
 *
 * This function stores the ft ies provided in vap context later
 * used for roaming
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_cfg80211_update_ft_ies(struct wiphy *wiphy,
        struct net_device *ndev,
        struct cfg80211_update_ft_ies_params *ftie)
{
    osif_dev                *osifp = get_vap_device_context(wiphy, ndev, 0);
    wlan_if_t               vap;
    int                     retval = 0;

    if (!osifp) {
        qdf_err("%s: osifp NULL\n", __func__);
        return -EINVAL;
    }

    vap = osifp->os_if;

    if (!vap) {
        qdf_err("vap is NULL\n");
        return -EINVAL;
    }

    if (!vap->iv_roam.iv_ft_enable) {
        retval = -EINVAL;
        goto error;
    }

    if (!ieee80211_vap_is_connected(vap) &&
            !ieee80211_vap_is_connecting(vap) &&
            !ieee80211_vap_is_roaming(vap)) {
        retval = -EINVAL;
        goto error;
    }

    if (!ftie) {
        retval = -EINVAL;
        goto error;
    }

    if (osifp->is_delete_in_progress) {
        retval = -EINVAL;
        goto error;
    }

    retval = wlan_mlme_set_ftie(vap, ftie->md, (u_int8_t *)ftie->ie, ftie->ie_len);

error:
    if (retval == 0) {
        vap->iv_roam.iv_roaming = 1;
        vap->iv_roam.iv_ft_roam = 1;
    }
    else {
        vap->iv_roam.iv_roaming = 0;
        vap->iv_roam.iv_ft_roam = 0;
    }
    vap->iv_roam.iv_wait_for_ftie_update = 0;

    return retval;
}


/**
 * ieee80211_cfg80211_post_ft_event() - Posts ft event to supplicant
 *
 * @osdev: Pointer to osdev
 *
 * This function posts ft event to supplicant used for ft roaming
 *
 * Return: None
 */
void ieee80211_cfg80211_post_ft_workq(void *context) {
    wlan_if_t vap = (wlan_if_t) context;
    osif_dev *osdev = (osif_dev *)vap->iv_ifp;

    ieee80211_cfg80211_post_ft_event(osdev);
}

/**
 * ieee80211_cfg80211_post_ft_event() - Posts ft event to supplicant
 *
 * @osdev: Pointer to osdev
 *
 * This function posts ft event to supplicant used for ft roaming
 *
 * Return: None
 */
void ieee80211_cfg80211_post_ft_event(osif_dev *osdev)
{
    struct cfg80211_ft_event_params ft_event;
    struct net_device *dev = osdev->netdev;
    wlan_if_t vap = osdev->os_if;

    if (vap->iv_roam.iv_ft_roam && vap->iv_roam.iv_ft_params.fties) {
        qdf_mem_zero(&ft_event, sizeof(ft_event));
        ft_event.ies = vap->iv_roam.iv_ft_params.fties;
        ft_event.ies_len = vap->iv_roam.iv_ft_params.fties_len;
        ft_event.target_ap = vap->iv_roam.iv_ft_params.target_ap;

        cfg80211_ft_event(dev, &ft_event);

        qdf_mem_free(vap->iv_roam.iv_ft_params.fties);
        vap->iv_roam.iv_ft_params.fties = NULL;
        vap->iv_roam.iv_ft_params.fties_len = 0;
        qdf_mem_zero(vap->iv_roam.iv_ft_params.target_ap, QDF_MAC_ADDR_SIZE);
    }
}

/**
 * clear_roam_params() - Clears roam related fields
 *
 * @vap: vap
 *
 * This function clears roam related fields
 *
 * Return: None
 */
static void clear_roam_params(wlan_if_t vap)
{
    if (vap->iv_roam.iv_roaming) {
        vap->iv_roam.iv_roaming = 0;
        if (vap->iv_roam.iv_ft_roam) {
            vap->iv_roam.iv_ft_roam = 0;
            vap->iv_roam.iv_wait_for_ftie_update = 0;
            if (vap->iv_roam.iv_ft_ie.ie) {
                qdf_mem_free(vap->iv_roam.iv_ft_ie.ie);
                vap->iv_roam.iv_ft_ie.ie = NULL;
                vap->iv_roam.iv_ft_ie.length = 0;
            }
            if (vap->iv_roam.iv_ft_params.fties) {
                qdf_mem_free(vap->iv_roam.iv_ft_params.fties);
                vap->iv_roam.iv_ft_params.fties = NULL;
                vap->iv_roam.iv_ft_params.fties_len = 0;
                qdf_mem_zero(vap->iv_roam.iv_ft_params.target_ap,
                    QDF_MAC_ADDR_SIZE);
            }
        }
    }
}

#ifdef QCA_BLOCK_EVENT_TO_USERSPACE
/**
 * is_valid_sub_mask_cfg () - checks if valid subtype is configured
 *
 * @ev_subtype: event subtype of each event type ACFG/ IWEVCUSTOM/ CFG
 *
 * This function is to check if user configured valid subtype event
 *
 * Return: 0 for success, non-zero for failure
 */
int is_valid_sub_mask_cfg(uint8_t ev_subtype)
{
    int ret = 0;

    switch (ev_subtype)
    {
        case FL_SUBTYPE_STA:
        case FL_SUBTYPE_AP:
        case FL_SUBTYPE_MGMT:
        case FL_SUBTYPE_SEC:
        case FL_SUBTYPE_SCAN:
        case FL_SUBTYPE_RADIO:
        case FL_SUBTYPE_VAP:
        case FL_SUBTYPE_MISC:
            qdf_info("Configured sub event type:%x", ev_subtype);
            break;
        default:
            qdf_err("Configured sub event type:%x is not valid", ev_subtype);
            ret = -EFAULT;
            break;
    }
    return ret;
}

#ifdef UMAC_SUPPORT_ACFG
/**
 * wlan_set_event_filter_acfg () - filter ACFG events
 *
 * @vap: pointer to vap
 * @ev_subtype: event subtype of ACFG events
 * @ev_mask: event mask to represent events
 * @ev_allow: event allow flag to block / allow individual ACFG event
 *
 * This function is to filter ACFG events based on subytpe & event mask
 * to allow / block events to user application
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_set_event_filter_acfg (wlan_if_t vap, u_int8_t ev_subtype,
                                u_int16_t ev_mask, int ev_allow)
{
    int idx;

    /* Configure individual events when 2nd arg allow flag is configured */
    if (ev_allow != DEFAULT_ALLOW_FLAG) {
        if (ev_mask > 0 && ev_mask < WL_ACFG_MAX_EVENT)
        {
            vap->iv_acfg_ev_fl[ev_mask].allow_to_app = ev_allow;
            if (vap->iv_acfg_ev_fl[ev_mask].subtype & ev_subtype)
                qdf_info("Configured event mask is %d",ev_mask);
            else
                qdf_info("INFO!! Subtype:0x%x mismatch for event:%d "
                          "proceeding with updating allow flag for the event",
                          ev_subtype, ev_mask);
            return 0;
        } else {
            qdf_err("Event ID: %d is out of range of MAX: %d supported",
                    ev_mask, WL_ACFG_MAX_EVENT);
            return -EINVAL;
        }
    }

    /* Configure group of events under subtype events */
    for (idx = 1; idx < WL_ACFG_MAX_EVENT; idx++)
    {
        if (vap->iv_acfg_ev_fl[idx].subtype & ev_subtype)
        {
            if (ev_mask == MASK_TO_BLOCK)
                vap->iv_acfg_ev_fl[idx].allow_to_app = 0;
            else
                vap->iv_acfg_ev_fl[idx].allow_to_app = 1;
        }
    }
    return 0;
}
#endif /* UMAC_SUPPORT_ACFG */

/**
 * wlan_set_event_filter_iwevcustom () - filter IWEVCUSTOM events
 *
 * @vap: pointer to vap
 * @ev_subtype: event subtype of IWEVCUSTOM events
 * @ev_mask: event mask to represent events
 * @ev_allow: event allow flag to block / allow individual IWEVCUSTOM event
 *
 * This function is to filter IWEVCUSTOM events based on subytpe & event mask
 * to allow / block events to user application
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_set_event_filter_iwevcustom (wlan_if_t vap, u_int8_t ev_subtype,
                                      u_int16_t ev_mask, int ev_allow)
{
    int idx;

    /* Configure individual events when 2nd arg allow flag is configured */
    if (ev_allow != DEFAULT_ALLOW_FLAG) {
        if (ev_mask >= 0 && ev_mask < IEEE80211_EV_MAX_EVENT)
        {
            vap->iv_iwevcustom_ev_fl[ev_mask].allow_to_app = ev_allow;
            if (vap->iv_iwevcustom_ev_fl[ev_mask].subtype & ev_subtype)
                qdf_info("Configured event mask is %d",ev_mask);
            else
                qdf_info("INFO!! Subtype:0x%x mismatch for event:%d,"
                         "proceeding with updating allow flag for the event",
                         ev_subtype, ev_mask);
            return 0;
        } else {
            qdf_err("Event ID: %d is out of range of MAX: %d supported",
                    ev_mask, IEEE80211_EV_MAX_EVENT);
            return -EINVAL;
        }
    }

    /* Configure group of events under subtype events */
    for (idx = 0; idx < IEEE80211_EV_MAX_EVENT; idx++)
    {
        if (vap->iv_iwevcustom_ev_fl[idx].subtype & ev_subtype)
        {
            if (ev_mask == MASK_TO_BLOCK)
                vap->iv_iwevcustom_ev_fl[idx].allow_to_app = 0;
            else
                vap->iv_iwevcustom_ev_fl[idx].allow_to_app = 1;
        }
    }
    return 0;
}

/**
 * wlan_set_event_filter_cfg () - filter CFG events
 *
 * @vap: pointer to vap
 * @ev_subtype: event subtype of CFG events
 * @ev_mask: event mask to represent events
 * @ev_allow: event allow flag to block / allow individual CFG event
 *
 * This function is to filter CFG events based on subytpe & event mask
 * to allow / block events to user application
 *
 * Return: 0 for success, non-zero for failure
 */
int wlan_set_event_filter_cfg (wlan_if_t vap, u_int8_t ev_subtype,
                               u_int16_t ev_mask, int ev_allow)
{
    int idx;

    /* Configure individual events when 2nd arg allow flag is configured */
    if (ev_allow != DEFAULT_ALLOW_FLAG) {
        if (ev_mask > 0 && ev_mask < QCA_NL80211_VENDOR_SUBCMD_INDEX_LAST)
        {
            vap->iv_cfg_ev_fl[ev_mask].allow_to_app = ev_allow;
            if (vap->iv_cfg_ev_fl[ev_mask].subtype & ev_subtype)
                qdf_info("Configured event mask is %d", ev_mask);
            else
                qdf_info("INFO!! Subtype:0x%x mismatch for event:%d,"
                         "proceeding with updating allow flag for the event",
                         ev_subtype, ev_mask);
            return 0;
        } else {
            qdf_err("Event ID: %d is out of range of MAX: %d supported",
                    ev_mask, QCA_NL80211_VENDOR_SUBCMD_INDEX_LAST);
            return -EINVAL;
        }
    }

    /* Configure group of events under subtype events */
    for (idx = 0; idx < QCA_NL80211_VENDOR_SUBCMD_INDEX_LAST; idx++)
    {
        if (vap->iv_cfg_ev_fl[idx].subtype & ev_subtype)
        {
            if (ev_mask == MASK_TO_BLOCK)
                vap->iv_cfg_ev_fl[idx].allow_to_app = 0;
            else
                vap->iv_cfg_ev_fl[idx].allow_to_app = 1;
        }
    }
    return 0;
}

#if UMAC_SUPPORT_ACFG
extern struct event_name_info g_acfg_event_name[WL_ACFG_MAX_EVENT];
/**
 * wlan_get_acfg_block_events () - get configured ACFG event filter
 *
 * @vap: pointer to vap
 *
 * This function is to get the configuration of event filter for ACFG events
 *
 * Return: count of configured ACFG events to block
 */
int wlan_get_acfg_block_events (wlan_if_t vap)
{
    int i, count = 0, each_count = 0;
    bool allow;
    uint8_t subtype;
    char *event_name = NULL;

    qdf_nofl_info("Subtype event - 0x1:AP  0x2:STA  0x4:SEC  0x8:SCAN  0x10:RADIO  0x20:MGMT  0x40:VAP  0x80:MISC");
    qdf_nofl_info("ACFG BLOCKED EVENT TABLE");
    qdf_nofl_info("-----------------------------------------------------------------------------------------------");
    qdf_nofl_info("|  EVENT_ID  |                  EVENT                  |  SUBTYPE  |  ALLOW_TO_APP  |  COUNT  |");
    qdf_nofl_info("-----------------------------------------------------------------------------------------------");

    for (i = 1; i < WL_ACFG_MAX_EVENT; i++)
    {
        if (vap->iv_acfg_ev_fl[i].allow_to_app == 0)
        {
            count += 1;
            allow = vap->iv_acfg_ev_fl[i].allow_to_app;
            subtype = vap->iv_acfg_ev_fl[i].subtype;
            each_count = vap->iv_acfg_ev_fl[i].count;
            event_name = g_acfg_event_name[i].event_name_str;
            qdf_nofl_info("|%6d      |%29s            |   (0x%02x)  |%11s     |%5d    |",
                          i, event_name, subtype , allow ? "true" : "false", each_count);
        }
    }
    qdf_nofl_info("-----------------------------------------------------------------------------------------------");
    return count;
}
#endif /* UMAC_SUPPORT_ACFG */

extern struct event_name_info g_iwevcustom_event_name[IEEE80211_EV_MAX_EVENT];
/**
 * wlan_get_iwevcustom_block_events () - get configured IWEVCUSTOM event filter
 *
 * @vap: pointer to vap
 *
 * This function is to get the configuration of event filter for IWEVCUSTOM events
 *
 * Return: count of configured IWEVCUSTOM events to block
 */
int wlan_get_iwevcustom_block_events (wlan_if_t vap)
{
    int j, count = 0, each_count = 0;
    bool allow;
    uint8_t subtype;
    char *event_name = NULL;

    qdf_nofl_info("Subtype event - 0x1:AP  0x2:STA  0x4:SEC  0x8:SCAN  0x10:RADIO  0x20:MGMT  0x40:VAP  0x80:MISC");
    qdf_nofl_info("IWEVCUSTOM BLOCKED EVENT TABLE");
    qdf_nofl_info("-----------------------------------------------------------------------------------------------");
    qdf_nofl_info("|  EVENT_ID  |                  EVENT                  |  SUBTYPE  |  ALLOW_TO_APP  |  COUNT  |");
    qdf_nofl_info("-----------------------------------------------------------------------------------------------");

    for (j = 0; j < IEEE80211_EV_MAX_EVENT; j++)
    {
        if (vap->iv_iwevcustom_ev_fl[j].allow_to_app == 0)
        {
            count += 1;
            allow = vap->iv_iwevcustom_ev_fl[j].allow_to_app;
            subtype = vap->iv_iwevcustom_ev_fl[j].subtype;
            each_count = vap->iv_iwevcustom_ev_fl[j].count;
            event_name = g_iwevcustom_event_name[j].event_name_str;
            qdf_nofl_info("|%6d      |%29s            |   (0x%02x)  |%11s     |%5d    |",
                          j, event_name, subtype , allow ? "true" : "false", each_count);
        }
    }
    qdf_nofl_info("-----------------------------------------------------------------------------------------------");
    return count;
}

extern struct event_name_info g_cfg_event_name[QCA_NL80211_VENDOR_SUBCMD_INDEX_LAST];
/**
 * wlan_get_cfg_block_events () - get configured CFG event filter
 *
 * @vap: pointer to vap
 *
 * This function is to get the configuration of event filter for CFG events
 *
 * Return: count of configured CFG events to block
 */
int wlan_get_cfg_block_events (wlan_if_t vap)
{
    int k, count = 0, each_count = 0;
    bool allow;
    uint8_t subtype;
    char *event_name = NULL;

    qdf_nofl_info("Subtype event - 0x1:AP  0x2:STA  0x4:SEC  0x8:SCAN  0x10:RADIO  0x20:MGMT  0x40:VAP  0x80:MISC");
    qdf_nofl_info("CFG BLOCKED EVENT TABLE");
    qdf_nofl_info("-----------------------------------------------------------------------------------------------");
    qdf_nofl_info("|  EVENT_ID  |                    EVENT                |  SUBTYPE  |  ALLOW_TO_APP  |  COUNT  |");
    qdf_nofl_info("-----------------------------------------------------------------------------------------------");

    for (k = 1 ; k < QCA_NL80211_VENDOR_SUBCMD_INDEX_LAST; k++)
    {
        if ((vap->iv_cfg_ev_fl[k].allow_to_app == 0) &&
                (vap->iv_cfg_ev_fl[k].subtype != 0))
        {
            count += 1;
            allow = vap->iv_cfg_ev_fl[k].allow_to_app;
            subtype = vap->iv_cfg_ev_fl[k].subtype;
            each_count = vap->iv_cfg_ev_fl[k].count;
            event_name = g_cfg_event_name[k].event_name_str;
            qdf_nofl_info("|%6d      |%35s      |   (0x%02x)  |%11s     |%5d    |",
                          k, event_name, subtype , allow ? "true" : "false", each_count);
        }
    }
    qdf_nofl_info("-----------------------------------------------------------------------------------------------");
    return count;
}

/**
 * wlan_cfg80211_set_event_filter () - set event filter configuration to
 * filter ACFG / CFG / IWEVCUSTOM events
 *
 * @wiphy : Pointer to wiphy
 * @wdev  : Pointer to wdev
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 for success or corresponding error code for failure.
 */
int wlan_cfg80211_set_event_filter (struct wiphy *wiphy,
                                    struct wireless_dev *wdev,
                                    struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    int ret = 0;
    u_int8_t ev_type, ev_subtype;
    u_int16_t ev_mask;
    u_int32_t ev_filter;
    int ev_allow;
    int *data = (int *) params->data;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);
    if (!cmd) {
        qdf_err("%s: cmd is NULL\n", __func__);
        return -EINVAL;
    }

    if (cmd_type == VAP_CMD) {
        vap = (wlan_if_t)cmd;
    } else {
        qdf_err("Invalid interface");
        return -EINVAL;
    }

    if (!vap) {
        qdf_err("VAP is NULL");
        return -EINVAL;
    }

    ev_filter = (uint32_t) data[0];
    ev_allow = params->value;
    if (!ev_filter) {
        qdf_err("Event filter is NULL");
        return -EINVAL;
    }
    if (ev_allow != 0xFF && (ev_allow < 0 || ev_allow > 1)) {
        qdf_err("Invalid allow flag value");
        return -EINVAL;
    }

    ev_type = GET_FILTER_TYPE(ev_filter);
    ev_subtype = GET_FILTER_SUBTYPE(ev_filter);
    ev_mask = GET_FILTER_EVENT_MASK(ev_filter);

    if (is_valid_sub_mask_cfg(ev_subtype)) {
        return -EINVAL;
    }

    if ((ev_allow == DEFAULT_ALLOW_FLAG) &&
        (ev_mask > MASK_TO_BLOCK && ev_mask < MASK_TO_ALLOW)) {
        qdf_err("Second param is mandatory to block individual event");
        return -EINVAL;
    }

    switch(ev_type)
    {
        case EVENT_ACFG:
#ifdef UMAC_SUPPORT_ACFG
            ret = wlan_set_event_filter_acfg(vap, ev_subtype, ev_mask, ev_allow);
            if (ret) {
                qdf_err("Filter setting for ACFG events failed");
                return -EFAULT;
            }
#endif /* UMAC_SUPPORT_ACFG */
            break;
        case EVENT_IWEVCUSTOM:
            ret = wlan_set_event_filter_iwevcustom(vap, ev_subtype, ev_mask, ev_allow);
            if (ret) {
                qdf_err("Filter setting for wireless custom events failed");
                return -EFAULT;
            }
            break;
        case EVENT_CFG:
            ret = wlan_set_event_filter_cfg(vap, ev_subtype, ev_mask, ev_allow);
            if (ret) {
                qdf_err("Filter setting for CFG events failed");
                return -EFAULT;
            }
            break;
        default:
            qdf_err("Block events filter type: %d not supported",ev_type);
            break;
    }
    return ret;
}

/**
 * wlan_cfg80211_get_event_filter () - get event filter configuration to
 * filter ACFG / CFG / IWEVCUSTOM events
 *
 * @wiphy : Pointer to wiphy
 * @wdev  : Pointer to wdev
 * @params: Pointer to wlan_cfg80211_genric_params
 *
 * Return: 0 for success or corresponding error code for failure.
 */
int wlan_cfg80211_get_event_filter (struct wiphy *wiphy,
                                    struct wireless_dev *wdev,
                                    struct wlan_cfg8011_genric_params *params)
{
    struct ieee80211com *ic = NULL;
    wlan_if_t vap = NULL;
    int cmd_type;
    void *cmd;
    uint8_t ev_type = params->value;
    int ret = 0;

    ic = wlan_cfg80211_get_ic_ptr(wiphy, wdev, params->link_id);
    if (!ic) {
        qdf_err("ic NULL");
        return -EINVAL;
    }

    cmd = extract_command(ic, wdev, &cmd_type, params->link_id);
    if (!cmd) {
        qdf_err("cmd is NULL\n");
        return -EINVAL;
    }

    if (cmd_type == VAP_CMD) {
        vap = (wlan_if_t)cmd;
    } else {
        qdf_err("Invalid interface");
        return -EINVAL;
    }

    if (!vap) {
        qdf_err("VAP is NULL");
        return -EINVAL;
    }

    if (!ev_type) {
        qdf_err("Enter valid event type to check blocked events");
        return -EFAULT;
    }

    switch(ev_type)
    {
        case EVENT_ACFG:
#ifdef UMAC_SUPPORT_ACFG
            ret = wlan_get_acfg_block_events (vap);
#endif /* UMAC_SUPPORT_ACFG */
            break;
        case EVENT_IWEVCUSTOM:
            ret = wlan_get_iwevcustom_block_events (vap);
            break;
        case EVENT_CFG:
            ret = wlan_get_cfg_block_events (vap);
            break;
        default:
            qdf_err("Event type : %d not supported", ev_type);
            break;
    }
    return cfg80211_reply_command(wiphy, sizeof(ret), &ret, 0);
}
#endif /* QCA_BLOCK_EVENT_TO_USERSPACE */

int wlan_cfg80211_reset_channel_survey_stats(struct ieee80211com *ic)
{

    qdf_spin_lock_bh(&ic->ic_channel_stats.lock);
    qdf_mem_zero(&ic->ic_channel_stats.home_chan_stats,
            sizeof(ic->ic_channel_stats.home_chan_stats));
    qdf_mem_zero(&ic->ic_channel_stats.scan_chan_stats[0],
            sizeof(ic->ic_channel_stats.scan_chan_stats));
    qdf_spin_unlock_bh(&ic->ic_channel_stats.lock);

    return 0;
}

int wlan_cfg80211_get_channel_survey_stats(struct ieee80211com *ic)
{
    uint8_t *scan_stats_block_start;
    uint32_t scan_stats_block_length;
    struct channel_stats *home_chan_stats = NULL;
    struct channel_stats *scan_chan_stats[NUM_CHANNELS] = {0};
    const uint32_t scan_stats_entry_size =
                   sizeof(ic->ic_channel_stats.scan_chan_stats[0]);
    int ret = 0;
    uint16_t channel_index;
    int i = 0;

    qdf_spin_lock_bh(&ic->ic_channel_stats.lock);

    home_chan_stats = qdf_mem_malloc(sizeof(struct channel_stats));
    if (!home_chan_stats) {
        qdf_err("Failed to allocate memory for home channel stats");
        ret = -ENOMEM;
        qdf_spin_unlock_bh(&ic->ic_channel_stats.lock);
        goto home_chan_stats_failed;
    }
    memcpy(home_chan_stats, &ic->ic_channel_stats.home_chan_stats,
           sizeof(struct channel_stats));

    scan_stats_block_start = (uint8_t *)ic->ic_channel_stats.scan_chan_stats;
    scan_stats_block_length = 0;
    for (channel_index = 0; channel_index < NUM_CHANNELS; channel_index++) {
        if ((scan_stats_block_length + scan_stats_entry_size) <
             LIST_ALLOC_SIZE) {
            scan_stats_block_length += scan_stats_entry_size;
            continue;
        }

        scan_chan_stats[channel_index] = qdf_mem_malloc(scan_stats_block_length);
        if (!scan_chan_stats[channel_index]) {
            qdf_err("Failed to allocate memory for scan stats");
            ret = -ENOMEM;
            qdf_spin_unlock_bh(&ic->ic_channel_stats.lock);
            goto scan_stats_failed;
        }
        memcpy(scan_chan_stats[channel_index], scan_stats_block_start,
               scan_stats_block_length);
        scan_stats_block_start = (uint8_t *)&ic->ic_channel_stats.
            scan_chan_stats[channel_index];
        scan_stats_block_length = scan_stats_entry_size;
    }

    if (scan_stats_block_length && channel_index < NUM_CHANNELS) {
        scan_chan_stats[channel_index] = qdf_mem_malloc(scan_stats_block_length);
        if (!scan_chan_stats[channel_index]) {
            qdf_err("Failed to allocate memory for scan stats");
            ret = -ENOMEM;
            qdf_spin_unlock_bh(&ic->ic_channel_stats.lock);
            goto scan_stats_failed;
        }
        memcpy(scan_chan_stats[channel_index], scan_stats_block_start,
               scan_stats_block_length);
    }

    qdf_spin_unlock_bh(&ic->ic_channel_stats.lock);

    ret = cfg80211_reply_command(ic->ic_wiphy, sizeof(struct channel_stats),
                                 home_chan_stats,
                                 CFG80211_GET_CHAN_SURVEY_HOME_CHANNEL_STATS);
    if (ret) {
        qdf_err("Failed to send home channel stats, ret = %d", ret);
        goto scan_stats_failed;
    }

    scan_stats_block_length = 0;
    for (channel_index = 0; channel_index < NUM_CHANNELS; channel_index++) {
        if ((scan_stats_block_length + scan_stats_entry_size) <
             LIST_ALLOC_SIZE) {
            scan_stats_block_length += scan_stats_entry_size;
            continue;
        }

        ret = cfg80211_reply_command(ic->ic_wiphy, scan_stats_block_length,
                               scan_chan_stats[channel_index],
                               CFG80211_GET_CHAN_SURVEY_SCAN_CHANNEL_STATS);
        if (ret) {
            qdf_err("Failed to send scan channel stats, ret = %d", ret);
            goto scan_stats_failed;
        }
        scan_stats_block_length = scan_stats_entry_size;
    }

    if (scan_stats_block_length && channel_index < NUM_CHANNELS) {
        ret = cfg80211_reply_command(ic->ic_wiphy, scan_stats_block_length,
                                   scan_chan_stats[channel_index],
                                   CFG80211_GET_CHAN_SURVEY_SCAN_CHANNEL_STATS);
        if (ret) {
            qdf_err("Failed to send scan channel stats, ret = %d", ret);
            goto scan_stats_failed;
        }
    }

scan_stats_failed:
    for (i = channel_index - 1; i >= 0; i--) {
        if (scan_chan_stats[i])
            qdf_mem_free(scan_chan_stats[i]);
    }
home_chan_stats_failed:
    if (home_chan_stats)
        qdf_mem_free(home_chan_stats);
    return ret;
}

void wlan_cfg80211_flush_rate_stats(void *ctrl_pdev, enum WDI_EVENT event,
                                    void *ptr, uint16_t len,
                                    uint32_t type)
{
    struct wlan_objmgr_pdev *pdev;
    struct wlan_peer_rate_stats_intf *buf;
    uint32_t max_buf_len;
    struct ol_ath_softc_net80211 *scn = NULL;
    struct pdev_osif_priv *osif_priv = NULL;
    struct ieee80211com * ic = NULL;
    struct sk_buff *vendor_event;
    const uint32_t NUM_TLVS = 10;
    struct net_device *dev;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
    int ret_val;
#endif

   pdev = (struct wlan_objmgr_pdev *)ctrl_pdev;
   buf = (struct wlan_peer_rate_stats_intf *)ptr;
   max_buf_len = max(WLANSTATS_CACHE_SIZE * sizeof(struct wlan_tx_rate_stats),
                     WLANSTATS_CACHE_SIZE * sizeof(struct wlan_rx_rate_stats));

    if (buf->buf_len > max_buf_len) {
        qdf_err("recevied buf len excceds max buffer len, return");
        return;
    }

    osif_priv = wlan_pdev_get_ospriv(pdev);
    scn = (struct ol_ath_softc_net80211 *)osif_priv->legacy_osif_priv;
    ic = &scn->sc_ic;
    dev = ic->ic_netdev;
#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    if (!osif_scn_event_filter_status_to_app(ic, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_PEER_STATS_CACHE_FLUSH_INDEX)) {
        return;
    }
    vendor_event =
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, NULL,
#else
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy,
                                                    dev->ieee80211_ptr,
#endif
                        buf->buf_len + NLMSG_HDRLEN + NUM_TLVS*sizeof(uint32_t),
                        QCA_NL80211_VENDOR_SUBCMD_PEER_STATS_CACHE_FLUSH_INDEX,
                        GFP_ATOMIC);

    if (!vendor_event) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "cfg80211_vendor_event_alloc failed\n");
        return;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);

    /* Send the IF INDEX to differentiate the ACS event for each interface
     * Needs to be updated once cfg80211 APIs are updated to accept if_index
     */
    ret_val = nla_put_u32(vendor_event,
            NL80211_ATTR_IFINDEX,
            dev->ifindex);
    if (ret_val) {
        qdf_warn("NL80211_ATTR_IFINDEX put fail");
        goto error_cleanup;
    }

    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);

    if(nla == NULL){
        qdf_warn("nla_nest_start fail nla is NULL ");
        goto error_cleanup;
    }

    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);
#endif

    if (nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_PEER_STATS_CACHE_TYPE,
                buf->stats_type)) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "%s:%d nla put fail", __func__, __LINE__);
        goto error_cleanup;
    }

    if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_PEER_STATS_CACHE_PEER_MAC,
                6, (void *)buf->peer_mac)) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "%s:%d nla put fail", __func__, __LINE__);
        goto error_cleanup;
    }

    if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_PEER_STATS_CACHE_DATA,
                buf->buf_len, buf->stats)) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_DEBUG,
                "%s:%d nla put fail", __func__, __LINE__);
        goto error_cleanup;
    }
    if (wlan_nla_put_u64(vendor_event, QCA_WLAN_VENDOR_ATTR_PEER_STATS_CACHE_PEER_COOKIE,
                buf->cookie)) {
        QDF_TRACE(QDF_MODULE_ID_DEBUG, QDF_TRACE_LEVEL_ERROR,
                "%s:%d nla put fail", __func__, __LINE__);
        goto error_cleanup;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(vendor_event, nla);
#endif

    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);
    return;

error_cleanup:
    wlan_cfg80211_vendor_free_skb(vendor_event);
    return;
}
qdf_export_symbol(wlan_cfg80211_flush_rate_stats);


int cfg80211_populate_vdev_group_index_status(struct ieee80211com *ic,
        uint32_t *vdev_if_indexs,
        uint8_t *vdev_if_status, uint8_t grp_id)
{
    struct ieee80211_mbss_ie_cache_node *node;
    struct wlan_objmgr_vdev *vdev;
    struct wlan_objmgr_psoc *psoc;
    int idx;
    struct mbssid_context *mbss_ctx;
    struct mbssid_info *ic_mbss;
    struct ieee80211vap *vap;
    osif_dev *osif = NULL;
    struct net_device *dev = NULL;
    int i =0;

    psoc = wlan_pdev_get_psoc(ic->ic_pdev_obj);
    if (!psoc) {
        mbss_err("psoc is NULL!\n");
        return -1;
    }

    if (!ic->is_mbssid_enabled) {
        mbss_err("MBSS IE feature not enabled!\n");
        return -1;
    }

    if (!ic->ic_mbss_ctx) {
        mbss_err("ic_mbss_ctx is null");
        return -1;
    }

    mbss_ctx = ic->ic_mbss_ctx;
    ic_mbss = &mbss_ctx->ic_mbss[grp_id];

    if (ieee80211_mbssid_get_num_vaps_in_mbss_cache(ic, grp_id) < 1) {
        mbss_err("No MBSSID/EMA VAPs in group: %d\n",grp_id);
        return -1;
    }
    node = (struct ieee80211_mbss_ie_cache_node *) ic_mbss->mbss_cache;
    if (!node) {
        mbss_err("MBSS cache node is NULL! for group: %d \n", grp_id);
        return -1;
    }

    qdf_debug("GroupID: %d", grp_id);
    /* acquire mbss_cache_lock */
    qdf_spin_lock_bh(&ic_mbss->mbss_cache_lock);

    for (idx = 0; idx < mbss_ctx->grp_sz; idx++) {

        node = &((struct ieee80211_mbss_ie_cache_node *)
                ic_mbss->mbss_cache)[idx];

        if (node && node->used) {
            vdev = wlan_objmgr_get_vdev_by_id_from_psoc(psoc, node->vdev_id,
                    WLAN_MISC_ID);
            if (!vdev) {
                continue;
            }

            vap = wlan_vdev_mlme_get_ext_hdl(vdev);
            if (!vap) {
                wlan_objmgr_vdev_release_ref(vdev, WLAN_MISC_ID);
                continue;
            }

            osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
            dev = get_cfg80211_notification_ndev(osif);
            vdev_if_indexs[i] = dev->ifindex;

            if ((dev->flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING)) {
                vdev_if_status[i] = 1;
            } else {
                vdev_if_status[i] = 0;
            }

            i++;
            wlan_objmgr_vdev_release_ref(vdev, WLAN_MISC_ID);
        } /* if node */

    } /* for */

    qdf_spin_unlock_bh(&ic_mbss->mbss_cache_lock);
    return 0;
}

/**
 * get_mbssid_multigroup_tx_vdev_notification_len -
 *  calculate length required for multigroup tx vdev notifications
 *
 * @num_vdev: Number of vdevs
 *
 * Return: length required for event.
 */
int get_mbssid_multigroup_tx_vdev_notification_len(int num_vdev)
{
    uint32_t len = NLMSG_HDRLEN;
    uint32_t group_info_len = num_vdev * (sizeof(u32)+sizeof(u8));

    /* QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_STATUS_VAL */
    len += nla_total_size(sizeof(u8));
    /* QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_EVENT */
    len += nla_total_size(sizeof(u8));
    /* QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_ID */
    len += nla_total_size(sizeof(u8));
    /* QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_INFO */
    len += nla_total_size(group_info_len);

    return len;
}

/**
 * wlan_cfg80211_mbssid_multigroup_tx_vdev_notification -
 *  Send group information to user space for TX vap up/down events.
 * This event sends Tx and Non-Tx VDEV IF_INDEX and
 * VDEV up/down status to user space for Tx VAP's group
 *
 * @vap: Pointer to vap object
 * @is_up_event: 1 - Tx VAP up event; 0- Tx VAP down event
 *
 * Return: None
 */
void wlan_cfg80211_mbssid_multigroup_tx_vdev_notification(wlan_if_t vap, bool is_up_event)
{
    struct sk_buff *vendor_event;
    int ret_val;
    struct ieee80211com *ic = NULL;
    osif_dev *osif = NULL;
    struct net_device *dev = NULL;
    uint8_t is_tx_vap;
    struct nlattr *nla;
    uint8_t grp_id, num_vdevs;
    uint32_t vdev_if_indexs[IEEE80211_MAX_VAPS] = {0};
    uint8_t vdev_if_status[IEEE80211_MAX_VAPS] = {0};
    struct nlattr *group_config, *group_params;
    int i =0, length;

    if (!vap) {
        qdf_err("VAP is null");
        return;
    }

#if UMAC_SUPPORT_CFG80211
    if(!vap->iv_cfg80211_create) {
       qdf_err("cfg80211 mode is disabled");
       return;
    }
#endif

    ic = vap->iv_ic;
    osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    dev = get_cfg80211_notification_ndev(osif);

    grp_id = vap->iv_mbss.group_id;
    num_vdevs = ieee80211_mbssid_get_num_vaps_in_mbss_cache(ic, grp_id);
    length = get_mbssid_multigroup_tx_vdev_notification_len(num_vdevs);

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    if (!osif_vap_event_filter_status_to_app(vap, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_MBSSID_TX_VDEV_STATUS_INDEX)) {
        return;
    }
    vendor_event =
        wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, dev->ieee80211_ptr,
                length,
                QCA_NL80211_VENDOR_SUBCMD_MBSSID_TX_VDEV_STATUS_INDEX,
                GFP_ATOMIC);
    if (!vendor_event) {
        qdf_err("cfg80211_vendor_event_alloc failed: vdev:id :%d",
                vap->iv_unit);
        return;
    }

    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);

    ret_val = nla_put_u32(vendor_event,
            NL80211_ATTR_IFINDEX,
            dev->ifindex);
    if (ret_val) {
        qdf_err("NL80211_ATTR_IFINDEX put fail");
        goto error_cleanup;
    }
    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);
    if(nla == NULL){
        qdf_err("nla_nest_start fail nla is NULL ");
        goto error_cleanup;
    }
    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);

    is_tx_vap = IEEE80211_VAP_IS_MBSS_NON_TRANSMIT_ENABLED(vap) ? 0: 1;

    ret_val = nla_put_u8(vendor_event,
            QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_STATUS_VAL,
            is_tx_vap);

    if (ret_val) {
        qdf_err("QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_STATUS_VAL put fail");
        goto error_cleanup;
    }

    ret_val = nla_put_u8(vendor_event,
            QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_EVENT,
            is_up_event);
    if (ret_val) {
        qdf_err("QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_EVENT put fail");
        goto error_cleanup;
    }
    ret_val = nla_put_u8(vendor_event,
            QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_ID,
            grp_id);
    if (ret_val) {
        qdf_err("QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_ID put fail");
        goto error_cleanup;
    }

    mbss_info("UP Event: %d Group ID: %d is_txvap:%d", is_up_event, grp_id, is_tx_vap);
    cfg80211_populate_vdev_group_index_status(ic, &vdev_if_indexs[0], &vdev_if_status[0], grp_id);

    group_config = nla_nest_start(vendor_event,
            QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_INFO);

    if (!group_config) {
        qdf_err("QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_INFO nla nest start fails");
        goto error_cleanup;
    }

    for (i = 0; i < num_vdevs ; i++) {
        group_params = nla_nest_start(vendor_event, i);

        if (!group_params) {
            qdf_err("nla_nest_start fail");
            goto error_cleanup;
        }
        ret_val = nla_put_u32(vendor_event,
                QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_INFO_IF_INDEX,
                vdev_if_indexs[i]);
        if (ret_val) {
            qdf_err("QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_INFO_IF_INDEX put fail");
            goto error_cleanup;
        }

        ret_val = nla_put_u8(vendor_event,
                QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_INFO_STATUS,
                vdev_if_status[i]);
        if (ret_val) {
            qdf_err("QCA_WLAN_VENDOR_ATTR_MBSSID_TX_VDEV_GROUP_INFO_STATUS put fail");
            goto error_cleanup;
        }
        mbss_info("vap:%d if_index: %d if_status: %d", i, vdev_if_indexs[i], vdev_if_status[i]);
        nla_nest_end(vendor_event, group_params); /* nested attribute end for group_params */
    }

    nla_nest_end(vendor_event, group_config); /* nested attribute end for group_config */
    nla_nest_end(vendor_event, nla); /* nested attribute end for vendor data */

    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);
    mbss_debug("TxVap multi group event notified for vdev %d", vap->iv_unit);
    return;

error_cleanup:
    wlan_cfg80211_vendor_free_skb(vendor_event);
}

#ifdef WLAN_FEATURE_11BE_MLO
/**
 * wlan_get_ifidx_by_link_id - Search through vdevs and find the ifindex of
 * vdev with matching link id.
 *
 * @vap: Pointer to the vap object
 * @link_id: link_id of the link
 * Return: Corresponding ifindex
 */

uint32_t wlan_get_ifidx_by_link_id(wlan_if_t vap, uint8_t link_id)
{
    struct wlan_objmgr_vdev *link_vdev;
    osif_dev *link_osif = NULL;
    wlan_if_t link_vap = NULL;
    struct net_device *netdev = NULL;

    link_vdev = mlo_get_vdev_by_link_id(vap->vdev_obj, link_id,
                                        WLAN_MLO_MGR_ID);
    if (!link_vdev) {
        mlo_err("vdev not found for the link id: %d",
                link_id);
        return -EINVAL;
    }
    link_vap = wlan_vdev_mlme_get_ext_hdl(link_vdev);
    if (!link_vap) {
        mlo_err("Vap handle not found for the link id: %d",
                link_id);
        goto error;
    }
    link_osif = (osif_dev *)wlan_vap_get_registered_handle(link_vap);
    if (!link_osif) {
        mlo_err("osif handle not found for the link id: %d",
                link_id);
        goto error;
    }
    mlo_release_vdev_ref(link_vdev);
    netdev = get_cfg80211_notification_ndev(link_osif);
    return netdev->ifindex;
error:
    mlo_release_vdev_ref(link_vdev);
    return -EINVAL;
}
qdf_export_symbol(wlan_get_ifidx_by_link_id);

/**
 * wlan_cfg80211_prim_netdev_notification -
 * Send notification to Application layer about primary netdev of an MLO peer
 * through cfg80211 events
 * @vap: Pointer to vap object
 * @peer: pointer to peer object
 * Return: None
 */

void wlan_cfg80211_prim_netdev_notification(wlan_if_t vap, struct wlan_objmgr_peer *peer)
{
    struct sk_buff *vendor_event;
    int ret_val;
    struct ieee80211com *ic = NULL;
    osif_dev *osif = NULL;
    struct net_device *dev = NULL, *mld_dev = NULL;
    int length, i;
    uint8_t prim_peer_link_id, num_links = 0, partner_link_id;
    uint32_t prim_ifindex, partner_link_ifindex;
    struct mlo_partner_info ml_links = {0};
    struct nlattr *partner_link_info, *partner_link_params;
    struct wlan_objmgr_vdev *vdev;
    struct wlan_mlo_dev_context *ml_dev = NULL;

    if (!peer || !peer->mlo_peer_ctx) {
        mlo_err("Peer is null");
        return;
    }
    if (!vap) {
        mlo_err("VAP is null for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        return;
    }

    vdev =  wlan_peer_get_vdev(peer);
    if (vdev) {
        ml_dev = vdev->mlo_dev_ctx;
        if (!ml_dev)
            return;
    } else {
        return;
    }

    ic = vap->iv_ic;
    osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    dev = get_cfg80211_notification_ndev(osif);
    wlan_mlo_peer_get_partner_links_info(peer, &ml_links);
    if (ml_links.num_partner_links <= IEEE80211_MAX_MLD_LINKS) {
        num_links = ml_links.num_partner_links;
    }

    length = NLMSG_HDRLEN +
             /* prim_netdev_ifindex */
             nla_total_size(sizeof(u32)) +
             /* mld ifindex */
             nla_total_size(sizeof(u32)) +
             /* link MAC_ADDR */
             nla_total_size(ETH_ALEN) +
             /* MLD MAC ADDR */
             nla_total_size(ETH_ALEN) +
             /* num of links */
             nla_total_size(sizeof(u8)) +
             /* partner link ifindex and mac address */
             nla_total_size (num_links * (sizeof(u32) + (ETH_ALEN)));

    if (!osif_vap_event_filter_status_to_app(vap, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_MLO_PEER_PRIM_NETDEV_EVENT_INDEX)) {
        return;
    }
    vendor_event =
        wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, dev->ieee80211_ptr,
                length,
                QCA_NL80211_VENDOR_SUBCMD_MLO_PEER_PRIM_NETDEV_EVENT_INDEX,
                GFP_ATOMIC);
    if (!vendor_event) {
        mlo_err("cfg80211_vendor_event_alloc failed: vdev:id :%d"
                "Peer mac address: " QDF_MAC_ADDR_FMT,
                vap->iv_unit, QDF_MAC_ADDR_REF(peer->macaddr));
        return;
    }
    ret_val = nla_put(vendor_event,
                      QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_MACADDR,
                      ETH_ALEN, peer->macaddr);
    if (ret_val) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_MACADDR"
                "put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }
    ret_val = nla_put(vendor_event,
                      QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_MLD_MAC_ADDR,
                      ETH_ALEN, peer->mlo_peer_ctx->peer_mld_addr.bytes);
    if (ret_val) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_MLD_MAC_ADDR"
                " put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }
    prim_peer_link_id = wlan_mlo_peer_get_primary_peer_link_id(peer);

    if (prim_peer_link_id == WLAN_LINK_ID_INVALID) {
        mlo_err("Primary peer link id invalid for peer mac address: "
                QDF_MAC_ADDR_FMT, QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }

    prim_ifindex  = wlan_get_ifidx_by_link_id(vap, prim_peer_link_id);
    if (prim_ifindex == -EINVAL) {
        mlo_err("Primary peer ifindex invalid for peer mac address: "
                QDF_MAC_ADDR_FMT, QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }
    ret_val = nla_put_u32(vendor_event,
                          QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_PRIM_IFINDEX,
                          prim_ifindex);
    if (ret_val) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_PRIM_IFINDEX"
                "put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }
    mld_dev = osif_find_mld_dev_for_all_groups(ml_dev->mld_addr.bytes);
    if (!mld_dev)
        return;
    ret_val = nla_put_u32(vendor_event,
                          QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_MLD_IFINDEX,
                          mld_dev->ifindex);
    if (ret_val) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_MLD_IFINDEX"
                "put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }
    ret_val = nla_put_u32(vendor_event,
                          QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_NUM_LINKS ,
                          num_links);
    if (ret_val) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_NUM_LINKS "
                "put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }

    partner_link_info = nla_nest_start(vendor_event,
                    QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_LINK_INFO);

    if (!partner_link_info) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_PEER_PRIM_NETDEV_EVENT_LINK_INFO"
                " nla nest start fails");
        goto error_cleanup;
    }

    for (i = 0; i < num_links; i++) {
        partner_link_params = nla_nest_start(vendor_event, i);

        if (!partner_link_params) {
            mlo_err("nla_nest_start fail");
            goto error_cleanup;
        }

        partner_link_id = ml_links.partner_link_info[i].link_id;
        partner_link_ifindex  = wlan_get_ifidx_by_link_id(vap,
                                                            partner_link_id);
        ret_val = nla_put_u32(vendor_event,
                          QCA_WLAN_VENDOR_ATTR_MLO_LINK_INFO_IFINDEX,
                          partner_link_ifindex);
        if (ret_val) {
            mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_LINK_INFO_IFINDEX"
                    " put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                    QDF_MAC_ADDR_REF(peer->macaddr));
            goto error_cleanup;
        }

        ret_val = nla_put(vendor_event,
                QCA_WLAN_VENDOR_ATTR_MLO_LINK_INFO_MACADDR,
                ETH_ALEN, ml_links.partner_link_info[i].link_addr.bytes);
        if (ret_val) {
            mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_LINK_INFO_MACADDR"
                    " put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                    QDF_MAC_ADDR_REF(peer->macaddr));
            goto error_cleanup;
        }
        mlo_info("link id: %d, ifindex: %d, macaddr:"
                 QDF_MAC_ADDR_FMT, partner_link_id, partner_link_ifindex,
                 ml_links.partner_link_info[i].link_addr.bytes);
        nla_nest_end(vendor_event, partner_link_params);
    }
    nla_nest_end(vendor_event, partner_link_info);

    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);
    mlo_info("Vendor event Created for peer mac address: " QDF_MAC_ADDR_FMT
             "Peer mld address: " QDF_MAC_ADDR_FMT
             "Primary Peer Link ID:%d, Primary peer ifindex: %d,"
             "MLD ifindex:%d",
             QDF_MAC_ADDR_REF(peer->macaddr),
             QDF_MAC_ADDR_REF(peer->mlo_peer_ctx->peer_mld_addr.bytes),
             prim_peer_link_id, prim_ifindex, mld_dev->ifindex);
    return;

error_cleanup:
    wlan_cfg80211_vendor_free_skb(vendor_event);
}

qdf_export_symbol(wlan_cfg80211_prim_netdev_notification);


/**
 * wlan_cfg80211_hw_status_notification -
 * Send notification for HW status through cfg80211 events
 * @vap: Pointer to vap object
 * @peer: pointer to peer object
 * @enable: Enable(1)/Disable(0) AMSDU
 * Return: None
 */
void wlan_cfg80211_hw_status_notification(wlan_if_t vap, struct wlan_objmgr_peer *peer, bool enable)
{
    struct sk_buff *vendor_event;
    int ret_val;
    struct ieee80211com *ic = NULL;
    osif_dev *osif = NULL;
    struct net_device *dev = NULL;
    int length;
    struct wlan_objmgr_vdev *vdev = NULL;

    if (!peer) {
        mlo_err("Peer is null");
        return;
    }
    if (!vap) {
        mlo_err("VAP is null for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        return;
    }

    ic = vap->iv_ic;
    osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    dev = osif->netdev;
    vdev = wlan_peer_get_vdev(peer);
    length = NLMSG_HDRLEN +
             nla_total_size(sizeof(uint8_t)) +
             nla_total_size(sizeof(uint8_t)) +
             nla_total_size(ETH_ALEN);

    if (!osif_vap_event_filter_status_to_app(vap, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_QCOM_HW_STATUS_INDEX)) {
        return;
    }
    vendor_event = wlan_cfg80211_vendor_event_alloc(
                           ic->ic_wiphy, dev->ieee80211_ptr,
                           length,
                           QCA_NL80211_VENDOR_SUBCMD_QCOM_HW_STATUS_INDEX,
                           GFP_ATOMIC);
    if (!vendor_event) {
        mlo_err("cfg80211_vendor_event_alloc failed: vdev:id :%d"
                "Peer mac address: " QDF_MAC_ADDR_FMT,
                vap->iv_unit, QDF_MAC_ADDR_REF(peer->macaddr));
        return;
    }

    ret_val = nla_put_u8(vendor_event,
                         QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_CATEGORY,
                         QCA_WLAN_VENDOR_HW_STATUS_RAW_MODE);
    if (ret_val) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_CATEGORY"
                "put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }
    ret_val = nla_put(vendor_event,
                      QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_MACADDR,
                      ETH_ALEN, peer->mlo_peer_ctx->peer_mld_addr.bytes);
    if (ret_val) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_MACADDR"
                "put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }
    if (wlan_vdev_mlme_is_ap(vdev) == true)
        ret_val = nla_put(vendor_event,
                          QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_LINK_MACADDR,
                          ETH_ALEN, vdev->vdev_mlme.macaddr);
    else
        ret_val = nla_put(vendor_event,
                          QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_LINK_MACADDR,
                          ETH_ALEN, peer->macaddr);
    if (ret_val) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_LINK_MACADDR"
                "put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }
    if (enable)
        ret_val = nla_put_u8(vendor_event,
                             QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_PARAM,
                             ENABLE_AMSDU);
    else
        ret_val = nla_put_u8(vendor_event,
                             QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_PARAM,
                             DISABLE_AMSDU);
    if (ret_val) {
        mlo_err("QCA_WLAN_VENDOR_ATTR_MLO_HW_STATUS_EVENT_PARAM"
                "put fail for peer mac address: " QDF_MAC_ADDR_FMT,
                QDF_MAC_ADDR_REF(peer->macaddr));
        goto error_cleanup;
    }
    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);
    IEEE80211_DPRINTF(vap, IEEE80211_MSG_HW_STATUS, "Vendor event for HW status"
                      " for peer mld mac: " QDF_MAC_ADDR_FMT,
                      QDF_MAC_ADDR_REF(peer->mlo_peer_ctx->peer_mld_addr.bytes));

    mlo_info("Vendor event created to enable(1)/disable(0) amsdu: %d for peer"
             "mac address: " QDF_MAC_ADDR_FMT, enable,
             QDF_MAC_ADDR_REF(peer->macaddr));
    return;

error_cleanup:
    wlan_cfg80211_vendor_free_skb(vendor_event);
}
#endif /* WLAN_FEATURE_11BE_MLO */

#ifdef QCA_SUPPORT_WDS_EXTENDED
void wlan_cfg80211_wds_ext_peer_learn(wlan_if_t vap,
                                      uint8_t peer_mac_addr[QDF_MAC_ADDR_SIZE])
{
    osif_dev *osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    struct net_device *dev = get_cfg80211_notification_ndev(osif);

#if defined(ENABLE_CFG80211_BACKPORTS_MLO) && defined(CFG80211_UNEXP_4ADDR_MLO)
    cfg80211_rx_unexpected_4addr_frame(dev, peer_mac_addr,
                                       GFP_ATOMIC, vap->link_id);
#else
    cfg80211_rx_unexpected_4addr_frame(dev, peer_mac_addr, GFP_ATOMIC);
#endif
}

qdf_export_symbol(wlan_cfg80211_wds_ext_peer_learn);
#endif /* QCA_SUPPORT_WDS_EXTENDED */

#ifdef WLAN_SUPPORT_SCS
/**
 * wlan_cfg80211_scs_rule_config - Send NL event for SCS rule configuration
 *
 * @vap: Pointer to vap object
 * @scs_rule_intf: Pointer to SCS rule interface object
 *
 * Return: None
 */
void wlan_cfg80211_scs_rule_config(wlan_if_t vap,
                                   struct ieee80211_scs_rule_config_intf *scs_rule_intf)
{
    struct ieee80211com *ic = vap->iv_ic;
    osif_dev *osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    struct sk_buff *vendor_event;
    struct net_device *dev = osif->netdev;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
    int ret_val;
#endif
    uint8_t classifier_mask = 0;

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    vendor_event =
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, NULL,
#else
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy,
                                                    dev->ieee80211_ptr,
#endif
                        MAX_CFG80211_BUF_LEN,
                        QCA_NL80211_VENDOR_SUBCMD_SCS_RULE_CONFIG_INDEX,
                        GFP_ATOMIC);

    if (!vendor_event) {
        qdf_err("cfg80211_vendor_event_alloc failed.");
        return;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);
    ret_val = nla_put_u32(vendor_event, NL80211_ATTR_IFINDEX, dev->ifindex);
    if (ret_val) {
        qdf_err("NL80211_ATTR_IFINDEX put fail");
        goto error_cleanup;
    }

    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);
    if (!nla){
        qdf_err("nla_nest_start fail nla is NULL ");
        goto error_cleanup;
    }

    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);
#endif

    if (nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_RULE_ID,
                    scs_rule_intf->rule_id)) {
        qdf_err("nla_put fail for rule_id.");
        goto error_cleanup;
    }

    if (nla_put_u8(vendor_event,
                   QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_REQUEST_TYPE,
                   scs_rule_intf->req_type)) {
        qdf_err("nla_put fail for request_type.");
        goto error_cleanup;
    }

    /* Other attributes are not required when request type is Remove_Rule */
    if (scs_rule_intf->req_type == IEEE80211_SCS_REMOVE_RULE)
        goto send_event;

    if (nla_put_u8(vendor_event,
                   QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_OUTPUT_TID,
                   scs_rule_intf->output_tid)) {
        qdf_err("nla_put fail for user_priority.");
        goto error_cleanup;
    }

    if (nla_put_u8(vendor_event,
                   QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_CLASSIFIER_TYPE,
                   scs_rule_intf->classifier_type)) {
        qdf_err("nla_put fail for classifier_type.");
        goto error_cleanup;
    }

    /* Setting attributes for TCLAS4 elements */
    if (scs_rule_intf->classifier_type & IEEE80211_WNM_TCLAS_CLASSIFIER_TYPE4) {
        classifier_mask = scs_rule_intf->tclas4_element.classifier_mask;

        if (classifier_mask & IEEE80211_SCS_TCLAS4_VERSION) {
            if (nla_put_u8(vendor_event,
                           QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_VERSION,
                           scs_rule_intf->tclas4_element.version)) {
               qdf_err("nla_put fail for version.");
               goto error_cleanup;
            }
        } else {
            /* Version field is mandatory for TCLAS4 element */
            qdf_err("Version field for TCLAS4 element missing.");
            goto error_cleanup;
        }

        if (classifier_mask & IEEE80211_SCS_TCLAS4_SRC_IP) {
            if(scs_rule_intf->tclas4_element.version == IEEE80211_WNM_TCLAS_CLAS14_VERSION_4) {
                if (nla_put(vendor_event,
                            QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_SRC_IPV4_ADDR,
                            IEEE80211_IPV4_LEN,
                            scs_rule_intf->tclas4_element.src_ip_addr.ipv4)) {
                    qdf_err("nla_put fail for src_ipv4_addr.");
                    goto error_cleanup;
                }
            } else if (scs_rule_intf->tclas4_element.version == IEEE80211_WNM_TCLAS_CLAS14_VERSION_6) {
                if (nla_put(vendor_event,
                            QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_SRC_IPV6_ADDR,
                            IEEE80211_IPV6_LEN,
                            scs_rule_intf->tclas4_element.src_ip_addr.ipv6)) {
                    qdf_err("nla_put fail for src_ipv6_addr.");
                    goto error_cleanup;
                }
            }
        }

        if (classifier_mask & IEEE80211_SCS_TCLAS4_DST_IP) {
            if (scs_rule_intf->tclas4_element.version == IEEE80211_WNM_TCLAS_CLAS14_VERSION_4) {
                if (nla_put(vendor_event,
                            QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_DST_IPV4_ADDR,
                            IEEE80211_IPV4_LEN,
                            scs_rule_intf->tclas4_element.dst_ip_addr.ipv4)) {
                    qdf_err("nla_put fail for dst_ipv4_addr.");
                    goto error_cleanup;
                }
            } else if(scs_rule_intf->tclas4_element.version == IEEE80211_WNM_TCLAS_CLAS14_VERSION_6) {
                if (nla_put(vendor_event,
                            QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_DST_IPV6_ADDR,
                            IEEE80211_IPV6_LEN,
                            scs_rule_intf->tclas4_element.dst_ip_addr.ipv6)) {
                    qdf_err("nla_put fail for dst_ipv6_addr.") ;
                    goto error_cleanup;
                }
            }
        }

        if (classifier_mask & IEEE80211_SCS_TCLAS4_SRC_PORT) {
            if (nla_put_u16(vendor_event,
                           QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_SRC_PORT,
                           scs_rule_intf->tclas4_element.src_port)) {
                qdf_err("nla_put fail for src_port.");
                goto error_cleanup;
            }
        }

        if (classifier_mask & IEEE80211_SCS_TCLAS4_DST_PORT) {
            if (nla_put_u16(vendor_event,
                            QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_DST_PORT,
                            scs_rule_intf->tclas4_element.dst_port)) {
                qdf_err("nla_put fail for dst_port.");
                goto error_cleanup;
            }
        }

        if (classifier_mask & IEEE80211_SCS_TCLAS4_DSCP) {
            if (nla_put_u8(vendor_event,
                           QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_DSCP,
                           scs_rule_intf->tclas4_element.dscp)) {
                qdf_err("nla_put fail for dscp.") ;
                goto error_cleanup;
            }
        }

        if (classifier_mask & IEEE80211_SCS_TCLAS4_NEXT_HEADER) {
            if (nla_put_u8(vendor_event,
                           QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_NEXT_HEADER,
                           scs_rule_intf->tclas4_element.next_header)) {
                qdf_err("nal_put fail for next_header.");
                goto error_cleanup;
           }
        }

        if (classifier_mask & IEEE80211_SCS_TCLAS4_FLOW_LABEL) {
            if (nla_put(vendor_event,
                        QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS4_FLOW_LABEL,
                        3 * sizeof(uint8_t),
                        scs_rule_intf->tclas4_element.flow_label)) {
                qdf_err("nla_put fail for flow_label.");
                goto error_cleanup;
            }
        }
    }

    /* Setting attributes for TCLAS10 elements */
    if (scs_rule_intf->classifier_type & IEEE80211_WNM_TCLAS_CLASSIFIER_TYPE10) {
        if (nla_put_u8(vendor_event,
                       QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS10_PROTOCOL_INSTANCE,
                       scs_rule_intf->tclas10_element.protocol_instance)) {
            qdf_err("nla_put fail for protocol_instance.");
            goto error_cleanup;
        }

        if (nla_put_u8(vendor_event,
                       QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS10_NEXT_HEADER,
                       scs_rule_intf->tclas10_element.protocol_no)) {
            qdf_err("nla_put fail for protocol no.");
            goto error_cleanup;
        }

        if (nla_put(vendor_event,
                    QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS10_FILTER_MASK,
                    scs_rule_intf->tclas10_element.filter_length,
                    scs_rule_intf->tclas10_element.filter_mask)) {
            qdf_err("nla_put fail for filter_mask");
            goto error_cleanup;
        }

        if (nla_put(vendor_event,
                    QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_TCLAS10_FILTER_VALUE,
                    scs_rule_intf->tclas10_element.filter_length,
                    scs_rule_intf->tclas10_element.filter_value)) {
            qdf_err("nla_put fail for filter_value");
            goto error_cleanup;
        }
    }

#ifdef QCA_SUPPORT_WDS_EXTENDED
    if (scs_rule_intf->dst_mac_addr_valid) {
        if (nla_put(vendor_event,
                    QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_DST_MAC_ADDR,
                    QDF_MAC_ADDR_SIZE,
                    scs_rule_intf->dst_mac_addr)) {
            qdf_err("nla_put fail for dst_mac_addr.") ;
            goto error_cleanup;
        }
    }

    if (scs_rule_intf->netdev_if_index_valid) {
        if (nla_put_u32(vendor_event,
                        QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_NETDEV_IF_INDEX,
                        scs_rule_intf->netdev_if_index)) {
            qdf_err("nla_put fail for netdev_index.") ;
            goto error_cleanup;
        }
    }
#endif

send_event:
    /* Setting attribute for service class id */
    if (scs_rule_intf->service_class_id != IEEE80211_QOS_ATTR_INVALID_SERVICE_CLASS_ID) {
        if (nla_put_u16(vendor_event,
                        QCA_WLAN_VENDOR_ATTR_SCS_RULE_CONFIG_SERVICE_CLASS_ID,
                        scs_rule_intf->service_class_id)) {
            qdf_err("nla_put fail for service_class_id");
            goto error_cleanup;
        }
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(vendor_event, nla);
#endif

    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);
    return;

error_cleanup:
    wlan_cfg80211_vendor_free_skb(vendor_event);
    return;
}

qdf_export_symbol(wlan_cfg80211_scs_rule_config);

#ifdef WLAN_SUPPORT_SCS_API
void process_nl_msg_send_scs_api_forward_scs_req(struct ieee80211_node *ni,
                                                 uint8_t *frm,
                                                 uint32_t frame_length,
                                                 uint8_t *mld_mac_addr,
                                                 bool is_mlo)
{
    struct ieee80211vap *vap = ni->ni_vap;
    struct ieee80211com *ic = vap->iv_ic;
    osif_dev *osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    struct sk_buff *vendor_event;
    struct net_device *dev = osif->netdev;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
    int ret_val;
#endif

    if (frame_length > SCS_API_REQ_BUF_MAX_SIZE) {
        scs_err("Err: Frame length > max SCS request buf size");
        return;
    }

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    if (!osif_vap_event_filter_status_to_app(vap, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_SCS_API_MSG_INDEX)) {
        return;
    }
    vendor_event =
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, NULL,
#else
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy,
                                                    dev->ieee80211_ptr,
#endif
                      MAX_CFG80211_BUF_LEN,
                      QCA_NL80211_VENDOR_SUBCMD_SCS_API_MSG_INDEX, GFP_ATOMIC);

    if (!vendor_event) {
        qdf_err("cfg80211_vendor_event_alloc failed");
        return;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);
    ret_val = nla_put_u32(vendor_event, NL80211_ATTR_IFINDEX, dev->ifindex);
    if (ret_val) {
        qdf_err("NL80211_ATTR_IFINDEX put fail");
        goto error_cleanup;
    }

    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);
    if (!nla) {
        qdf_err("nla_nest_start fail nla is NULL");
        goto error_cleanup;
    }

    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);
#endif

    if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TYPE,
                   QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TYPE_SCS_REQUEST)) {
        qdf_err("nla_put fail for msg_type");
        goto error_cleanup;
    }

    /* Link MAC is sent as a NL param for both MLO/Non-MLO connection */
    if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_PEER_MAC,
                QDF_MAC_ADDR_SIZE, ni->ni_macaddr)) {
        qdf_err("nla_put fail for peer mac");
        goto error_cleanup;
    }

#ifdef WLAN_FEATURE_11BE_MLO
    /* MLD MAC is sent only in case of MLO */
    if (is_mlo) {
        if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MLD_MAC,
                    QDF_MAC_ADDR_SIZE, mld_mac_addr)) {
            qdf_err("nla_put fail for MLD  mac");
            goto error_cleanup;
        }
    }
#endif

    if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DATA,
                frame_length, frm)) {
        qdf_err("nla_put fail for SCS req frame");
        goto error_cleanup;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(vendor_event, nla);
#endif

    scs_info("Send NL message - SCS Frame");
    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);

    return;

error_cleanup:
    wlan_cfg80211_vendor_free_skb(vendor_event);
    return;
}

void ieee80211_forward_scs_req(struct ieee80211_node *ni, uint8_t *frm,
                               uint32_t frame_length)
{
    uint8_t mld_mac_addr[QDF_MAC_ADDR_SIZE];
    bool is_mlo = false;
#ifdef WLAN_FEATURE_11BE_MLO
    struct wlan_objmgr_peer *peer;
    struct wlan_mlo_peer_context *ml_peer;

    peer = ni->peer_obj;
    if (!peer) {
        scs_err("Peer obj is NULL");
        return;
    }

    /* Check if the node corresponds to a MLD STA */
    if (wlan_peer_is_mlo(peer)) {
        ml_peer = peer->mlo_peer_ctx;
        if (!ml_peer) {
            scs_err("MLO Peer is NULL");
            return;
        }

        is_mlo = true;
        IEEE80211_ADDR_COPY(mld_mac_addr, ml_peer->peer_mld_addr.bytes);
    }
#endif

    process_nl_msg_send_scs_api_forward_scs_req(ni, frm, frame_length,
                                                mld_mac_addr, is_mlo);
}

qdf_export_symbol(ieee80211_forward_scs_req);

void ieee80211_send_scs_api_drv_response(
                    struct ieee80211_node *ni, uint8_t dialog_token,
                    struct scs_api_drv_resp *scs_drv_response,
                    uint8_t num_scs_descriptor, uint8_t *mld_mac_addr,
                    bool is_mlo)
{
    struct ieee80211vap *vap = ni->ni_vap;
    struct ieee80211com *ic = vap->iv_ic;
    osif_dev *osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    struct sk_buff *vendor_event;
    struct net_device *dev = osif->netdev;
    uint16_t size;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
    int ret_val;
#endif

    size = num_scs_descriptor * sizeof(struct scs_api_drv_resp);
    if (size > SCS_API_RESP_BUF_MAX_SIZE) {
        scs_err("Err: Drv response size > Max buf size");
        return;
    }

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    vendor_event =
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, NULL,
#else
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy,
                                                    dev->ieee80211_ptr,
#endif
                      MAX_CFG80211_BUF_LEN,
                      QCA_NL80211_VENDOR_SUBCMD_SCS_API_MSG_INDEX, GFP_ATOMIC);

    if (!vendor_event) {
        qdf_err("cfg80211_vendor_event_alloc failed");
        return;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);
    ret_val = nla_put_u32(vendor_event, NL80211_ATTR_IFINDEX, dev->ifindex);
    if (ret_val) {
        qdf_err("NL80211_ATTR_IFINDEX put fail");
        goto error_cleanup;
    }

    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);
    if (!nla) {
        qdf_err("nla_nest_start fail nla is NULL");
        goto error_cleanup;
    }

    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);
#endif

    if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TYPE,
                    QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TYPE_DRIVER_RESPONSE)) {
        qdf_err("nla_put fail for msg_type");
        goto error_cleanup;
    }

    if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_PEER_MAC,
                QDF_MAC_ADDR_SIZE, ni->ni_macaddr)) {
        qdf_err("nla_put fail for peer mac");
        goto error_cleanup;
    }

#ifdef WLAN_FEATURE_11BE_MLO
    /* MLD MAC is sent only in case of MLO */
    if (is_mlo) {
        if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_MLD_MAC,
                    QDF_MAC_ADDR_SIZE, mld_mac_addr)) {
            qdf_err("nla_put fail for MLD  mac");
            goto error_cleanup;
        }
    }
#endif

    if (nla_put_u8(vendor_event,
                   QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DIALOG_TOKEN,
                   dialog_token)) {
        qdf_err("nla_put fail for dialog token");
        goto error_cleanup;
    }

    if (nla_put_u8(vendor_event,
                   QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_TOTAL_SCS_IDX,
                   num_scs_descriptor)) {
        qdf_err("nla_put fail for SCS Index");
        goto error_cleanup;
    }

    if (nla_put(vendor_event,
                QCA_WLAN_VENDOR_ATTR_SCS_API_MSG_DATA, size,
                scs_drv_response)) {
        qdf_err("nla_put fail for driver response param.");
        goto error_cleanup;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(vendor_event, nla);
#endif

    scs_info("Send NL message - SCS driver response");
    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);
    return;

error_cleanup:
    wlan_cfg80211_vendor_free_skb(vendor_event);
    return;
}

qdf_export_symbol(ieee80211_send_scs_api_drv_response);

#endif /* WLAN_SUPPORT_SCS_API */

#ifdef SAWF_ADMISSION_CONTROL
void wlan_cfg80211_send_scs_adm_ctrl_req(wlan_if_t vap,
                         struct ieee80211_scs_adm_ctrl_intf *scs_adm_ctrl_intf)
{
    struct ieee80211com *ic = vap->iv_ic;
    osif_dev *osif = (osif_dev *)wlan_vap_get_registered_handle(vap);
    struct sk_buff *vendor_event;
    struct net_device *dev = osif->netdev;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    struct nlattr *nla;
    int ret_val;
#endif
    struct nlattr *scs_data, *scs_request;
    uint8_t index = 0;

#define VENDOR_CMD_CB_ASSIGN(a, b) ((void **)a->cb)[2] = b

    if (!osif_vap_event_filter_status_to_app(vap, EVENT_CFG,
                QCA_NL80211_VENDOR_SUBCMD_SCS_ADM_CTRL_INDEX)) {
        return;
    }
    vendor_event =
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy, NULL,
#else
                   wlan_cfg80211_vendor_event_alloc(ic->ic_wiphy,
                                                    dev->ieee80211_ptr,
#endif
                        MAX_CFG80211_BUF_LEN,
                        QCA_NL80211_VENDOR_SUBCMD_SCS_ADM_CTRL_INDEX,
                        GFP_ATOMIC);

    if (!vendor_event) {
        qdf_err("cfg80211_vendor_event_alloc failed.");
        return;
    }

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_cancel(vendor_event, ((void **)vendor_event->cb)[2]);
    ret_val = nla_put_u32(vendor_event, NL80211_ATTR_IFINDEX, dev->ifindex);
    if (ret_val) {
        qdf_err("NL80211_ATTR_IFINDEX put fail");
        goto error_cleanup;
    }

    nla = nla_nest_start(vendor_event, NL80211_ATTR_VENDOR_DATA);
    if (!nla){
        qdf_err("nla_nest_start fail nla is NULL ");
        goto error_cleanup;
    }

    VENDOR_CMD_CB_ASSIGN(vendor_event, nla);
#endif

    if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_DIALOG_TOKEN,
                   scs_adm_ctrl_intf->dialog_token)) {
        qdf_err("nla_put fail for dialog_token.");
        goto error_cleanup;
    }

    if (nla_put_u16(vendor_event,
                   QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_HW_LINK_ID,
                   scs_adm_ctrl_intf->hw_link_id)) {
        qdf_err("nla_put fail for hw_link_id.");
        goto error_cleanup;
    }

    if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_PEER_MAC,
                QDF_MAC_ADDR_SIZE, scs_adm_ctrl_intf->peer_mac_addr)) {
        qdf_err("nla_put fail for peer_mac_addr.") ;
        goto error_cleanup;
    }

    if (scs_adm_ctrl_intf->is_mlo_peer) {
        if (nla_put(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_PEER_MLD_MAC,
                    QDF_MAC_ADDR_SIZE, scs_adm_ctrl_intf->peer_mld_mac_addr)) {
            qdf_err("nla_put fail for peer_mld_mac_addr.");
            goto error_cleanup;
        }
    }


    if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_NUM_SCS_REQS,
                   scs_adm_ctrl_intf->num_scs_reqs)) {
        qdf_err("nla_put fail for num_scs_reqs.");
        goto error_cleanup;
    }

    scs_data = nla_nest_start(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_ADM_CTRL_SCS_DATA);
    if (!scs_data) {
        qdf_err("nla_nest_start fail for scs_data.");
        goto error_cleanup;
    }

    for (index = 0; index < scs_adm_ctrl_intf->num_scs_reqs && index < IEEE80211_SCS_MAX_SIZE; index++) {
        scs_request = nla_nest_start(vendor_event, index);
        if (!scs_request) {
            qdf_err("nla_nest_start fail for scs_request");
            goto error_cleanup;
        }

        if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_DATA_SCSID,
                       scs_adm_ctrl_intf->scs_info[index].scsid)) {
            qdf_err("nla_put fail for scsid.");
            goto error_cleanup;
        }

        if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_DATA_ACCESS_CATEGORY,
                       scs_adm_ctrl_intf->scs_info[index].ac)) {
            qdf_err("nla_put fail for access_category.");
            goto error_cleanup;
        }

        if (nla_put_u8(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_DATA_TID,
                       scs_adm_ctrl_intf->scs_info[index].tid)) {
            qdf_err("nla_put fail for tid");
            goto error_cleanup;
        }

        if (nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_DATA_SERVICE_INTERVAL,
                        scs_adm_ctrl_intf->scs_info[index].service_interval)) {
            qdf_err("nla_put fail for service_interval");
            goto error_cleanup;
        }

        if (nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_DATA_DELAY_BOUND,
                        scs_adm_ctrl_intf->scs_info[index].delay_bound)) {
            qdf_err("nla_put fail for delay_bound.");
            goto error_cleanup;
        }

        if (nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_DATA_BURST_SIZE,
                        scs_adm_ctrl_intf->scs_info[index].burst_size)) {
            qdf_err("nla_put fail for burst_size.");
            goto error_cleanup;
        }

        if (nla_put_u32(vendor_event, QCA_WLAN_VENDOR_ATTR_SCS_DATA_MIN_DATA_RATE,
                        scs_adm_ctrl_intf->scs_info[index].min_data_rate)) {
            qdf_err("nla_put fail for min_data_rate.");
            goto error_cleanup;
        }

        nla_nest_end(vendor_event, scs_request);
    }

    nla_nest_end(vendor_event, scs_data);

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 24))
    nla_nest_end(vendor_event, nla);
#endif

    wlan_cfg80211_vendor_event(vendor_event, GFP_ATOMIC);
    return;

error_cleanup:
    wlan_cfg80211_vendor_free_skb(vendor_event);
    return;
}

qdf_export_symbol(wlan_cfg80211_send_scs_adm_ctrl_req);
#endif /* SAWF_ADMISSION_CONTROL */
#endif /* WLAN_SUPPORT_SCS */

#endif
